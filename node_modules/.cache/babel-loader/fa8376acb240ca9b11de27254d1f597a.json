{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { nftSources } from 'config/constants/nfts';\nimport { getAddress } from 'utils/addressHelpers';\nimport { getErc721Contract } from 'utils/contractHelpers';\nimport { getNftByTokenId } from 'utils/collectibles';\nconst initialState = {\n  isInitialized: false,\n  isLoading: true,\n  data: {}\n};\n// Thunks\nexport const fetchWalletNfts = createAsyncThunk('collectibles/fetchWalletNfts', async account => {\n  // For each nft source get nft data\n  const nftSourcePromises = Object.keys(nftSources).map(async nftSourceType => {\n    const {\n      address: addressObj\n    } = nftSources[nftSourceType];\n    const address = getAddress(addressObj);\n    const contract = getErc721Contract(address);\n\n    const getTokenIdAndData = async index => {\n      try {\n        const tokenIdBn = await contract.tokenOfOwnerByIndex(account, index);\n        const tokenId = tokenIdBn.toNumber();\n        const walletNft = await getNftByTokenId(address, tokenId);\n        return [tokenId, walletNft.identifier];\n      } catch (error) {\n        console.error('getTokenIdAndData', error);\n        return null;\n      }\n    };\n\n    const balanceOfResponse = await contract.balanceOf(account);\n    const balanceOf = balanceOfResponse.toNumber();\n\n    if (balanceOf === 0) {\n      return [];\n    }\n\n    const nftDataFetchPromises = []; // For each index get the tokenId and data associated with it\n\n    for (let i = 0; i < balanceOf; i++) {\n      nftDataFetchPromises.push(getTokenIdAndData(i));\n    }\n\n    const nftData = await Promise.all(nftDataFetchPromises);\n    return nftData;\n  });\n  const nftSourceData = await Promise.all(nftSourcePromises);\n  return nftSourceData.flat();\n});\nexport const collectiblesSlice = createSlice({\n  name: 'collectibles',\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchWalletNfts.pending, state => {\n      state.isLoading = true;\n    });\n    builder.addCase(fetchWalletNfts.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.isInitialized = true;\n      state.data = action.payload.reduce((accum, association) => {\n        if (!association) {\n          return accum;\n        }\n\n        const [tokenId, identifier] = association;\n        return { ...accum,\n          [identifier]: accum[identifier] ? [...accum[identifier], tokenId] : [tokenId]\n        };\n      }, {});\n    });\n  }\n});\nexport default collectiblesSlice.reducer;","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/collectibles/index.ts"],"names":["createAsyncThunk","createSlice","nftSources","getAddress","getErc721Contract","getNftByTokenId","initialState","isInitialized","isLoading","data","fetchWalletNfts","account","nftSourcePromises","Object","keys","map","nftSourceType","address","addressObj","contract","getTokenIdAndData","index","tokenIdBn","tokenOfOwnerByIndex","tokenId","toNumber","walletNft","identifier","error","console","balanceOfResponse","balanceOf","nftDataFetchPromises","i","push","nftData","Promise","all","nftSourceData","flat","collectiblesSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","reduce","accum","association","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\r\nimport { CollectiblesState } from 'state/types'\r\nimport { nftSources } from 'config/constants/nfts'\r\nimport { NftType } from 'config/constants/types'\r\nimport { getAddress } from 'utils/addressHelpers'\r\nimport { getErc721Contract } from 'utils/contractHelpers'\r\nimport { getNftByTokenId } from 'utils/collectibles'\r\nimport { ethers } from 'ethers'\r\n\r\nconst initialState: CollectiblesState = {\r\n  isInitialized: false,\r\n  isLoading: true,\r\n  data: {},\r\n}\r\n\r\ntype NftSourceItem = [number, string]\r\n\r\n// Thunks\r\nexport const fetchWalletNfts = createAsyncThunk<NftSourceItem[], string>(\r\n  'collectibles/fetchWalletNfts',\r\n  async (account) => {\r\n    // For each nft source get nft data\r\n    const nftSourcePromises = Object.keys(nftSources).map(async (nftSourceType) => {\r\n      const { address: addressObj } = nftSources[nftSourceType as NftType]\r\n      const address = getAddress(addressObj)\r\n      const contract = getErc721Contract(address)\r\n\r\n      const getTokenIdAndData = async (index: number) => {\r\n        try {\r\n          const tokenIdBn: ethers.BigNumber = await contract.tokenOfOwnerByIndex(account, index)\r\n          const tokenId = tokenIdBn.toNumber()\r\n\r\n          const walletNft = await getNftByTokenId(address, tokenId)\r\n          return [tokenId, walletNft.identifier]\r\n        } catch (error) {\r\n          console.error('getTokenIdAndData', error)\r\n          return null\r\n        }\r\n      }\r\n\r\n      const balanceOfResponse = await contract.balanceOf(account)\r\n      const balanceOf = balanceOfResponse.toNumber()\r\n\r\n      if (balanceOf === 0) {\r\n        return []\r\n      }\r\n\r\n      const nftDataFetchPromises = []\r\n\r\n      // For each index get the tokenId and data associated with it\r\n      for (let i = 0; i < balanceOf; i++) {\r\n        nftDataFetchPromises.push(getTokenIdAndData(i))\r\n      }\r\n\r\n      const nftData = await Promise.all(nftDataFetchPromises)\r\n      return nftData\r\n    })\r\n\r\n    const nftSourceData = await Promise.all(nftSourcePromises)\r\n\r\n    return nftSourceData.flat()\r\n  },\r\n)\r\n\r\nexport const collectiblesSlice = createSlice({\r\n  name: 'collectibles',\r\n  initialState,\r\n  reducers: {},\r\n  extraReducers: (builder) => {\r\n    builder.addCase(fetchWalletNfts.pending, (state) => {\r\n      state.isLoading = true\r\n    })\r\n    builder.addCase(fetchWalletNfts.fulfilled, (state, action) => {\r\n      state.isLoading = false\r\n      state.isInitialized = true\r\n      state.data = action.payload.reduce((accum, association) => {\r\n        if (!association) {\r\n          return accum\r\n        }\r\n\r\n        const [tokenId, identifier] = association as NftSourceItem\r\n\r\n        return {\r\n          ...accum,\r\n          [identifier]: accum[identifier] ? [...accum[identifier], tokenId] : [tokenId],\r\n        }\r\n      }, {})\r\n    })\r\n  },\r\n})\r\n\r\nexport default collectiblesSlice.reducer\r\n"]},"metadata":{},"sourceType":"module"}