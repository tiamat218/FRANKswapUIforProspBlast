{"ast":null,"code":"var $schema = \"http://json-schema.org/draft-07/schema#\";\nvar $id = \"https://uniswap.org/tokenlist.schema.json\";\nvar title = \"Uniswap Token List\";\nvar description = \"Schema for lists of tokens compatible with the Uniswap Interface\";\nvar definitions = {\n  Version: {\n    type: \"object\",\n    description: \"The version of the list, used in change detection\",\n    examples: [{\n      major: 1,\n      minor: 0,\n      patch: 0\n    }],\n    additionalProperties: false,\n    properties: {\n      major: {\n        type: \"integer\",\n        description: \"The major version of the list. Must be incremented when tokens are removed from the list or token addresses are changed.\",\n        minimum: 0,\n        examples: [1, 2]\n      },\n      minor: {\n        type: \"integer\",\n        description: \"The minor version of the list. Must be incremented when tokens are added to the list.\",\n        minimum: 0,\n        examples: [0, 1]\n      },\n      patch: {\n        type: \"integer\",\n        description: \"The patch version of the list. Must be incremented for any changes to the list.\",\n        minimum: 0,\n        examples: [0, 1]\n      }\n    },\n    required: [\"major\", \"minor\", \"patch\"]\n  },\n  TagIdentifier: {\n    type: \"string\",\n    description: \"The unique identifier of a tag\",\n    minLength: 1,\n    maxLength: 10,\n    pattern: \"^[\\\\w]+$\",\n    examples: [\"compound\", \"stablecoin\"]\n  },\n  ExtensionIdentifier: {\n    type: \"string\",\n    description: \"The name of a token extension property\",\n    minLength: 1,\n    maxLength: 30,\n    pattern: \"^[\\\\w]+$\",\n    examples: [\"color\", \"is_fee_on_transfer\", \"aliases\"]\n  },\n  ExtensionValue: {\n    anyOf: [{\n      type: \"string\",\n      minLength: 1,\n      maxLength: 42,\n      examples: [\"#00000\"]\n    }, {\n      type: \"boolean\",\n      examples: [true]\n    }, {\n      type: \"number\",\n      examples: [15]\n    }, {\n      type: \"null\"\n    }]\n  },\n  TagDefinition: {\n    type: \"object\",\n    description: \"Definition of a tag that can be associated with a token via its identifier\",\n    additionalProperties: false,\n    properties: {\n      name: {\n        type: \"string\",\n        description: \"The name of the tag\",\n        pattern: \"^[ \\\\w]+$\",\n        minLength: 1,\n        maxLength: 20\n      },\n      description: {\n        type: \"string\",\n        description: \"A user-friendly description of the tag\",\n        pattern: \"^[ \\\\w\\\\.,]+$\",\n        minLength: 1,\n        maxLength: 200\n      }\n    },\n    required: [\"name\", \"description\"],\n    examples: [{\n      name: \"Stablecoin\",\n      description: \"A token with value pegged to another asset\"\n    }]\n  },\n  TokenInfo: {\n    type: \"object\",\n    description: \"Metadata for a single token in a token list\",\n    additionalProperties: false,\n    properties: {\n      chainId: {\n        type: \"integer\",\n        description: \"The chain ID of the Ethereum network where this token is deployed\",\n        minimum: 1,\n        examples: [1, 42]\n      },\n      address: {\n        type: \"string\",\n        description: \"The checksummed address of the token on the specified chain ID\",\n        pattern: \"^0x[a-fA-F0-9]{40}$\",\n        examples: [\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"]\n      },\n      decimals: {\n        type: \"integer\",\n        description: \"The number of decimals for the token balance\",\n        minimum: 0,\n        maximum: 255,\n        examples: [18]\n      },\n      name: {\n        type: \"string\",\n        description: \"The name of the token\",\n        minLength: 1,\n        maxLength: 40,\n        pattern: \"^[ \\\\w.'+\\\\-%/À-ÖØ-öø-ÿ\\\\:]+$\",\n        examples: [\"USD Coin\"]\n      },\n      symbol: {\n        type: \"string\",\n        description: \"The symbol for the token; must be alphanumeric\",\n        pattern: \"^[a-zA-Z0-9+\\\\-%/\\\\$]+$\",\n        minLength: 1,\n        maxLength: 20,\n        examples: [\"USDC\"]\n      },\n      logoURI: {\n        type: \"string\",\n        description: \"A URI to the token logo asset; if not set, interface will attempt to find a logo based on the token address; suggest SVG or PNG of size 64x64\",\n        format: \"uri\",\n        examples: [\"ipfs://QmXfzKRvjZz3u5JRgC4v5mGVbm9ahrUiB4DgzHBsnWbTMM\"]\n      },\n      tags: {\n        type: \"array\",\n        description: \"An array of tag identifiers associated with the token; tags are defined at the list level\",\n        items: {\n          $ref: \"#/definitions/TagIdentifier\"\n        },\n        maxLength: 10,\n        examples: [\"stablecoin\", \"compound\"]\n      },\n      extensions: {\n        type: \"object\",\n        description: \"An object containing any arbitrary or vendor-specific token metadata\",\n        propertyNames: {\n          $ref: \"#/definitions/ExtensionIdentifier\"\n        },\n        additionalProperties: {\n          $ref: \"#/definitions/ExtensionValue\"\n        },\n        maxProperties: 10,\n        examples: [{\n          color: \"#000000\",\n          is_verified_by_me: true\n        }]\n      }\n    },\n    required: [\"chainId\", \"address\", \"decimals\", \"name\", \"symbol\"]\n  }\n};\nvar type = \"object\";\nvar additionalProperties = false;\nvar properties = {\n  name: {\n    type: \"string\",\n    description: \"The name of the token list\",\n    minLength: 1,\n    maxLength: 20,\n    pattern: \"^[\\\\w ]+$\",\n    examples: [\"My Token List\"]\n  },\n  timestamp: {\n    type: \"string\",\n    format: \"date-time\",\n    description: \"The timestamp of this list version; i.e. when this immutable version of the list was created\"\n  },\n  version: {\n    $ref: \"#/definitions/Version\"\n  },\n  tokens: {\n    type: \"array\",\n    description: \"The list of tokens included in the list\",\n    items: {\n      $ref: \"#/definitions/TokenInfo\"\n    },\n    minItems: 1,\n    maxItems: 10000\n  },\n  keywords: {\n    type: \"array\",\n    description: \"Keywords associated with the contents of the list; may be used in list discoverability\",\n    items: {\n      type: \"string\",\n      description: \"A keyword to describe the contents of the list\",\n      minLength: 1,\n      maxLength: 20,\n      pattern: \"^[\\\\w ]+$\",\n      examples: [\"compound\", \"lending\", \"personal tokens\"]\n    },\n    maxItems: 20,\n    uniqueItems: true\n  },\n  tags: {\n    type: \"object\",\n    description: \"A mapping of tag identifiers to their name and description\",\n    propertyNames: {\n      $ref: \"#/definitions/TagIdentifier\"\n    },\n    additionalProperties: {\n      $ref: \"#/definitions/TagDefinition\"\n    },\n    maxProperties: 20,\n    examples: [{\n      stablecoin: {\n        name: \"Stablecoin\",\n        description: \"A token with value pegged to another asset\"\n      }\n    }]\n  },\n  logoURI: {\n    type: \"string\",\n    description: \"A URI for the logo of the token list; prefer SVG or PNG of size 256x256\",\n    format: \"uri\",\n    examples: [\"ipfs://QmXfzKRvjZz3u5JRgC4v5mGVbm9ahrUiB4DgzHBsnWbTMM\"]\n  }\n};\nvar required = [\"name\", \"timestamp\", \"version\", \"tokens\"];\nvar tokenlist_schema = {\n  $schema: $schema,\n  $id: $id,\n  title: title,\n  description: description,\n  definitions: definitions,\n  type: type,\n  additionalProperties: additionalProperties,\n  properties: properties,\n  required: required\n};\n\n/**\r\n * Comparator function that allows sorting version from lowest to highest\r\n * @param versionA version A to compare\r\n * @param versionB version B to compare\r\n * @returns -1 if versionA comes before versionB, 0 if versionA is equal to version B, and 1 if version A comes after version B\r\n */\nfunction versionComparator(versionA, versionB) {\n  if (versionA.major < versionB.major) {\n    return -1;\n  } else if (versionA.major > versionB.major) {\n    return 1;\n  } else if (versionA.minor < versionB.minor) {\n    return -1;\n  } else if (versionA.minor > versionB.minor) {\n    return 1;\n  } else if (versionA.patch < versionB.patch) {\n    return -1;\n  } else if (versionA.patch > versionB.patch) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n/**\r\n * Returns true if versionB is an update over versionA\r\n */\n\nfunction isVersionUpdate(base, update) {\n  return versionComparator(base, update) < 0;\n}\nvar VersionUpgrade;\n(function (VersionUpgrade) {\n  VersionUpgrade[VersionUpgrade[\"NONE\"] = 0] = \"NONE\";\n  VersionUpgrade[VersionUpgrade[\"PATCH\"] = 1] = \"PATCH\";\n  VersionUpgrade[VersionUpgrade[\"MINOR\"] = 2] = \"MINOR\";\n  VersionUpgrade[VersionUpgrade[\"MAJOR\"] = 3] = \"MAJOR\";\n})(VersionUpgrade || (VersionUpgrade = {}));\n/**\r\n * Return the upgrade type from the base version to the update version.\r\n * Note that downgrades and equivalent versions are both treated as `NONE`.\r\n * @param base base list\r\n * @param update update to the list\r\n */\n\nfunction getVersionUpgrade(base, update) {\n  if (update.major > base.major) {\n    return VersionUpgrade.MAJOR;\n  }\n  if (update.major < base.major) {\n    return VersionUpgrade.NONE;\n  }\n  if (update.minor > base.minor) {\n    return VersionUpgrade.MINOR;\n  }\n  if (update.minor < base.minor) {\n    return VersionUpgrade.NONE;\n  }\n  return update.patch > base.patch ? VersionUpgrade.PATCH : VersionUpgrade.NONE;\n}\n\n/**\r\n * compares two token info key values\r\n * this subset of full deep equal functionality does not work on objects or object arrays\r\n * @param a comparison item a\r\n * @param b comparison item b\r\n */\nfunction compareTokenInfoProperty(a, b) {\n  if (a === b) return true;\n  if (typeof a !== typeof b) return false;\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.every(function (el, i) {\n      return b[i] === el;\n    });\n  }\n  return false;\n}\n/**\r\n * Computes the diff of a token list where the first argument is the base and the second argument is the updated list.\r\n * @param base base list\r\n * @param update updated list\r\n */\n\nfunction diffTokenLists(base, update) {\n  var indexedBase = base.reduce(function (memo, tokenInfo) {\n    if (!memo[tokenInfo.chainId]) memo[tokenInfo.chainId] = {};\n    memo[tokenInfo.chainId][tokenInfo.address] = tokenInfo;\n    return memo;\n  }, {});\n  var newListUpdates = update.reduce(function (memo, tokenInfo) {\n    var _indexedBase$tokenInf;\n    var baseToken = (_indexedBase$tokenInf = indexedBase[tokenInfo.chainId]) == null ? void 0 : _indexedBase$tokenInf[tokenInfo.address];\n    if (!baseToken) {\n      memo.added.push(tokenInfo);\n    } else {\n      var changes = Object.keys(tokenInfo).filter(function (s) {\n        return s !== 'address' && s !== 'chainId';\n      }).filter(function (s) {\n        return !compareTokenInfoProperty(tokenInfo[s], baseToken[s]);\n      });\n      if (changes.length > 0) {\n        if (!memo.changed[tokenInfo.chainId]) {\n          memo.changed[tokenInfo.chainId] = {};\n        }\n        memo.changed[tokenInfo.chainId][tokenInfo.address] = changes;\n      }\n    }\n    if (!memo.index[tokenInfo.chainId]) {\n      var _memo$index$tokenInfo;\n      memo.index[tokenInfo.chainId] = (_memo$index$tokenInfo = {}, _memo$index$tokenInfo[tokenInfo.address] = true, _memo$index$tokenInfo);\n    } else {\n      memo.index[tokenInfo.chainId][tokenInfo.address] = true;\n    }\n    return memo;\n  }, {\n    added: [],\n    changed: {},\n    index: {}\n  });\n  var removed = base.reduce(function (list, curr) {\n    if (!newListUpdates.index[curr.chainId] || !newListUpdates.index[curr.chainId][curr.address]) {\n      list.push(curr);\n    }\n    return list;\n  }, []);\n  return {\n    added: newListUpdates.added,\n    changed: newListUpdates.changed,\n    removed: removed\n  };\n}\n\n/**\r\n * Returns the minimum version bump for the given list\r\n * @param baseList the base list of tokens\r\n * @param updatedList the updated list of tokens\r\n */\n\nfunction minVersionBump(baseList, updatedList) {\n  var diff = diffTokenLists(baseList, updatedList);\n  if (diff.removed.length > 0) return VersionUpgrade.MAJOR;\n  if (diff.added.length > 0) return VersionUpgrade.MINOR;\n  if (Object.keys(diff.changed).length > 0) return VersionUpgrade.PATCH;\n  return VersionUpgrade.NONE;\n}\n\n/**\r\n * Returns the next version of the list given a base version and the upgrade type\r\n * @param base current version\r\n * @param bump the upgrade type\r\n */\n\nfunction nextVersion(base, bump) {\n  switch (bump) {\n    case VersionUpgrade.NONE:\n      return base;\n    case VersionUpgrade.MAJOR:\n      return {\n        major: base.major + 1,\n        minor: 0,\n        patch: 0\n      };\n    case VersionUpgrade.MINOR:\n      return {\n        major: base.major,\n        minor: base.minor + 1,\n        patch: 0\n      };\n    case VersionUpgrade.PATCH:\n      return {\n        major: base.major,\n        minor: base.minor,\n        patch: base.patch + 1\n      };\n  }\n}\nexport { VersionUpgrade, diffTokenLists, getVersionUpgrade, isVersionUpdate, minVersionBump, nextVersion, tokenlist_schema as schema, versionComparator };","map":{"version":3,"names":["versionComparator","versionA","versionB","major","minor","patch","isVersionUpdate","base","update","VersionUpgrade","getVersionUpgrade","MAJOR","NONE","MINOR","PATCH","compareTokenInfoProperty","a","b","Array","isArray","every","el","i","diffTokenLists","indexedBase","reduce","memo","tokenInfo","chainId","address","newListUpdates","baseToken","_indexedBase$tokenInf","added","push","changes","Object","keys","filter","s","length","changed","index","_memo$index$tokenInfo","removed","list","curr","minVersionBump","baseList","updatedList","diff","nextVersion","bump"],"sources":["../src/versionComparator.ts","../src/isVersionUpdate.ts","../src/getVersionUpgrade.ts","../src/diffTokenLists.ts","../src/minVersionBump.ts","../src/nextVersion.ts"],"sourcesContent":["import { Version } from './types';\n\n/**\n * Comparator function that allows sorting version from lowest to highest\n * @param versionA version A to compare\n * @param versionB version B to compare\n * @returns -1 if versionA comes before versionB, 0 if versionA is equal to version B, and 1 if version A comes after version B\n */\nexport function versionComparator(\n  versionA: Version,\n  versionB: Version\n): -1 | 0 | 1 {\n  if (versionA.major < versionB.major) {\n    return -1;\n  } else if (versionA.major > versionB.major) {\n    return 1;\n  } else if (versionA.minor < versionB.minor) {\n    return -1;\n  } else if (versionA.minor > versionB.minor) {\n    return 1;\n  } else if (versionA.patch < versionB.patch) {\n    return -1;\n  } else if (versionA.patch > versionB.patch) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","import { versionComparator } from './versionComparator';\nimport { Version } from './types';\n\n/**\n * Returns true if versionB is an update over versionA\n */\nexport function isVersionUpdate(base: Version, update: Version): boolean {\n  return versionComparator(base, update) < 0;\n}\n","/**\n * Enum describing types of version differences\n */\nimport { Version } from './types';\n\nexport enum VersionUpgrade {\n  NONE,\n  PATCH,\n  MINOR,\n  MAJOR,\n}\n\n/**\n * Return the upgrade type from the base version to the update version.\n * Note that downgrades and equivalent versions are both treated as `NONE`.\n * @param base base list\n * @param update update to the list\n */\nexport function getVersionUpgrade(\n  base: Version,\n  update: Version\n): VersionUpgrade {\n  if (update.major > base.major) {\n    return VersionUpgrade.MAJOR;\n  }\n  if (update.major < base.major) {\n    return VersionUpgrade.NONE;\n  }\n  if (update.minor > base.minor) {\n    return VersionUpgrade.MINOR;\n  }\n  if (update.minor < base.minor) {\n    return VersionUpgrade.NONE;\n  }\n  return update.patch > base.patch ? VersionUpgrade.PATCH : VersionUpgrade.NONE;\n}\n","import { TokenInfo } from './types';\n\nexport type TokenInfoChangeKey = Exclude<\n  keyof TokenInfo,\n  'address' | 'chainId'\n>;\nexport type TokenInfoChanges = Array<TokenInfoChangeKey>;\n\n/**\n * compares two token info key values\n * this subset of full deep equal functionality does not work on objects or object arrays\n * @param a comparison item a\n * @param b comparison item b\n */\nfunction compareTokenInfoProperty(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  if (typeof a !== typeof b) return false;\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.every((el, i) => b[i] === el);\n  }\n  return false;\n}\n\n/**\n * Differences between a base list and an updated list.\n */\nexport interface TokenListDiff {\n  /**\n   * Tokens from updated with chainId/address not present in base list\n   */\n  readonly added: TokenInfo[];\n  /**\n   * Tokens from base with chainId/address not present in the updated list\n   */\n  readonly removed: TokenInfo[];\n  /**\n   * The token info that changed\n   */\n  readonly changed: {\n    [chainId: number]: {\n      [address: string]: TokenInfoChanges;\n    };\n  };\n}\n\n/**\n * Computes the diff of a token list where the first argument is the base and the second argument is the updated list.\n * @param base base list\n * @param update updated list\n */\nexport function diffTokenLists(\n  base: TokenInfo[],\n  update: TokenInfo[]\n): TokenListDiff {\n  const indexedBase = base.reduce<{\n    [chainId: number]: { [address: string]: TokenInfo };\n  }>((memo, tokenInfo) => {\n    if (!memo[tokenInfo.chainId]) memo[tokenInfo.chainId] = {};\n    memo[tokenInfo.chainId][tokenInfo.address] = tokenInfo;\n    return memo;\n  }, {});\n\n  const newListUpdates = update.reduce<{\n    added: TokenInfo[];\n    changed: {\n      [chainId: number]: {\n        [address: string]: TokenInfoChanges;\n      };\n    };\n    index: {\n      [chainId: number]: {\n        [address: string]: true;\n      };\n    };\n  }>(\n    (memo, tokenInfo) => {\n      const baseToken = indexedBase[tokenInfo.chainId]?.[tokenInfo.address];\n      if (!baseToken) {\n        memo.added.push(tokenInfo);\n      } else {\n        const changes: TokenInfoChanges = Object.keys(tokenInfo)\n          .filter(\n            (s): s is TokenInfoChangeKey => s !== 'address' && s !== 'chainId'\n          )\n          .filter(s => {\n            return !compareTokenInfoProperty(tokenInfo[s], baseToken[s]);\n          });\n        if (changes.length > 0) {\n          if (!memo.changed[tokenInfo.chainId]) {\n            memo.changed[tokenInfo.chainId] = {};\n          }\n          memo.changed[tokenInfo.chainId][tokenInfo.address] = changes;\n        }\n      }\n\n      if (!memo.index[tokenInfo.chainId]) {\n        memo.index[tokenInfo.chainId] = {\n          [tokenInfo.address]: true,\n        };\n      } else {\n        memo.index[tokenInfo.chainId][tokenInfo.address] = true;\n      }\n\n      return memo;\n    },\n    { added: [], changed: {}, index: {} }\n  );\n\n  const removed = base.reduce<TokenInfo[]>((list, curr) => {\n    if (\n      !newListUpdates.index[curr.chainId] ||\n      !newListUpdates.index[curr.chainId][curr.address]\n    ) {\n      list.push(curr);\n    }\n    return list;\n  }, []);\n\n  return {\n    added: newListUpdates.added,\n    changed: newListUpdates.changed,\n    removed,\n  };\n}\n","import { diffTokenLists } from './diffTokenLists';\nimport { VersionUpgrade } from './getVersionUpgrade';\nimport { TokenInfo } from './types';\n\n/**\n * Returns the minimum version bump for the given list\n * @param baseList the base list of tokens\n * @param updatedList the updated list of tokens\n */\nexport function minVersionBump(\n  baseList: TokenInfo[],\n  updatedList: TokenInfo[]\n): VersionUpgrade {\n  const diff = diffTokenLists(baseList, updatedList);\n  if (diff.removed.length > 0) return VersionUpgrade.MAJOR;\n  if (diff.added.length > 0) return VersionUpgrade.MINOR;\n  if (Object.keys(diff.changed).length > 0) return VersionUpgrade.PATCH;\n  return VersionUpgrade.NONE;\n}\n","import { VersionUpgrade } from './getVersionUpgrade';\nimport { Version } from './types';\n\n/**\n * Returns the next version of the list given a base version and the upgrade type\n * @param base current version\n * @param bump the upgrade type\n */\nexport function nextVersion(base: Version, bump: VersionUpgrade): Version {\n  switch (bump) {\n    case VersionUpgrade.NONE:\n      return base;\n\n    case VersionUpgrade.MAJOR:\n      return { major: base.major + 1, minor: 0, patch: 0 };\n\n    case VersionUpgrade.MINOR:\n      return {\n        major: base.major,\n        minor: base.minor + 1,\n        patch: 0,\n      };\n\n    case VersionUpgrade.PATCH:\n      return {\n        major: base.major,\n        minor: base.minor,\n        patch: base.patch + 1,\n      };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}