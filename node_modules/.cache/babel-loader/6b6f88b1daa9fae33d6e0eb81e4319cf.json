{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints';\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed } from './helpers';\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData';\nconst applyNodeDataToUserGraphResponse = (userNodeData, userGraphData, lotteryNodeData) => {\n  //   If no graph rounds response - return node data\n  if (userGraphData.length === 0) {\n    return lotteryNodeData.map(nodeRound => {\n      const ticketDataForRound = userNodeData.find(roundTickets => roundTickets.roundId === nodeRound.lotteryId);\n      return {\n        endTime: nodeRound.endTime,\n        status: nodeRound.status,\n        lotteryId: nodeRound.lotteryId.toString(),\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\n        tickets: ticketDataForRound.userTickets\n      };\n    });\n  }\n\n  //   Else if there is a graph response - merge with node data where node data is more accurate\n  const mergedResponse = userGraphData.map((graphRound, index) => {\n    const nodeRound = lotteryNodeData[index];\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n    if (nodeRound) {\n      const ticketDataForRound = userNodeData.find(roundTickets => roundTickets.roundId === nodeRound.lotteryId);\n      // if isLoading === true, there has been a node error - return graphRound\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          status: nodeRound.status,\n          lotteryId: nodeRound.lotteryId.toString(),\n          claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n          totalTickets: graphRound.totalTickets,\n          tickets: ticketDataForRound.userTickets\n        };\n      }\n      return graphRound;\n    }\n    return graphRound;\n  });\n  return mergedResponse;\n};\nconst getGraphLotteryUser = async account => {\n  let user;\n  const blankUser = {\n    account,\n    totalCake: '',\n    totalTickets: '',\n    rounds: []\n  };\n  try {\n    const response = await request(GRAPH_API_LOTTERY, gql`\n        query getUserLotteries($account: ID!) {\n          user(id: $account) {\n            id\n            totalTickets\n            totalCake\n            rounds(first: 100, orderDirection: desc, orderBy: block) {\n              id\n              lottery {\n                id\n                endTime\n                status\n              }\n              claimed\n              totalTickets\n            }\n          }\n        }\n      `, {\n      account: account.toLowerCase()\n    });\n    const userRes = response.user;\n\n    // If no user returned - return blank user\n    if (!userRes) {\n      user = blankUser;\n    } else {\n      user = {\n        account: userRes.id,\n        totalCake: userRes.totalCake,\n        totalTickets: userRes.totalTickets,\n        rounds: userRes.rounds.map(round => {\n          var _round$lottery, _round$lottery2, _round$lottery3;\n          return {\n            lotteryId: round === null || round === void 0 ? void 0 : (_round$lottery = round.lottery) === null || _round$lottery === void 0 ? void 0 : _round$lottery.id,\n            endTime: round === null || round === void 0 ? void 0 : (_round$lottery2 = round.lottery) === null || _round$lottery2 === void 0 ? void 0 : _round$lottery2.endTime,\n            claimed: round === null || round === void 0 ? void 0 : round.claimed,\n            totalTickets: round === null || round === void 0 ? void 0 : round.totalTickets,\n            status: round === null || round === void 0 ? void 0 : (_round$lottery3 = round.lottery) === null || _round$lottery3 === void 0 ? void 0 : _round$lottery3.status\n          };\n        })\n      };\n    }\n  } catch (error) {\n    console.error(error);\n    user = blankUser;\n  }\n  return user;\n};\nconst getUserLotteryData = async (account, currentLotteryId) => {\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId);\n  const roundDataAndUserTickets = await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall, account);\n  const userRoundsNodeData = roundDataAndUserTickets.filter(round => round.userTickets.length > 0);\n  const idsForLotteriesNodeCall = userRoundsNodeData.map(round => round.roundId);\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall);\n  const graphResponse = await getGraphLotteryUser(account);\n  const mergedRoundData = applyNodeDataToUserGraphResponse(userRoundsNodeData, graphResponse.rounds, lotteriesNodeData);\n  const graphResponseWithNodeRounds = {\n    ...graphResponse,\n    rounds: mergedRoundData\n  };\n  return graphResponseWithNodeRounds;\n};\nexport default getUserLotteryData;","map":{"version":3,"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","hasRoundBeenClaimed","fetchUserTicketsForMultipleRounds","applyNodeDataToUserGraphResponse","userNodeData","userGraphData","lotteryNodeData","length","map","nodeRound","ticketDataForRound","find","roundTickets","roundId","lotteryId","endTime","status","toString","claimed","userTickets","totalTickets","tickets","mergedResponse","graphRound","index","isLoading","getGraphLotteryUser","account","user","blankUser","totalCake","rounds","response","toLowerCase","userRes","id","round","_round$lottery","_round$lottery2","_round$lottery3","lottery","error","console","getUserLotteryData","currentLotteryId","idsForTicketsNodeCall","roundDataAndUserTickets","userRoundsNodeData","filter","idsForLotteriesNodeCall","lotteriesNodeData","graphResponse","mergedRoundData","graphResponseWithNodeRounds"],"sources":["C:/Users/frkul/Documents/swapUI_pancake-frontend/src/state/lottery/getUserLotteryData.ts"],"sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\r\nimport { LotteryTicket } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryResponse, UserRound } from 'state/types'\r\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed } from './helpers'\r\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\r\n\r\nconst applyNodeDataToUserGraphResponse = (\r\n  userNodeData: { roundId: string; userTickets: LotteryTicket[] }[],\r\n  userGraphData: UserRound[],\r\n  lotteryNodeData: LotteryResponse[],\r\n): UserRound[] => {\r\n  //   If no graph rounds response - return node data\r\n  if (userGraphData.length === 0) {\r\n    return lotteryNodeData.map((nodeRound) => {\r\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      return {\r\n        endTime: nodeRound.endTime,\r\n        status: nodeRound.status,\r\n        lotteryId: nodeRound.lotteryId.toString(),\r\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\r\n        tickets: ticketDataForRound.userTickets,\r\n      }\r\n    })\r\n  }\r\n\r\n  //   Else if there is a graph response - merge with node data where node data is more accurate\r\n  const mergedResponse = userGraphData.map((graphRound, index) => {\r\n    const nodeRound = lotteryNodeData[index]\r\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\r\n    if (nodeRound) {\r\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      // if isLoading === true, there has been a node error - return graphRound\r\n      if (!nodeRound.isLoading) {\r\n        return {\r\n          endTime: nodeRound.endTime,\r\n          status: nodeRound.status,\r\n          lotteryId: nodeRound.lotteryId.toString(),\r\n          claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n          totalTickets: graphRound.totalTickets,\r\n          tickets: ticketDataForRound.userTickets,\r\n        }\r\n      }\r\n      return graphRound\r\n    }\r\n    return graphRound\r\n  })\r\n  return mergedResponse\r\n}\r\n\r\nconst getGraphLotteryUser = async (account: string): Promise<LotteryUserGraphEntity> => {\r\n  let user\r\n  const blankUser = {\r\n    account,\r\n    totalCake: '',\r\n    totalTickets: '',\r\n    rounds: [],\r\n  }\r\n\r\n  try {\r\n    const response = await request(\r\n      GRAPH_API_LOTTERY,\r\n      gql`\r\n        query getUserLotteries($account: ID!) {\r\n          user(id: $account) {\r\n            id\r\n            totalTickets\r\n            totalCake\r\n            rounds(first: 100, orderDirection: desc, orderBy: block) {\r\n              id\r\n              lottery {\r\n                id\r\n                endTime\r\n                status\r\n              }\r\n              claimed\r\n              totalTickets\r\n            }\r\n          }\r\n        }\r\n      `,\r\n      { account: account.toLowerCase() },\r\n    )\r\n    const userRes = response.user\r\n\r\n    // If no user returned - return blank user\r\n    if (!userRes) {\r\n      user = blankUser\r\n    } else {\r\n      user = {\r\n        account: userRes.id,\r\n        totalCake: userRes.totalCake,\r\n        totalTickets: userRes.totalTickets,\r\n        rounds: userRes.rounds.map((round) => {\r\n          return {\r\n            lotteryId: round?.lottery?.id,\r\n            endTime: round?.lottery?.endTime,\r\n            claimed: round?.claimed,\r\n            totalTickets: round?.totalTickets,\r\n            status: round?.lottery?.status,\r\n          }\r\n        }),\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(error)\r\n    user = blankUser\r\n  }\r\n\r\n  return user\r\n}\r\n\r\nconst getUserLotteryData = async (account: string, currentLotteryId: string): Promise<LotteryUserGraphEntity> => {\r\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId)\r\n  const roundDataAndUserTickets = await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall, account)\r\n  const userRoundsNodeData = roundDataAndUserTickets.filter((round) => round.userTickets.length > 0)\r\n  const idsForLotteriesNodeCall = userRoundsNodeData.map((round) => round.roundId)\r\n\r\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall)\r\n  const graphResponse = await getGraphLotteryUser(account)\r\n  const mergedRoundData = applyNodeDataToUserGraphResponse(userRoundsNodeData, graphResponse.rounds, lotteriesNodeData)\r\n  const graphResponseWithNodeRounds = { ...graphResponse, rounds: mergedRoundData }\r\n  return graphResponseWithNodeRounds\r\n}\r\n\r\nexport default getUserLotteryData\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}