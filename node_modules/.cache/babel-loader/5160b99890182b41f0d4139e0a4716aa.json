{"ast":null,"code":"import BigNumber from'bignumber.js';import{LotteryStatus}from'config/constants/types';import{multicallv2}from'utils/multicall';import lotteryV2Abi from'config/abi/lotteryV2.json';import{NUM_ROUNDS_TO_CHECK_FOR_REWARDS}from'config/constants/lottery';import{getLotteryV2Address}from'utils/addressHelpers';import{BIG_ZERO}from'utils/bigNumber';import{fetchUserTicketsForMultipleRounds}from'./getUserTicketsData';const lotteryAddress=getLotteryV2Address();const fetchCakeRewardsForTickets=async winningTickets=>{const calls=winningTickets.map(winningTicket=>{const{roundId,id,rewardBracket}=winningTicket;return{name:'viewRewardsForTicketId',address:lotteryAddress,params:[roundId,id,rewardBracket]};});try{const cakeRewards=await multicallv2(lotteryV2Abi,calls);const cakeTotal=cakeRewards.reduce((accum,cakeReward)=>{return accum.plus(new BigNumber(cakeReward[0].toString()));},BIG_ZERO);const ticketsWithUnclaimedRewards=winningTickets.map((winningTicket,index)=>{return{...winningTicket,cakeReward:cakeRewards[index]};});return{ticketsWithUnclaimedRewards,cakeTotal};}catch(error){console.error(error);return{ticketsWithUnclaimedRewards:null,cakeTotal:null};}};const getRewardBracketByNumber=(ticketNumber,finalNumber)=>{// Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n// i.e. '1123456' should be evaluated as '6543211'\nconst ticketNumAsArray=ticketNumber.split('').reverse();const winningNumsAsArray=finalNumber.split('').reverse();const matchingNumbers=[];// The number at index 6 in all tickets is 1 and will always match, so finish at index 5\nfor(let index=0;index<winningNumsAsArray.length-1;index++){if(ticketNumAsArray[index]!==winningNumsAsArray[index]){break;}matchingNumbers.push(ticketNumAsArray[index]);}// Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\nconst rewardBracket=matchingNumbers.length-1;return rewardBracket;};export const getWinningTickets=async roundDataAndUserTickets=>{const{roundId,userTickets,finalNumber}=roundDataAndUserTickets;const ticketsWithRewardBrackets=userTickets.map(ticket=>{return{roundId,id:ticket.id,number:ticket.number,status:ticket.status,rewardBracket:getRewardBracketByNumber(ticket.number,finalNumber)};});// A rewardBracket of -1 means no matches. 0 and above means there has been a match\nconst allWinningTickets=ticketsWithRewardBrackets.filter(ticket=>{return ticket.rewardBracket>=0;});// If ticket.status is true, the ticket has already been claimed\nconst unclaimedWinningTickets=allWinningTickets.filter(ticket=>{return!ticket.status;});if(unclaimedWinningTickets.length>0){const{ticketsWithUnclaimedRewards,cakeTotal}=await fetchCakeRewardsForTickets(unclaimedWinningTickets);return{ticketsWithUnclaimedRewards,allWinningTickets,cakeTotal,roundId};}if(allWinningTickets.length>0){return{ticketsWithUnclaimedRewards:null,allWinningTickets,cakeTotal:null,roundId};}return null;};const getWinningNumbersForRound=(targetRoundId,lotteriesData)=>{const targetRound=lotteriesData.find(pastLottery=>pastLottery.id===targetRoundId);return targetRound===null||targetRound===void 0?void 0:targetRound.finalNumber;};const fetchUnclaimedUserRewards=async(account,userLotteryData,lotteriesData)=>{const{rounds}=userLotteryData;// If there is no user round history - return an empty array\nif(rounds.length===0){return[];}// If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\nif(userLotteryData.account.toLowerCase()!==account.toLowerCase()){return[];}// Filter out non-claimable rounds\nconst claimableRounds=rounds.filter(round=>{return round.status.toLowerCase()===LotteryStatus.CLAIMABLE;});// Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\nconst roundsWithPossibleWinnings=claimableRounds.filter(round=>{return!round.claimed||parseInt(round.totalTickets,10)>100;});// Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\nconst roundsToCheck=roundsWithPossibleWinnings.slice(0,NUM_ROUNDS_TO_CHECK_FOR_REWARDS);if(roundsToCheck.length>0){const idsToCheck=roundsToCheck.map(round=>round.lotteryId);const userTicketData=await fetchUserTicketsForMultipleRounds(idsToCheck,account);const roundsWithTickets=userTicketData.filter(roundData=>{var _roundData$userTicket;return(roundData===null||roundData===void 0?void 0:(_roundData$userTicket=roundData.userTickets)===null||_roundData$userTicket===void 0?void 0:_roundData$userTicket.length)>0;});const roundDataAndWinningTickets=roundsWithTickets.map(roundData=>{return{...roundData,finalNumber:getWinningNumbersForRound(roundData.roundId,lotteriesData)};});const winningTicketsForPastRounds=await Promise.all(roundDataAndWinningTickets.map(roundData=>getWinningTickets(roundData)));// Filter out null values (returned when no winning tickets found for past round)\nconst roundsWithWinningTickets=winningTicketsForPastRounds.filter(winningTicketData=>winningTicketData!==null);// Filter to only rounds with unclaimed tickets\nconst roundsWithUnclaimedWinningTickets=roundsWithWinningTickets.filter(winningTicketData=>winningTicketData.ticketsWithUnclaimedRewards);return roundsWithUnclaimedWinningTickets;}// All rounds claimed, return empty array\nreturn[];};export default fetchUnclaimedUserRewards;","map":{"version":3,"names":["BigNumber","LotteryStatus","multicallv2","lotteryV2Abi","NUM_ROUNDS_TO_CHECK_FOR_REWARDS","getLotteryV2Address","BIG_ZERO","fetchUserTicketsForMultipleRounds","lotteryAddress","fetchCakeRewardsForTickets","winningTickets","calls","map","winningTicket","roundId","id","rewardBracket","name","address","params","cakeRewards","cakeTotal","reduce","accum","cakeReward","plus","toString","ticketsWithUnclaimedRewards","index","error","console","getRewardBracketByNumber","ticketNumber","finalNumber","ticketNumAsArray","split","reverse","winningNumsAsArray","matchingNumbers","length","push","getWinningTickets","roundDataAndUserTickets","userTickets","ticketsWithRewardBrackets","ticket","number","status","allWinningTickets","filter","unclaimedWinningTickets","getWinningNumbersForRound","targetRoundId","lotteriesData","targetRound","find","pastLottery","fetchUnclaimedUserRewards","account","userLotteryData","rounds","toLowerCase","claimableRounds","round","CLAIMABLE","roundsWithPossibleWinnings","claimed","parseInt","totalTickets","roundsToCheck","slice","idsToCheck","lotteryId","userTicketData","roundsWithTickets","roundData","_roundData$userTicket","roundDataAndWinningTickets","winningTicketsForPastRounds","Promise","all","roundsWithWinningTickets","winningTicketData","roundsWithUnclaimedWinningTickets"],"sources":["C:/Users/frkul/Documents/swapUI_pancake-frontend/src/state/lottery/fetchUnclaimedUserRewards.ts"],"sourcesContent":["import BigNumber from 'bignumber.js'\r\nimport { ethers } from 'ethers'\r\nimport { LotteryStatus, LotteryTicket, LotteryTicketClaimData } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryRoundGraphEntity } from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\r\nimport { NUM_ROUNDS_TO_CHECK_FOR_REWARDS } from 'config/constants/lottery'\r\nimport { getLotteryV2Address } from 'utils/addressHelpers'\r\nimport { BIG_ZERO } from 'utils/bigNumber'\r\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\r\n\r\ninterface RoundDataAndUserTickets {\r\n  roundId: string\r\n  userTickets: LotteryTicket[]\r\n  finalNumber: string\r\n}\r\n\r\nconst lotteryAddress = getLotteryV2Address()\r\n\r\nconst fetchCakeRewardsForTickets = async (\r\n  winningTickets: LotteryTicket[],\r\n): Promise<{ ticketsWithUnclaimedRewards: LotteryTicket[]; cakeTotal: BigNumber }> => {\r\n  const calls = winningTickets.map((winningTicket) => {\r\n    const { roundId, id, rewardBracket } = winningTicket\r\n    return {\r\n      name: 'viewRewardsForTicketId',\r\n      address: lotteryAddress,\r\n      params: [roundId, id, rewardBracket],\r\n    }\r\n  })\r\n\r\n  try {\r\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls)\r\n\r\n    const cakeTotal = cakeRewards.reduce((accum: BigNumber, cakeReward: ethers.BigNumber[]) => {\r\n      return accum.plus(new BigNumber(cakeReward[0].toString()))\r\n    }, BIG_ZERO)\r\n\r\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\r\n      return { ...winningTicket, cakeReward: cakeRewards[index] }\r\n    })\r\n    return { ticketsWithUnclaimedRewards, cakeTotal }\r\n  } catch (error) {\r\n    console.error(error)\r\n    return { ticketsWithUnclaimedRewards: null, cakeTotal: null }\r\n  }\r\n}\r\n\r\nconst getRewardBracketByNumber = (ticketNumber: string, finalNumber: string): number => {\r\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\r\n  // i.e. '1123456' should be evaluated as '6543211'\r\n  const ticketNumAsArray = ticketNumber.split('').reverse()\r\n  const winningNumsAsArray = finalNumber.split('').reverse()\r\n  const matchingNumbers = []\r\n\r\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\r\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\r\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\r\n      break\r\n    }\r\n    matchingNumbers.push(ticketNumAsArray[index])\r\n  }\r\n\r\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\r\n  const rewardBracket = matchingNumbers.length - 1\r\n  return rewardBracket\r\n}\r\n\r\nexport const getWinningTickets = async (\r\n  roundDataAndUserTickets: RoundDataAndUserTickets,\r\n): Promise<LotteryTicketClaimData> => {\r\n  const { roundId, userTickets, finalNumber } = roundDataAndUserTickets\r\n\r\n  const ticketsWithRewardBrackets = userTickets.map((ticket) => {\r\n    return {\r\n      roundId,\r\n      id: ticket.id,\r\n      number: ticket.number,\r\n      status: ticket.status,\r\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber),\r\n    }\r\n  })\r\n\r\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\r\n  const allWinningTickets = ticketsWithRewardBrackets.filter((ticket) => {\r\n    return ticket.rewardBracket >= 0\r\n  })\r\n\r\n  // If ticket.status is true, the ticket has already been claimed\r\n  const unclaimedWinningTickets = allWinningTickets.filter((ticket) => {\r\n    return !ticket.status\r\n  })\r\n\r\n  if (unclaimedWinningTickets.length > 0) {\r\n    const { ticketsWithUnclaimedRewards, cakeTotal } = await fetchCakeRewardsForTickets(unclaimedWinningTickets)\r\n    return { ticketsWithUnclaimedRewards, allWinningTickets, cakeTotal, roundId }\r\n  }\r\n\r\n  if (allWinningTickets.length > 0) {\r\n    return { ticketsWithUnclaimedRewards: null, allWinningTickets, cakeTotal: null, roundId }\r\n  }\r\n\r\n  return null\r\n}\r\n\r\nconst getWinningNumbersForRound = (targetRoundId: string, lotteriesData: LotteryRoundGraphEntity[]) => {\r\n  const targetRound = lotteriesData.find((pastLottery) => pastLottery.id === targetRoundId)\r\n  return targetRound?.finalNumber\r\n}\r\n\r\nconst fetchUnclaimedUserRewards = async (\r\n  account: string,\r\n  userLotteryData: LotteryUserGraphEntity,\r\n  lotteriesData: LotteryRoundGraphEntity[],\r\n): Promise<LotteryTicketClaimData[]> => {\r\n  const { rounds } = userLotteryData\r\n\r\n  // If there is no user round history - return an empty array\r\n  if (rounds.length === 0) {\r\n    return []\r\n  }\r\n\r\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\r\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\r\n    return []\r\n  }\r\n\r\n  // Filter out non-claimable rounds\r\n  const claimableRounds = rounds.filter((round) => {\r\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE\r\n  })\r\n\r\n  // Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\r\n  const roundsWithPossibleWinnings = claimableRounds.filter((round) => {\r\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100\r\n  })\r\n\r\n  // Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\r\n  const roundsToCheck = roundsWithPossibleWinnings.slice(0, NUM_ROUNDS_TO_CHECK_FOR_REWARDS)\r\n\r\n  if (roundsToCheck.length > 0) {\r\n    const idsToCheck = roundsToCheck.map((round) => round.lotteryId)\r\n    const userTicketData = await fetchUserTicketsForMultipleRounds(idsToCheck, account)\r\n    const roundsWithTickets = userTicketData.filter((roundData) => roundData?.userTickets?.length > 0)\r\n\r\n    const roundDataAndWinningTickets = roundsWithTickets.map((roundData) => {\r\n      return { ...roundData, finalNumber: getWinningNumbersForRound(roundData.roundId, lotteriesData) }\r\n    })\r\n\r\n    const winningTicketsForPastRounds = await Promise.all(\r\n      roundDataAndWinningTickets.map((roundData) => getWinningTickets(roundData)),\r\n    )\r\n\r\n    // Filter out null values (returned when no winning tickets found for past round)\r\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(\r\n      (winningTicketData) => winningTicketData !== null,\r\n    )\r\n\r\n    // Filter to only rounds with unclaimed tickets\r\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(\r\n      (winningTicketData) => winningTicketData.ticketsWithUnclaimedRewards,\r\n    )\r\n\r\n    return roundsWithUnclaimedWinningTickets\r\n  }\r\n  // All rounds claimed, return empty array\r\n  return []\r\n}\r\n\r\nexport default fetchUnclaimedUserRewards\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}