{"ast":null,"code":"import _taggedTemplateLiteral from\"C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";var _templateObject,_templateObject2,_templateObject3;import{request,gql}from'graphql-request';import{GRAPH_API_PREDICTION}from'config/constants/endpoints';import{ethers}from'ethers';import{BetPosition,PredictionStatus}from'state/types';import{multicallv2}from'utils/multicall';import predictionsAbi from'config/abi/predictions.json';import{getPredictionsAddress}from'utils/addressHelpers';import{getRoundBaseFields,getBetBaseFields,getUserBaseFields}from'./queries';export let Result;(function(Result){Result[\"WIN\"]=\"win\";Result[\"LOSE\"]=\"lose\";Result[\"CANCELED\"]=\"canceled\";Result[\"LIVE\"]=\"live\";})(Result||(Result={}));export const numberOrNull=value=>{if(value===null){return null;}const valueNum=Number(value);return Number.isNaN(valueNum)?null:valueNum;};export const transformBetResponse=betResponse=>{const bet={id:betResponse.id,hash:betResponse.hash,amount:betResponse.amount?parseFloat(betResponse.amount):0,position:betResponse.position==='Bull'?BetPosition.BULL:BetPosition.BEAR,claimed:betResponse.claimed,claimedHash:betResponse.claimedHash,user:{id:betResponse.user.id,address:betResponse.user.address,block:numberOrNull(betResponse.user.block),totalBets:numberOrNull(betResponse.user.totalBets),totalBNB:numberOrNull(betResponse.user.totalBNB)}};if(betResponse.round){bet.round=transformRoundResponse(betResponse.round);}return bet;};export const transformRoundResponse=roundResponse=>{const{id,epoch,failed,startBlock,startAt,lockAt,lockBlock,lockPrice,endBlock,closePrice,totalBets,totalAmount,bullBets,bearBets,bearAmount,bullAmount,position,bets=[]}=roundResponse;const getRoundPosition=positionResponse=>{if(positionResponse==='Bull'){return BetPosition.BULL;}if(positionResponse==='Bear'){return BetPosition.BEAR;}return null;};return{id,failed,epoch:numberOrNull(epoch),startBlock:numberOrNull(startBlock),startAt:numberOrNull(startAt),lockAt:numberOrNull(lockAt),lockBlock:numberOrNull(lockBlock),lockPrice:lockPrice?parseFloat(lockPrice):null,endBlock:numberOrNull(endBlock),closePrice:closePrice?parseFloat(closePrice):null,totalBets:numberOrNull(totalBets),totalAmount:totalAmount?parseFloat(totalAmount):0,bullBets:numberOrNull(bullBets),bearBets:numberOrNull(bearBets),bearAmount:numberOrNull(bearAmount),bullAmount:numberOrNull(bullAmount),position:getRoundPosition(position),bets:bets.map(transformBetResponse)};};export const transformTotalWonResponse=(marketResponse,roundResponse)=>{const houseRounds=roundResponse.reduce((accum,round)=>{return accum+(round.totalAmount?parseFloat(round.totalAmount):0);},0);const totalBNB=marketResponse.totalBNB?parseFloat(marketResponse.totalBNB):0;const totalBNBTreasury=marketResponse.totalBNBTreasury?parseFloat(marketResponse.totalBNBTreasury):0;return Math.max(totalBNB-(totalBNBTreasury+houseRounds),0);};export const getRoundResult=(bet,currentEpoch)=>{const{round}=bet;if(round.failed){return Result.CANCELED;}if(round.epoch>=currentEpoch-1){return Result.LIVE;}const roundResultPosition=round.closePrice>round.lockPrice?BetPosition.BULL:BetPosition.BEAR;return bet.position===roundResultPosition?Result.WIN:Result.LOSE;};/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */export const getCanClaim=bet=>{return!bet.claimed&&(bet.position===bet.round.position||bet.round.failed===true);};/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */export const getUnclaimedWinningBets=bets=>{return bets.filter(getCanClaim);};export const getTotalWon=async()=>{const response=await request(GRAPH_API_PREDICTION,gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n      query getTotalWonData($position: String) {\\n        market(id: 1) {\\n          totalBNB\\n          totalBNBTreasury\\n        }\\n        rounds(where: { position: $position }) {\\n          totalAmount\\n        }\\n      }\\n    \"]))),{position:BetPosition.HOUSE});return transformTotalWonResponse(response.market,response.rounds);};export const getBetHistory=async function(){let where=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let first=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1000;let skip=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;const response=await request(GRAPH_API_PREDICTION,gql(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"\\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\\n          \",\"\\n          round {\\n            \",\"\\n          }\\n          user {\\n            \",\"\\n          } \\n        }\\n      }\\n    \"])),getBetBaseFields(),getRoundBaseFields(),getUserBaseFields()),{first,skip,where});return response.bets;};export const getBet=async betId=>{const response=await request(GRAPH_API_PREDICTION,gql(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"\\n      query getBet($id: ID!) {\\n        bet(id: $id) {\\n          \",\"\\n          round {\\n            \",\"\\n          }\\n          user {\\n            \",\"\\n          } \\n        }\\n      }\\n  \"])),getBetBaseFields(),getRoundBaseFields(),getUserBaseFields()),{id:betId.toLowerCase()});return response.bet;};// V2 REFACTOR\nexport const getLedgerData=async(account,epochs)=>{const address=getPredictionsAddress();const ledgerCalls=epochs.map(epoch=>({address,name:'ledger',params:[epoch,account]}));const response=await multicallv2(predictionsAbi,ledgerCalls);return response;};export const getClaimStatuses=async(account,epochs)=>{const address=getPredictionsAddress();const claimableCalls=epochs.map(epoch=>({address,name:'claimable',params:[epoch,account]}));const claimableResponses=await multicallv2(predictionsAbi,claimableCalls);// \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\n// To get around this temporarily we check the ledger status as well to confirm that it is claimable\n// This can be removed in Predictions V2\nconst ledgerResponses=await getLedgerData(account,epochs);return claimableResponses.reduce((accum,claimableResponse,index)=>{const{amount,claimed}=ledgerResponses[index];const epoch=epochs[index];const[claimable]=claimableResponse;return{...accum,[epoch]:claimable&&amount.gt(0)&&!claimed};},{});};export const getPredictionData=async()=>{const address=getPredictionsAddress();const staticCalls=['currentEpoch','intervalBlocks','minBetAmount','paused','bufferBlocks','rewardRate'].map(method=>({address,name:method}));const[[currentEpoch],[intervalBlocks],[minBetAmount],[paused],[bufferBlocks],[rewardRate]]=await multicallv2(predictionsAbi,staticCalls);return{status:paused?PredictionStatus.PAUSED:PredictionStatus.LIVE,currentEpoch:currentEpoch.toNumber(),intervalBlocks:intervalBlocks.toNumber(),bufferBlocks:bufferBlocks.toNumber(),minBetAmount:minBetAmount.toString(),rewardRate:rewardRate.toNumber()};};export const getRoundsData=async epochs=>{const address=getPredictionsAddress();const calls=epochs.map(epoch=>({address,name:'rounds',params:[epoch]}));const response=await multicallv2(predictionsAbi,calls);return response;};export const makeFutureRoundResponse=(epoch,startBlock)=>{return{epoch,startBlock,lockBlock:null,endBlock:null,lockPrice:null,closePrice:null,totalAmount:ethers.BigNumber.from(0).toJSON(),bullAmount:ethers.BigNumber.from(0).toJSON(),bearAmount:ethers.BigNumber.from(0).toJSON(),rewardBaseCalAmount:ethers.BigNumber.from(0).toJSON(),rewardAmount:ethers.BigNumber.from(0).toJSON(),oracleCalled:false};};export const makeRoundData=rounds=>{return rounds.reduce((accum,round)=>{return{...accum,[round.epoch.toString()]:round};},{});};export const serializePredictionsLedgerResponse=ledgerResponse=>({position:ledgerResponse.position===0?BetPosition.BULL:BetPosition.BEAR,amount:ledgerResponse.amount.toJSON(),claimed:ledgerResponse.claimed});export const makeLedgerData=(account,ledgers,epochs)=>{return ledgers.reduce((accum,ledgerResponse,index)=>{if(!ledgerResponse){return accum;}// If the amount is zero that means the user did not bet\nif(ledgerResponse.amount.eq(0)){return accum;}const epoch=epochs[index].toString();return{...accum,[account]:{...accum[account],[epoch]:serializePredictionsLedgerResponse(ledgerResponse)}};},{});};/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */export const serializePredictionsRoundsResponse=response=>{const{epoch,startBlock,lockBlock,endBlock,lockPrice,closePrice,totalAmount,bullAmount,bearAmount,rewardAmount,rewardBaseCalAmount,oracleCalled}=response;return{epoch:epoch.toNumber(),startBlock:startBlock.toNumber(),lockBlock:lockBlock.toNumber(),endBlock:endBlock.toNumber(),lockPrice:lockPrice.eq(0)?null:lockPrice.toJSON(),closePrice:closePrice.eq(0)?null:closePrice.toJSON(),totalAmount:totalAmount.toJSON(),bullAmount:bullAmount.toJSON(),bearAmount:bearAmount.toJSON(),rewardAmount:rewardAmount.toJSON(),rewardBaseCalAmount:rewardBaseCalAmount.toJSON(),oracleCalled};};/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */export const parseBigNumberObj=data=>{return Object.keys(data).reduce((accum,key)=>{const value=data[key];if(value&&(value===null||value===void 0?void 0:value.type)==='BigNumber'){return{...accum,[key]:ethers.BigNumber.from(value)};}return{...accum,[key]:value};},{});};","map":{"version":3,"names":["request","gql","GRAPH_API_PREDICTION","ethers","BetPosition","PredictionStatus","multicallv2","predictionsAbi","getPredictionsAddress","getRoundBaseFields","getBetBaseFields","getUserBaseFields","Result","numberOrNull","value","valueNum","Number","isNaN","transformBetResponse","betResponse","bet","id","hash","amount","parseFloat","position","BULL","BEAR","claimed","claimedHash","user","address","block","totalBets","totalBNB","round","transformRoundResponse","roundResponse","epoch","failed","startBlock","startAt","lockAt","lockBlock","lockPrice","endBlock","closePrice","totalAmount","bullBets","bearBets","bearAmount","bullAmount","bets","getRoundPosition","positionResponse","map","transformTotalWonResponse","marketResponse","houseRounds","reduce","accum","totalBNBTreasury","Math","max","getRoundResult","currentEpoch","CANCELED","LIVE","roundResultPosition","WIN","LOSE","getCanClaim","getUnclaimedWinningBets","filter","getTotalWon","response","_templateObject","_taggedTemplateLiteral","HOUSE","market","rounds","getBetHistory","where","arguments","length","undefined","first","skip","_templateObject2","getBet","betId","_templateObject3","toLowerCase","getLedgerData","account","epochs","ledgerCalls","name","params","getClaimStatuses","claimableCalls","claimableResponses","ledgerResponses","claimableResponse","index","claimable","gt","getPredictionData","staticCalls","method","intervalBlocks","minBetAmount","paused","bufferBlocks","rewardRate","status","PAUSED","toNumber","toString","getRoundsData","calls","makeFutureRoundResponse","BigNumber","from","toJSON","rewardBaseCalAmount","rewardAmount","oracleCalled","makeRoundData","serializePredictionsLedgerResponse","ledgerResponse","makeLedgerData","ledgers","eq","serializePredictionsRoundsResponse","parseBigNumberObj","data","Object","keys","key","type"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/predictions/helpers.ts"],"sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints'\r\nimport { ethers } from 'ethers'\r\nimport {\r\n  Bet,\r\n  LedgerData,\r\n  BetPosition,\r\n  PredictionsState,\r\n  PredictionStatus,\r\n  ReduxNodeLedger,\r\n  ReduxNodeRound,\r\n  Round,\r\n  RoundData,\r\n} from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport predictionsAbi from 'config/abi/predictions.json'\r\nimport { getPredictionsAddress } from 'utils/addressHelpers'\r\nimport { PredictionsClaimableResponse, PredictionsLedgerResponse, PredictionsRoundsResponse } from 'utils/types'\r\nimport {\r\n  BetResponse,\r\n  getRoundBaseFields,\r\n  getBetBaseFields,\r\n  getUserBaseFields,\r\n  RoundResponse,\r\n  TotalWonMarketResponse,\r\n  TotalWonRoundResponse,\r\n} from './queries'\r\n\r\nexport enum Result {\r\n  WIN = 'win',\r\n  LOSE = 'lose',\r\n  CANCELED = 'canceled',\r\n  LIVE = 'live',\r\n}\r\n\r\nexport const numberOrNull = (value: string) => {\r\n  if (value === null) {\r\n    return null\r\n  }\r\n\r\n  const valueNum = Number(value)\r\n  return Number.isNaN(valueNum) ? null : valueNum\r\n}\r\n\r\nexport const transformBetResponse = (betResponse: BetResponse): Bet => {\r\n  const bet = {\r\n    id: betResponse.id,\r\n    hash: betResponse.hash,\r\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\r\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\r\n    claimed: betResponse.claimed,\r\n    claimedHash: betResponse.claimedHash,\r\n    user: {\r\n      id: betResponse.user.id,\r\n      address: betResponse.user.address,\r\n      block: numberOrNull(betResponse.user.block),\r\n      totalBets: numberOrNull(betResponse.user.totalBets),\r\n      totalBNB: numberOrNull(betResponse.user.totalBNB),\r\n    },\r\n  } as Bet\r\n\r\n  if (betResponse.round) {\r\n    bet.round = transformRoundResponse(betResponse.round)\r\n  }\r\n\r\n  return bet\r\n}\r\n\r\nexport const transformRoundResponse = (roundResponse: RoundResponse): Round => {\r\n  const {\r\n    id,\r\n    epoch,\r\n    failed,\r\n    startBlock,\r\n    startAt,\r\n    lockAt,\r\n    lockBlock,\r\n    lockPrice,\r\n    endBlock,\r\n    closePrice,\r\n    totalBets,\r\n    totalAmount,\r\n    bullBets,\r\n    bearBets,\r\n    bearAmount,\r\n    bullAmount,\r\n    position,\r\n    bets = [],\r\n  } = roundResponse\r\n\r\n  const getRoundPosition = (positionResponse: string) => {\r\n    if (positionResponse === 'Bull') {\r\n      return BetPosition.BULL\r\n    }\r\n\r\n    if (positionResponse === 'Bear') {\r\n      return BetPosition.BEAR\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  return {\r\n    id,\r\n    failed,\r\n    epoch: numberOrNull(epoch),\r\n    startBlock: numberOrNull(startBlock),\r\n    startAt: numberOrNull(startAt),\r\n    lockAt: numberOrNull(lockAt),\r\n    lockBlock: numberOrNull(lockBlock),\r\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\r\n    endBlock: numberOrNull(endBlock),\r\n    closePrice: closePrice ? parseFloat(closePrice) : null,\r\n    totalBets: numberOrNull(totalBets),\r\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\r\n    bullBets: numberOrNull(bullBets),\r\n    bearBets: numberOrNull(bearBets),\r\n    bearAmount: numberOrNull(bearAmount),\r\n    bullAmount: numberOrNull(bullAmount),\r\n    position: getRoundPosition(position),\r\n    bets: bets.map(transformBetResponse),\r\n  }\r\n}\r\n\r\nexport const transformTotalWonResponse = (\r\n  marketResponse: TotalWonMarketResponse,\r\n  roundResponse: TotalWonRoundResponse[],\r\n): number => {\r\n  const houseRounds = roundResponse.reduce((accum, round) => {\r\n    return accum + (round.totalAmount ? parseFloat(round.totalAmount) : 0)\r\n  }, 0)\r\n\r\n  const totalBNB = marketResponse.totalBNB ? parseFloat(marketResponse.totalBNB) : 0\r\n  const totalBNBTreasury = marketResponse.totalBNBTreasury ? parseFloat(marketResponse.totalBNBTreasury) : 0\r\n\r\n  return Math.max(totalBNB - (totalBNBTreasury + houseRounds), 0)\r\n}\r\n\r\nexport const getRoundResult = (bet: Bet, currentEpoch: number): Result => {\r\n  const { round } = bet\r\n  if (round.failed) {\r\n    return Result.CANCELED\r\n  }\r\n\r\n  if (round.epoch >= currentEpoch - 1) {\r\n    return Result.LIVE\r\n  }\r\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR\r\n\r\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE\r\n}\r\n\r\n/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */\r\nexport const getCanClaim = (bet: Bet) => {\r\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true)\r\n}\r\n\r\n/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */\r\nexport const getUnclaimedWinningBets = (bets: Bet[]): Bet[] => {\r\n  return bets.filter(getCanClaim)\r\n}\r\n\r\nexport const getTotalWon = async (): Promise<number> => {\r\n  const response = (await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getTotalWonData($position: String) {\r\n        market(id: 1) {\r\n          totalBNB\r\n          totalBNBTreasury\r\n        }\r\n        rounds(where: { position: $position }) {\r\n          totalAmount\r\n        }\r\n      }\r\n    `,\r\n    { position: BetPosition.HOUSE },\r\n  )) as { market: TotalWonMarketResponse; rounds: TotalWonRoundResponse[] }\r\n\r\n  return transformTotalWonResponse(response.market, response.rounds)\r\n}\r\n\r\ntype BetHistoryWhereClause = Record<string, string | number | boolean | string[]>\r\n\r\nexport const getBetHistory = async (\r\n  where: BetHistoryWhereClause = {},\r\n  first = 1000,\r\n  skip = 0,\r\n): Promise<BetResponse[]> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\r\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n    `,\r\n    { first, skip, where },\r\n  )\r\n  return response.bets\r\n}\r\n\r\nexport const getBet = async (betId: string): Promise<BetResponse> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBet($id: ID!) {\r\n        bet(id: $id) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n  `,\r\n    {\r\n      id: betId.toLowerCase(),\r\n    },\r\n  )\r\n  return response.bet\r\n}\r\n\r\n// V2 REFACTOR\r\nexport const getLedgerData = async (account: string, epochs: number[]) => {\r\n  const address = getPredictionsAddress()\r\n  const ledgerCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'ledger',\r\n    params: [epoch, account],\r\n  }))\r\n  const response = await multicallv2<PredictionsLedgerResponse[]>(predictionsAbi, ledgerCalls)\r\n  return response\r\n}\r\n\r\nexport const getClaimStatuses = async (\r\n  account: string,\r\n  epochs: number[],\r\n): Promise<PredictionsState['claimableStatuses']> => {\r\n  const address = getPredictionsAddress()\r\n  const claimableCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'claimable',\r\n    params: [epoch, account],\r\n  }))\r\n  const claimableResponses = await multicallv2<[PredictionsClaimableResponse][]>(predictionsAbi, claimableCalls)\r\n\r\n  // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\r\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\r\n  // This can be removed in Predictions V2\r\n  const ledgerResponses = await getLedgerData(account, epochs)\r\n\r\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\r\n    const { amount, claimed } = ledgerResponses[index]\r\n    const epoch = epochs[index]\r\n    const [claimable] = claimableResponse\r\n\r\n    return {\r\n      ...accum,\r\n      [epoch]: claimable && amount.gt(0) && !claimed,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport type MarketData = Pick<\r\n  PredictionsState,\r\n  'status' | 'currentEpoch' | 'intervalBlocks' | 'bufferBlocks' | 'minBetAmount' | 'rewardRate'\r\n>\r\nexport const getPredictionData = async (): Promise<MarketData> => {\r\n  const address = getPredictionsAddress()\r\n  const staticCalls = ['currentEpoch', 'intervalBlocks', 'minBetAmount', 'paused', 'bufferBlocks', 'rewardRate'].map(\r\n    (method) => ({\r\n      address,\r\n      name: method,\r\n    }),\r\n  )\r\n  const [[currentEpoch], [intervalBlocks], [minBetAmount], [paused], [bufferBlocks], [rewardRate]] = await multicallv2(\r\n    predictionsAbi,\r\n    staticCalls,\r\n  )\r\n\r\n  return {\r\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\r\n    currentEpoch: currentEpoch.toNumber(),\r\n    intervalBlocks: intervalBlocks.toNumber(),\r\n    bufferBlocks: bufferBlocks.toNumber(),\r\n    minBetAmount: minBetAmount.toString(),\r\n    rewardRate: rewardRate.toNumber(),\r\n  }\r\n}\r\n\r\nexport const getRoundsData = async (epochs: number[]): Promise<PredictionsRoundsResponse[]> => {\r\n  const address = getPredictionsAddress()\r\n  const calls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'rounds',\r\n    params: [epoch],\r\n  }))\r\n  const response = await multicallv2<PredictionsRoundsResponse[]>(predictionsAbi, calls)\r\n  return response\r\n}\r\n\r\nexport const makeFutureRoundResponse = (epoch: number, startBlock: number): ReduxNodeRound => {\r\n  return {\r\n    epoch,\r\n    startBlock,\r\n    lockBlock: null,\r\n    endBlock: null,\r\n    lockPrice: null,\r\n    closePrice: null,\r\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\r\n    oracleCalled: false,\r\n  }\r\n}\r\n\r\nexport const makeRoundData = (rounds: ReduxNodeRound[]): RoundData => {\r\n  return rounds.reduce((accum, round) => {\r\n    return {\r\n      ...accum,\r\n      [round.epoch.toString()]: round,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport const serializePredictionsLedgerResponse = (ledgerResponse: PredictionsLedgerResponse): ReduxNodeLedger => ({\r\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\r\n  amount: ledgerResponse.amount.toJSON(),\r\n  claimed: ledgerResponse.claimed,\r\n})\r\n\r\nexport const makeLedgerData = (account: string, ledgers: PredictionsLedgerResponse[], epochs: number[]): LedgerData => {\r\n  return ledgers.reduce((accum, ledgerResponse, index) => {\r\n    if (!ledgerResponse) {\r\n      return accum\r\n    }\r\n\r\n    // If the amount is zero that means the user did not bet\r\n    if (ledgerResponse.amount.eq(0)) {\r\n      return accum\r\n    }\r\n\r\n    const epoch = epochs[index].toString()\r\n\r\n    return {\r\n      ...accum,\r\n      [account]: {\r\n        ...accum[account],\r\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse),\r\n      },\r\n    }\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */\r\nexport const serializePredictionsRoundsResponse = (response: PredictionsRoundsResponse): ReduxNodeRound => {\r\n  const {\r\n    epoch,\r\n    startBlock,\r\n    lockBlock,\r\n    endBlock,\r\n    lockPrice,\r\n    closePrice,\r\n    totalAmount,\r\n    bullAmount,\r\n    bearAmount,\r\n    rewardAmount,\r\n    rewardBaseCalAmount,\r\n    oracleCalled,\r\n  } = response\r\n\r\n  return {\r\n    epoch: epoch.toNumber(),\r\n    startBlock: startBlock.toNumber(),\r\n    lockBlock: lockBlock.toNumber(),\r\n    endBlock: endBlock.toNumber(),\r\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\r\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\r\n    totalAmount: totalAmount.toJSON(),\r\n    bullAmount: bullAmount.toJSON(),\r\n    bearAmount: bearAmount.toJSON(),\r\n    rewardAmount: rewardAmount.toJSON(),\r\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\r\n    oracleCalled,\r\n  }\r\n}\r\n\r\n/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */\r\nexport const parseBigNumberObj = <T = Record<string, any>, K = Record<string, any>>(data: T): K => {\r\n  return Object.keys(data).reduce((accum, key) => {\r\n    const value = data[key]\r\n\r\n    if (value && value?.type === 'BigNumber') {\r\n      return {\r\n        ...accum,\r\n        [key]: ethers.BigNumber.from(value),\r\n      }\r\n    }\r\n\r\n    return {\r\n      ...accum,\r\n      [key]: value,\r\n    }\r\n  }, {}) as K\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}