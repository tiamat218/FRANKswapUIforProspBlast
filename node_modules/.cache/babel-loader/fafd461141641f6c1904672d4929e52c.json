{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Devrim\\\\Documents\\\\FRANKswapUIforProspBlast\\\\src\\\\contexts\\\\Localization\\\\Provider.tsx\",\n  _s = $RefreshSig$();\nimport React, { createContext, useCallback, useEffect, useState } from 'react';\nimport { EN, languages } from 'config/localization/languages';\nimport translations from 'config/localization/translations.json';\nimport { LS_KEY, fetchLocale, getLanguageCodeFromLS } from './helpers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialState = {\n  isFetching: true,\n  currentLanguage: EN\n};\n\n// Export the translations directly\nexport const languageMap = new Map();\nlanguageMap.set(EN.locale, translations);\nexport const LanguageContext = /*#__PURE__*/createContext(undefined);\nexport const LanguageProvider = ({\n  children\n}) => {\n  _s();\n  const [state, setState] = useState(() => {\n    const codeFromStorage = getLanguageCodeFromLS();\n    return {\n      ...initialState,\n      currentLanguage: languages[codeFromStorage]\n    };\n  });\n  const {\n    currentLanguage\n  } = state;\n  useEffect(() => {\n    const fetchInitialLocales = async () => {\n      const codeFromStorage = getLanguageCodeFromLS();\n      if (codeFromStorage !== EN.locale) {\n        const enLocale = languageMap.get(EN.locale);\n        const currentLocale = await fetchLocale(codeFromStorage);\n        languageMap.set(codeFromStorage, {\n          ...enLocale,\n          ...currentLocale\n        });\n      }\n      setState(prevState => ({\n        ...prevState,\n        isFetching: false\n      }));\n    };\n    fetchInitialLocales();\n  }, [setState]);\n  const setLanguage = async language => {\n    if (!languageMap.has(language.locale)) {\n      setState(prevState => ({\n        ...prevState,\n        isFetching: true\n      }));\n      const locale = await fetchLocale(language.locale);\n      const enLocale = languageMap.get(EN.locale);\n\n      // Merge the EN locale to ensure that any locale fetched has all the keys\n      languageMap.set(language.locale, {\n        ...enLocale,\n        ...locale\n      });\n      localStorage.setItem(LS_KEY, language.locale);\n      setState(prevState => ({\n        ...prevState,\n        isFetching: false,\n        currentLanguage: language\n      }));\n    } else {\n      localStorage.setItem(LS_KEY, language.locale);\n      setState(prevState => ({\n        ...prevState,\n        isFetching: false,\n        currentLanguage: language\n      }));\n    }\n  };\n  const translate = useCallback((key, data) => {\n    const translationSet = languageMap.has(currentLanguage.locale) ? languageMap.get(currentLanguage.locale) : languageMap.get(EN.locale);\n    const translatedText = translationSet[key] || key;\n\n    // Check the existence of at least one combination of %%, separated by 1 or more non space characters\n    const includesVariable = translatedText.match(/%\\S+?%/gm);\n    if (includesVariable && data) {\n      let interpolatedText = translatedText;\n      Object.keys(data).forEach(dataKey => {\n        const templateKey = new RegExp(`%${dataKey}%`, 'g');\n        interpolatedText = interpolatedText.replace(templateKey, data[dataKey].toString());\n      });\n      return interpolatedText;\n    }\n    return translatedText;\n  }, [currentLanguage]);\n  return /*#__PURE__*/_jsxDEV(LanguageContext.Provider, {\n    value: {\n      ...state,\n      setLanguage,\n      t: translate\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 103,\n    columnNumber: 10\n  }, this);\n};\n_s(LanguageProvider, \"NmO1riNlHTNF5g3KZy6AK9L8Fdc=\");\n_c = LanguageProvider;\nvar _c;\n$RefreshReg$(_c, \"LanguageProvider\");","map":{"version":3,"names":["React","createContext","useCallback","useEffect","useState","EN","languages","translations","LS_KEY","fetchLocale","getLanguageCodeFromLS","jsxDEV","_jsxDEV","initialState","isFetching","currentLanguage","languageMap","Map","set","locale","LanguageContext","undefined","LanguageProvider","children","_s","state","setState","codeFromStorage","fetchInitialLocales","enLocale","get","currentLocale","prevState","setLanguage","language","has","localStorage","setItem","translate","key","data","translationSet","translatedText","includesVariable","match","interpolatedText","Object","keys","forEach","dataKey","templateKey","RegExp","replace","toString","Provider","value","t","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/contexts/Localization/Provider.tsx"],"sourcesContent":["import React, { createContext, useCallback, useEffect, useState } from 'react'\r\nimport { Language } from '@pancakeswap/uikit'\r\nimport { EN, languages } from 'config/localization/languages'\r\nimport translations from 'config/localization/translations.json'\r\nimport { ContextApi, ContextData, ProviderState } from './types'\r\nimport { LS_KEY, fetchLocale, getLanguageCodeFromLS } from './helpers'\r\n\r\nconst initialState: ProviderState = {\r\n  isFetching: true,\r\n  currentLanguage: EN,\r\n}\r\n\r\n// Export the translations directly\r\nexport const languageMap = new Map<Language['locale'], Record<string, string>>()\r\nlanguageMap.set(EN.locale, translations)\r\n\r\nexport const LanguageContext = createContext<ContextApi>(undefined)\r\n\r\nexport const LanguageProvider: React.FC = ({ children }) => {\r\n  const [state, setState] = useState<ProviderState>(() => {\r\n    const codeFromStorage = getLanguageCodeFromLS()\r\n\r\n    return {\r\n      ...initialState,\r\n      currentLanguage: languages[codeFromStorage],\r\n    }\r\n  })\r\n  const { currentLanguage } = state\r\n\r\n  useEffect(() => {\r\n    const fetchInitialLocales = async () => {\r\n      const codeFromStorage = getLanguageCodeFromLS()\r\n\r\n      if (codeFromStorage !== EN.locale) {\r\n        const enLocale = languageMap.get(EN.locale)\r\n        const currentLocale = await fetchLocale(codeFromStorage)\r\n        languageMap.set(codeFromStorage, { ...enLocale, ...currentLocale })\r\n      }\r\n\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: false,\r\n      }))\r\n    }\r\n\r\n    fetchInitialLocales()\r\n  }, [setState])\r\n\r\n  const setLanguage = async (language: Language) => {\r\n    if (!languageMap.has(language.locale)) {\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: true,\r\n      }))\r\n\r\n      const locale = await fetchLocale(language.locale)\r\n      const enLocale = languageMap.get(EN.locale)\r\n\r\n      // Merge the EN locale to ensure that any locale fetched has all the keys\r\n      languageMap.set(language.locale, { ...enLocale, ...locale })\r\n      localStorage.setItem(LS_KEY, language.locale)\r\n\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: false,\r\n        currentLanguage: language,\r\n      }))\r\n    } else {\r\n      localStorage.setItem(LS_KEY, language.locale)\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: false,\r\n        currentLanguage: language,\r\n      }))\r\n    }\r\n  }\r\n\r\n  const translate = useCallback(\r\n    (key: string, data?: ContextData) => {\r\n      const translationSet = languageMap.has(currentLanguage.locale)\r\n        ? languageMap.get(currentLanguage.locale)\r\n        : languageMap.get(EN.locale)\r\n      const translatedText = translationSet[key] || key\r\n\r\n      // Check the existence of at least one combination of %%, separated by 1 or more non space characters\r\n      const includesVariable = translatedText.match(/%\\S+?%/gm)\r\n\r\n      if (includesVariable && data) {\r\n        let interpolatedText = translatedText\r\n        Object.keys(data).forEach((dataKey) => {\r\n          const templateKey = new RegExp(`%${dataKey}%`, 'g')\r\n          interpolatedText = interpolatedText.replace(templateKey, data[dataKey].toString())\r\n        })\r\n\r\n        return interpolatedText\r\n      }\r\n\r\n      return translatedText\r\n    },\r\n    [currentLanguage],\r\n  )\r\n\r\n  return <LanguageContext.Provider value={{ ...state, setLanguage, t: translate }}>{children}</LanguageContext.Provider>\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}