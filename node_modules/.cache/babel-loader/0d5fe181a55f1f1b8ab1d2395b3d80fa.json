{"ast":null,"code":"import { createReducer } from '@reduxjs/toolkit';\nimport { addMulticallListeners, errorFetchingMulticallResults, fetchingMulticallResults, removeMulticallListeners, toCallKey, updateMulticallResults } from './actions';\nconst initialState = {\n  callResults: {}\n};\nexport default createReducer(initialState, builder => builder.addCase(addMulticallListeners, (state, {\n  payload: {\n    calls,\n    chainId,\n    options: {\n      blocksPerFetch = 1\n    } = {}\n  }\n}) => {\n  var _listeners$chainId;\n  const listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n  listeners[chainId] = (_listeners$chainId = listeners[chainId]) !== null && _listeners$chainId !== void 0 ? _listeners$chainId : {};\n  calls.forEach(call => {\n    var _listeners$chainId$ca, _listeners$chainId$ca2;\n    const callKey = toCallKey(call);\n    listeners[chainId][callKey] = (_listeners$chainId$ca = listeners[chainId][callKey]) !== null && _listeners$chainId$ca !== void 0 ? _listeners$chainId$ca : {};\n    listeners[chainId][callKey][blocksPerFetch] = ((_listeners$chainId$ca2 = listeners[chainId][callKey][blocksPerFetch]) !== null && _listeners$chainId$ca2 !== void 0 ? _listeners$chainId$ca2 : 0) + 1;\n  });\n}).addCase(removeMulticallListeners, (state, {\n  payload: {\n    chainId,\n    calls,\n    options: {\n      blocksPerFetch = 1\n    } = {}\n  }\n}) => {\n  const listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n  if (!listeners[chainId]) return;\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    if (!listeners[chainId][callKey]) return;\n    if (!listeners[chainId][callKey][blocksPerFetch]) return;\n    if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n      delete listeners[chainId][callKey][blocksPerFetch];\n    } else {\n      listeners[chainId][callKey][blocksPerFetch]--;\n    }\n  });\n}).addCase(fetchingMulticallResults, (state, {\n  payload: {\n    chainId,\n    fetchingBlockNumber,\n    calls\n  }\n}) => {\n  var _state$callResults$ch;\n  state.callResults[chainId] = (_state$callResults$ch = state.callResults[chainId]) !== null && _state$callResults$ch !== void 0 ? _state$callResults$ch : {};\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    const current = state.callResults[chainId][callKey];\n    if (!current) {\n      state.callResults[chainId][callKey] = {\n        fetchingBlockNumber\n      };\n    } else {\n      var _current$fetchingBloc;\n      if (((_current$fetchingBloc = current.fetchingBlockNumber) !== null && _current$fetchingBloc !== void 0 ? _current$fetchingBloc : 0) >= fetchingBlockNumber) return;\n      state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;\n    }\n  });\n}).addCase(errorFetchingMulticallResults, (state, {\n  payload: {\n    fetchingBlockNumber,\n    chainId,\n    calls\n  }\n}) => {\n  var _state$callResults$ch2;\n  state.callResults[chainId] = (_state$callResults$ch2 = state.callResults[chainId]) !== null && _state$callResults$ch2 !== void 0 ? _state$callResults$ch2 : {};\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    const current = state.callResults[chainId][callKey];\n    if (!current) return; // only should be dispatched if we are already fetching\n    if (current.fetchingBlockNumber === fetchingBlockNumber) {\n      delete current.fetchingBlockNumber;\n      current.data = null;\n      current.blockNumber = fetchingBlockNumber;\n    }\n  });\n}).addCase(updateMulticallResults, (state, {\n  payload: {\n    chainId,\n    results,\n    blockNumber\n  }\n}) => {\n  var _state$callResults$ch3;\n  state.callResults[chainId] = (_state$callResults$ch3 = state.callResults[chainId]) !== null && _state$callResults$ch3 !== void 0 ? _state$callResults$ch3 : {};\n  Object.keys(results).forEach(callKey => {\n    var _current$blockNumber;\n    const current = state.callResults[chainId][callKey];\n    if (((_current$blockNumber = current === null || current === void 0 ? void 0 : current.blockNumber) !== null && _current$blockNumber !== void 0 ? _current$blockNumber : 0) > blockNumber) return;\n    state.callResults[chainId][callKey] = {\n      data: results[callKey],\n      blockNumber\n    };\n  });\n}));","map":{"version":3,"names":["createReducer","addMulticallListeners","errorFetchingMulticallResults","fetchingMulticallResults","removeMulticallListeners","toCallKey","updateMulticallResults","initialState","callResults","builder","addCase","state","payload","calls","chainId","options","blocksPerFetch","_listeners$chainId","listeners","callListeners","forEach","call","_listeners$chainId$ca","_listeners$chainId$ca2","callKey","fetchingBlockNumber","_state$callResults$ch","current","_current$fetchingBloc","_state$callResults$ch2","data","blockNumber","results","_state$callResults$ch3","Object","keys","_current$blockNumber"],"sources":["C:/Users/frkul/Documents/swapUI_pancake-frontend/src/state/multicall/reducer.ts"],"sourcesContent":["import { createReducer } from '@reduxjs/toolkit'\r\nimport {\r\n  addMulticallListeners,\r\n  errorFetchingMulticallResults,\r\n  fetchingMulticallResults,\r\n  removeMulticallListeners,\r\n  toCallKey,\r\n  updateMulticallResults,\r\n} from './actions'\r\n\r\nexport interface MulticallState {\r\n  callListeners?: {\r\n    // on a per-chain basis\r\n    [chainId: number]: {\r\n      // stores for each call key the listeners' preferences\r\n      [callKey: string]: {\r\n        // stores how many listeners there are per each blocks per fetch preference\r\n        [blocksPerFetch: number]: number\r\n      }\r\n    }\r\n  }\r\n\r\n  callResults: {\r\n    [chainId: number]: {\r\n      [callKey: string]: {\r\n        data?: string | null\r\n        blockNumber?: number\r\n        fetchingBlockNumber?: number\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst initialState: MulticallState = {\r\n  callResults: {},\r\n}\r\n\r\nexport default createReducer(initialState, (builder) =>\r\n  builder\r\n    .addCase(addMulticallListeners, (state, { payload: { calls, chainId, options: { blocksPerFetch = 1 } = {} } }) => {\r\n      const listeners: MulticallState['callListeners'] = state.callListeners\r\n        ? state.callListeners\r\n        : (state.callListeners = {})\r\n      listeners[chainId] = listeners[chainId] ?? {}\r\n      calls.forEach((call) => {\r\n        const callKey = toCallKey(call)\r\n        listeners[chainId][callKey] = listeners[chainId][callKey] ?? {}\r\n        listeners[chainId][callKey][blocksPerFetch] = (listeners[chainId][callKey][blocksPerFetch] ?? 0) + 1\r\n      })\r\n    })\r\n    .addCase(\r\n      removeMulticallListeners,\r\n      (state, { payload: { chainId, calls, options: { blocksPerFetch = 1 } = {} } }) => {\r\n        const listeners: MulticallState['callListeners'] = state.callListeners\r\n          ? state.callListeners\r\n          : (state.callListeners = {})\r\n\r\n        if (!listeners[chainId]) return\r\n        calls.forEach((call) => {\r\n          const callKey = toCallKey(call)\r\n          if (!listeners[chainId][callKey]) return\r\n          if (!listeners[chainId][callKey][blocksPerFetch]) return\r\n\r\n          if (listeners[chainId][callKey][blocksPerFetch] === 1) {\r\n            delete listeners[chainId][callKey][blocksPerFetch]\r\n          } else {\r\n            listeners[chainId][callKey][blocksPerFetch]--\r\n          }\r\n        })\r\n      },\r\n    )\r\n    .addCase(fetchingMulticallResults, (state, { payload: { chainId, fetchingBlockNumber, calls } }) => {\r\n      state.callResults[chainId] = state.callResults[chainId] ?? {}\r\n      calls.forEach((call) => {\r\n        const callKey = toCallKey(call)\r\n        const current = state.callResults[chainId][callKey]\r\n        if (!current) {\r\n          state.callResults[chainId][callKey] = {\r\n            fetchingBlockNumber,\r\n          }\r\n        } else {\r\n          if ((current.fetchingBlockNumber ?? 0) >= fetchingBlockNumber) return\r\n          state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber\r\n        }\r\n      })\r\n    })\r\n    .addCase(errorFetchingMulticallResults, (state, { payload: { fetchingBlockNumber, chainId, calls } }) => {\r\n      state.callResults[chainId] = state.callResults[chainId] ?? {}\r\n      calls.forEach((call) => {\r\n        const callKey = toCallKey(call)\r\n        const current = state.callResults[chainId][callKey]\r\n        if (!current) return // only should be dispatched if we are already fetching\r\n        if (current.fetchingBlockNumber === fetchingBlockNumber) {\r\n          delete current.fetchingBlockNumber\r\n          current.data = null\r\n          current.blockNumber = fetchingBlockNumber\r\n        }\r\n      })\r\n    })\r\n    .addCase(updateMulticallResults, (state, { payload: { chainId, results, blockNumber } }) => {\r\n      state.callResults[chainId] = state.callResults[chainId] ?? {}\r\n      Object.keys(results).forEach((callKey) => {\r\n        const current = state.callResults[chainId][callKey]\r\n        if ((current?.blockNumber ?? 0) > blockNumber) return\r\n        state.callResults[chainId][callKey] = {\r\n          data: results[callKey],\r\n          blockNumber,\r\n        }\r\n      })\r\n    }),\r\n)\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}