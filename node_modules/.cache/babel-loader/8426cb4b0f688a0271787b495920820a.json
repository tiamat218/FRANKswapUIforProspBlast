{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$();\n\n/* eslint-disable no-param-reassign */\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { ETHER, Token, currencyEquals } from '@pancakeswap/sdk';\nimport { useMemo } from 'react';\nimport { arrayify } from 'ethers/lib/utils';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { useDefaultTokenList, useUnsupportedTokenList, useCombinedActiveList, useCombinedInactiveList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\nimport useUserAddedTokens from '../state/user/hooks/useUserAddedTokens';\nimport { isAddress } from '../utils';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nimport { filterTokens } from '../components/SearchModal/filtering'; // reduce token map into standard address <-> Token mapping, optionally include user added tokens\n\nfunction useTokensFromMap(tokenMap, includeUserAdded) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  return useMemo(() => {\n    if (!chainId) return {};\n    /*     const object1 = {\r\n          a: 'somestring',\r\n          b: 42,\r\n          c: false,\r\n        }; */\n\n    /*     // reduce to just tokens\r\n        const mapWithoutUrlspt1 = Object.keys(tokenMap[chainId]);\r\n        \r\n        \r\n        const mapWithoutUrls = mapWithoutUrlspt1.reduce <{ [address: string]: Token }> ((newMap, address) => {\r\n          newMap[address] = tokenMap[chainId][address].token\r\n          return newMap\r\n        }, {})  */\n\n    const mapWithoutUrls = {};\n\n    if (includeUserAdded) {\n      return userAddedTokens // reduce into all ALL_TOKENS filtered by the current chain\n      .reduce((tokenMap_, token) => {\n        tokenMap_[token.address] = token;\n        return tokenMap_;\n      }, // must make a copy because reduce modifies the map, and we do not\n      // want to make a copy in every iteration\n      { ...mapWithoutUrls\n      });\n    }\n\n    return mapWithoutUrls;\n  }, [chainId, userAddedTokens, includeUserAdded]); //  tokenMap, hier rausgenommen\n}\n\n_s(useTokensFromMap, \"o7LgZeIx6jncN8Lb8S6zeK0wZEQ=\", false, function () {\n  return [useActiveWeb3React, useUserAddedTokens];\n});\n\nexport function useDefaultTokens() {\n  _s2();\n\n  const defaultList = useDefaultTokenList();\n  return useTokensFromMap(defaultList, false);\n}\n\n_s2(useDefaultTokens, \"KFd6g+TcR728AgRacaW35zCvQZc=\", false, function () {\n  return [useDefaultTokenList, useTokensFromMap];\n});\n\nexport function useAllTokens() {\n  _s3();\n\n  const allTokens = useCombinedActiveList();\n  return useTokensFromMap(allTokens, true);\n}\n\n_s3(useAllTokens, \"jCGW4tI4Rs1UGm9shzKA8VnDJ0A=\", false, function () {\n  return [useCombinedActiveList, useTokensFromMap];\n});\n\nexport function useAllInactiveTokens() {\n  _s4();\n\n  // get inactive tokens\n  const inactiveTokensMap = useCombinedInactiveList();\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false); // filter out any token that are on active list\n\n  const activeTokensAddresses = Object.keys(useAllTokens());\n  const filteredInactive = activeTokensAddresses ? Object.keys(inactiveTokens).reduce((newMap, address) => {\n    if (!activeTokensAddresses.includes(address)) {\n      newMap[address] = inactiveTokens[address];\n    }\n\n    return newMap;\n  }, {}) : inactiveTokens;\n  return filteredInactive;\n}\n\n_s4(useAllInactiveTokens, \"y9223uP8GCC/3ME2n383kLmFOz4=\", false, function () {\n  return [useCombinedInactiveList, useTokensFromMap, useAllTokens];\n});\n\nexport function useUnsupportedTokens() {\n  _s5();\n\n  const unsupportedTokensMap = useUnsupportedTokenList();\n  return useTokensFromMap(unsupportedTokensMap, false);\n}\n\n_s5(useUnsupportedTokens, \"cfUcH2/tU9tFbaAvFr6x9maL1ms=\", false, function () {\n  return [useUnsupportedTokenList, useTokensFromMap];\n});\n\nexport function useIsTokenActive(token) {\n  _s6();\n\n  const activeTokens = useAllTokens();\n\n  if (!activeTokens || !token) {\n    return false;\n  }\n\n  return !!activeTokens[token.address];\n} // used to detect extra search results\n\n_s6(useIsTokenActive, \"/DZnqUeqi963rU8m84lshLFLG1g=\", false, function () {\n  return [useAllTokens];\n});\n\nexport function useFoundOnInactiveList(searchQuery) {\n  _s7();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const inactiveTokens = useAllInactiveTokens();\n  return useMemo(() => {\n    if (!chainId || searchQuery === '') {\n      return undefined;\n    }\n\n    const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n    return tokens;\n  }, [chainId, inactiveTokens, searchQuery]);\n} // Check if currency is included in custom list from user storage\n\n_s7(useFoundOnInactiveList, \"hwNPd01dv/ucAD4kWZcYbreBqQU=\", false, function () {\n  return [useActiveWeb3React, useAllInactiveTokens];\n});\n\nexport function useIsUserAddedToken(currency) {\n  _s8();\n\n  const userAddedTokens = useUserAddedTokens();\n\n  if (!currency) {\n    return false;\n  }\n\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n} // parse a name or symbol from a token response\n\n_s8(useIsUserAddedToken, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", false, function () {\n  return [useUserAddedTokens];\n});\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : // need to check for proper bytes string and valid terminator\n  bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0 ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  _s9();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address || undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address || undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\n\n_s9(useToken, \"eKyRyOw1MkhB0rg/op393nwat5k=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useTokenContract, useBytes32TokenContract, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\n\nexport function useCurrency(currencyId) {\n  _s10();\n\n  const isBNB = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'BNB';\n  const token = useToken(isBNB ? undefined : currencyId);\n  return isBNB ? ETHER : token;\n}\n\n_s10(useCurrency, \"YdEbLWY6/B/ql2/5vHiby7UXKcg=\", false, function () {\n  return [useToken];\n});","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/hooks/Tokens.ts"],"names":["parseBytes32String","ETHER","Token","currencyEquals","useMemo","arrayify","useActiveWeb3React","useDefaultTokenList","useUnsupportedTokenList","useCombinedActiveList","useCombinedInactiveList","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useBytes32TokenContract","useTokenContract","filterTokens","useTokensFromMap","tokenMap","includeUserAdded","chainId","userAddedTokens","mapWithoutUrls","reduce","tokenMap_","token","address","useDefaultTokens","defaultList","useAllTokens","allTokens","useAllInactiveTokens","inactiveTokensMap","inactiveTokens","activeTokensAddresses","Object","keys","filteredInactive","newMap","includes","useUnsupportedTokens","unsupportedTokensMap","useIsTokenActive","activeTokens","useFoundOnInactiveList","searchQuery","undefined","tokens","values","useIsUserAddedToken","currency","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","tokenContract","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","useCurrency","currencyId","isBNB","toUpperCase"],"mappings":";;;;;;;;;;;AAAA;AACA,SAASA,kBAAT,QAAmC,wBAAnC;AACA,SAAmBC,KAAnB,EAA0BC,KAA1B,EAAiCC,cAAjC,QAAuD,kBAAvD;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,QAAT,QAAyB,kBAAzB;AACA,OAAOC,kBAAP,MAA+B,0BAA/B;AACA,SAEEC,mBAFF,EAGEC,uBAHF,EAIEC,qBAJF,EAKEC,uBALF,QAMO,sBANP;AAQA,SAASC,YAAT,EAAuBC,mBAAvB,QAAkD,0BAAlD;AACA,OAAOC,kBAAP,MAA+B,wCAA/B;AACA,SAASC,SAAT,QAA0B,UAA1B;AAEA,SAASC,uBAAT,EAAkCC,gBAAlC,QAA0D,eAA1D;AACA,SAASC,YAAT,QAA6B,qCAA7B,C,CAEA;;AACA,SAASC,gBAAT,CAA0BC,QAA1B,EAAqDC,gBAArD,EAA8G;AAAA;;AAC5G,QAAM;AAAEC,IAAAA;AAAF,MAAcf,kBAAkB,EAAtC;AACA,QAAMgB,eAAe,GAAGT,kBAAkB,EAA1C;AAEA,SAAOT,OAAO,CAAC,MAAM;AACnB,QAAI,CAACiB,OAAL,EAAc,OAAO,EAAP;AAGlB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI,UAAME,cAAc,GAAG,EAAvB;;AAGA,QAAIH,gBAAJ,EAAsB;AACpB,aACEE,eAAe,CACb;AADa,OAEZE,MAFH,CAGI,CAACC,SAAD,EAAYC,KAAZ,KAAsB;AACpBD,QAAAA,SAAS,CAACC,KAAK,CAACC,OAAP,CAAT,GAA2BD,KAA3B;AACA,eAAOD,SAAP;AACD,OANL,EAOI;AACA;AACA,QAAE,GAAGF;AAAL,OATJ,CADF;AAaD;;AAED,WAAOA,cAAP;AACD,GAvCa,EAuCX,CAACF,OAAD,EAAUC,eAAV,EAA4BF,gBAA5B,CAvCW,CAAd,CAJ4G,CA2CzD;AACpD;;GA5CQF,gB;UACaZ,kB,EACIO,kB;;;AA4C1B,OAAO,SAASe,gBAAT,GAA0D;AAAA;;AAC/D,QAAMC,WAAW,GAAGtB,mBAAmB,EAAvC;AACA,SAAOW,gBAAgB,CAACW,WAAD,EAAc,KAAd,CAAvB;AACD;;IAHeD,gB;UACMrB,mB,EACbW,gB;;;AAGT,OAAO,SAASY,YAAT,GAAsD;AAAA;;AAC3D,QAAMC,SAAS,GAAGtB,qBAAqB,EAAvC;AACA,SAAOS,gBAAgB,CAACa,SAAD,EAAY,IAAZ,CAAvB;AACD;;IAHeD,Y;UACIrB,qB,EACXS,gB;;;AAGT,OAAO,SAASc,oBAAT,GAA8D;AAAA;;AACnE;AACA,QAAMC,iBAAiB,GAAGvB,uBAAuB,EAAjD;AACA,QAAMwB,cAAc,GAAGhB,gBAAgB,CAACe,iBAAD,EAAoB,KAApB,CAAvC,CAHmE,CAKnE;;AACA,QAAME,qBAAqB,GAAGC,MAAM,CAACC,IAAP,CAAYP,YAAY,EAAxB,CAA9B;AACA,QAAMQ,gBAAgB,GAAGH,qBAAqB,GAC1CC,MAAM,CAACC,IAAP,CAAYH,cAAZ,EAA4BV,MAA5B,CAAiE,CAACe,MAAD,EAASZ,OAAT,KAAqB;AACpF,QAAI,CAACQ,qBAAqB,CAACK,QAAtB,CAA+Bb,OAA/B,CAAL,EAA8C;AAC5CY,MAAAA,MAAM,CAACZ,OAAD,CAAN,GAAkBO,cAAc,CAACP,OAAD,CAAhC;AACD;;AACD,WAAOY,MAAP;AACD,GALD,EAKG,EALH,CAD0C,GAO1CL,cAPJ;AASA,SAAOI,gBAAP;AACD;;IAjBeN,oB;UAEYtB,uB,EACHQ,gB,EAGmBY,Y;;;AAa5C,OAAO,SAASW,oBAAT,GAA8D;AAAA;;AACnE,QAAMC,oBAAoB,GAAGlC,uBAAuB,EAApD;AACA,SAAOU,gBAAgB,CAACwB,oBAAD,EAAuB,KAAvB,CAAvB;AACD;;IAHeD,oB;UACejC,uB,EACtBU,gB;;;AAGT,OAAO,SAASyB,gBAAT,CAA0BjB,KAA1B,EAAoE;AAAA;;AACzE,QAAMkB,YAAY,GAAGd,YAAY,EAAjC;;AAEA,MAAI,CAACc,YAAD,IAAiB,CAAClB,KAAtB,EAA6B;AAC3B,WAAO,KAAP;AACD;;AAED,SAAO,CAAC,CAACkB,YAAY,CAAClB,KAAK,CAACC,OAAP,CAArB;AACD,C,CAED;;IAVgBgB,gB;UACOb,Y;;;AAUvB,OAAO,SAASe,sBAAT,CAAgCC,WAAhC,EAA0E;AAAA;;AAC/E,QAAM;AAAEzB,IAAAA;AAAF,MAAcf,kBAAkB,EAAtC;AACA,QAAM4B,cAAc,GAAGF,oBAAoB,EAA3C;AAEA,SAAO5B,OAAO,CAAC,MAAM;AACnB,QAAI,CAACiB,OAAD,IAAYyB,WAAW,KAAK,EAAhC,EAAoC;AAClC,aAAOC,SAAP;AACD;;AACD,UAAMC,MAAM,GAAG/B,YAAY,CAACmB,MAAM,CAACa,MAAP,CAAcf,cAAd,CAAD,EAAgCY,WAAhC,CAA3B;AACA,WAAOE,MAAP;AACD,GANa,EAMX,CAAC3B,OAAD,EAAUa,cAAV,EAA0BY,WAA1B,CANW,CAAd;AAOD,C,CAED;;IAbgBD,sB;UACMvC,kB,EACG0B,oB;;;AAYzB,OAAO,SAASkB,mBAAT,CAA6BC,QAA7B,EAA6E;AAAA;;AAClF,QAAM7B,eAAe,GAAGT,kBAAkB,EAA1C;;AAEA,MAAI,CAACsC,QAAL,EAAe;AACb,WAAO,KAAP;AACD;;AAED,SAAO,CAAC,CAAC7B,eAAe,CAAC8B,IAAhB,CAAsB1B,KAAD,IAAWvB,cAAc,CAACgD,QAAD,EAAWzB,KAAX,CAA9C,CAAT;AACD,C,CAED;;IAVgBwB,mB;UACUrC,kB;;;AAU1B,MAAMwC,aAAa,GAAG,qBAAtB;;AAEA,SAASC,oBAAT,CAA8BC,GAA9B,EAAuDC,OAAvD,EAAoFC,YAApF,EAAkH;AAChH,SAAOF,GAAG,IAAIA,GAAG,CAACG,MAAJ,GAAa,CAApB,GACHH,GADG,GAEH;AACFC,EAAAA,OAAO,IAAIH,aAAa,CAACM,IAAd,CAAmBH,OAAnB,CAAX,IAA0CnD,QAAQ,CAACmD,OAAD,CAAR,CAAkB,EAAlB,MAA0B,CAApE,GACExD,kBAAkB,CAACwD,OAAD,CADpB,GAEEC,YALJ;AAMD,C,CAED;AACA;AACA;;;AACA,OAAO,SAASG,QAAT,CAAkBC,YAAlB,EAAmE;AAAA;;AACxE,QAAM;AAAExC,IAAAA;AAAF,MAAcf,kBAAkB,EAAtC;AACA,QAAM0C,MAAM,GAAGlB,YAAY,EAA3B;AAEA,QAAMH,OAAO,GAAGb,SAAS,CAAC+C,YAAD,CAAzB;AAEA,QAAMC,aAAa,GAAG9C,gBAAgB,CAACW,OAAO,IAAIoB,SAAZ,EAAuB,KAAvB,CAAtC;AACA,QAAMgB,oBAAoB,GAAGhD,uBAAuB,CAACY,OAAO,IAAIoB,SAAZ,EAAuB,KAAvB,CAApD;AACA,QAAMrB,KAAwB,GAAGC,OAAO,GAAGqB,MAAM,CAACrB,OAAD,CAAT,GAAqBoB,SAA7D;AAEA,QAAMiB,SAAS,GAAGpD,mBAAmB,CAACc,KAAK,GAAGqB,SAAH,GAAee,aAArB,EAAoC,MAApC,EAA4Cf,SAA5C,EAAuDpC,YAAvD,CAArC;AACA,QAAMsD,gBAAgB,GAAGrD,mBAAmB,CAC1Cc,KAAK,GAAGqB,SAAH,GAAegB,oBADsB,EAE1C,MAF0C,EAG1ChB,SAH0C,EAI1CpC,YAJ0C,CAA5C;AAMA,QAAMuD,MAAM,GAAGtD,mBAAmB,CAACc,KAAK,GAAGqB,SAAH,GAAee,aAArB,EAAoC,QAApC,EAA8Cf,SAA9C,EAAyDpC,YAAzD,CAAlC;AACA,QAAMwD,aAAa,GAAGvD,mBAAmB,CAACc,KAAK,GAAGqB,SAAH,GAAegB,oBAArB,EAA2C,QAA3C,EAAqDhB,SAArD,EAAgEpC,YAAhE,CAAzC;AACA,QAAMyD,QAAQ,GAAGxD,mBAAmB,CAACc,KAAK,GAAGqB,SAAH,GAAee,aAArB,EAAoC,UAApC,EAAgDf,SAAhD,EAA2DpC,YAA3D,CAApC;AAEA,SAAOP,OAAO,CAAC,MAAM;AACnB,QAAIsB,KAAJ,EAAW,OAAOA,KAAP;AACX,QAAI,CAACL,OAAD,IAAY,CAACM,OAAjB,EAA0B,OAAOoB,SAAP;AAC1B,QAAIqB,QAAQ,CAACC,OAAT,IAAoBH,MAAM,CAACG,OAA3B,IAAsCL,SAAS,CAACK,OAApD,EAA6D,OAAO,IAAP;;AAC7D,QAAID,QAAQ,CAACE,MAAb,EAAqB;AAAA;;AACnB,aAAO,IAAIpE,KAAJ,CACLmB,OADK,EAELM,OAFK,EAGLyC,QAAQ,CAACE,MAAT,CAAgB,CAAhB,CAHK,EAILhB,oBAAoB,mBAACY,MAAM,CAACI,MAAR,mDAAC,eAAgB,CAAhB,CAAD,2BAAqBH,aAAa,CAACG,MAAnC,0DAAqB,sBAAuB,CAAvB,CAArB,EAAgD,SAAhD,CAJf,EAKLhB,oBAAoB,sBAACU,SAAS,CAACM,MAAX,sDAAC,kBAAmB,CAAnB,CAAD,2BAAwBL,gBAAgB,CAACK,MAAzC,0DAAwB,sBAA0B,CAA1B,CAAxB,EAAsD,eAAtD,CALf,CAAP;AAOD;;AACD,WAAOvB,SAAP;AACD,GAda,EAcX,CACDpB,OADC,EAEDN,OAFC,EAGD+C,QAAQ,CAACC,OAHR,EAIDD,QAAQ,CAACE,MAJR,EAKDJ,MAAM,CAACG,OALN,EAMDH,MAAM,CAACI,MANN,EAODH,aAAa,CAACG,MAPb,EAQD5C,KARC,EASDsC,SAAS,CAACK,OATT,EAUDL,SAAS,CAACM,MAVT,EAWDL,gBAAgB,CAACK,MAXhB,CAdW,CAAd;AA2BD;;IAhDeV,Q;UACMtD,kB,EACLwB,Y,EAIOd,gB,EACOD,uB,EAGXH,mB,EACOA,mB,EAMVA,mB,EACOA,mB,EACLA,mB;;;AA+BnB,OAAO,SAAS2D,WAAT,CAAqBC,UAArB,EAAkF;AAAA;;AACvF,QAAMC,KAAK,GAAG,CAAAD,UAAU,SAAV,IAAAA,UAAU,WAAV,YAAAA,UAAU,CAAEE,WAAZ,QAA8B,KAA5C;AACA,QAAMhD,KAAK,GAAGkC,QAAQ,CAACa,KAAK,GAAG1B,SAAH,GAAeyB,UAArB,CAAtB;AACA,SAAOC,KAAK,GAAGxE,KAAH,GAAWyB,KAAvB;AACD;;KAJe6C,W;UAEAX,Q","sourcesContent":["/* eslint-disable no-param-reassign */\r\nimport { parseBytes32String } from '@ethersproject/strings'\r\nimport { Currency, ETHER, Token, currencyEquals } from '@pancakeswap/sdk'\r\nimport { useMemo } from 'react'\r\nimport { arrayify } from 'ethers/lib/utils'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport {\r\n  TokenAddressMap,\r\n  useDefaultTokenList,\r\n  useUnsupportedTokenList,\r\n  useCombinedActiveList,\r\n  useCombinedInactiveList,\r\n} from '../state/lists/hooks'\r\n\r\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks'\r\nimport useUserAddedTokens from '../state/user/hooks/useUserAddedTokens'\r\nimport { isAddress } from '../utils'\r\n\r\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\r\nimport { filterTokens } from '../components/SearchModal/filtering'\r\n\r\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\r\nfunction useTokensFromMap(tokenMap: TokenAddressMap, includeUserAdded: boolean): { [address: string]: Token } {\r\n  const { chainId } = useActiveWeb3React()\r\n  const userAddedTokens = useUserAddedTokens()\r\n\r\n  return useMemo(() => {\r\n    if (!chainId) return {}\r\n\r\n\r\n/*     const object1 = {\r\n      a: 'somestring',\r\n      b: 42,\r\n      c: false,\r\n    }; */\r\n    \r\n/*     // reduce to just tokens\r\n    const mapWithoutUrlspt1 = Object.keys(tokenMap[chainId]);\r\n    \r\n    \r\n    const mapWithoutUrls = mapWithoutUrlspt1.reduce <{ [address: string]: Token }> ((newMap, address) => {\r\n      newMap[address] = tokenMap[chainId][address].token\r\n      return newMap\r\n    }, {})  */\r\n\r\n    const mapWithoutUrls = {};\r\n\r\n\r\n    if (includeUserAdded) {\r\n      return (\r\n        userAddedTokens\r\n          // reduce into all ALL_TOKENS filtered by the current chain\r\n          .reduce<{ [address: string]: Token }>(\r\n            (tokenMap_, token) => {\r\n              tokenMap_[token.address] = token\r\n              return tokenMap_\r\n            },\r\n            // must make a copy because reduce modifies the map, and we do not\r\n            // want to make a copy in every iteration\r\n            { ...mapWithoutUrls },\r\n          )\r\n      )\r\n    }\r\n\r\n    return mapWithoutUrls\r\n  }, [chainId, userAddedTokens,  includeUserAdded])  //  tokenMap, hier rausgenommen\r\n}\r\n\r\nexport function useDefaultTokens(): { [address: string]: Token } {\r\n  const defaultList = useDefaultTokenList()\r\n  return useTokensFromMap(defaultList, false)\r\n}\r\n\r\nexport function useAllTokens(): { [address: string]: Token } {\r\n  const allTokens = useCombinedActiveList()\r\n  return useTokensFromMap(allTokens, true)\r\n}\r\n\r\nexport function useAllInactiveTokens(): { [address: string]: Token } {\r\n  // get inactive tokens\r\n  const inactiveTokensMap = useCombinedInactiveList()\r\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false)\r\n\r\n  // filter out any token that are on active list\r\n  const activeTokensAddresses = Object.keys(useAllTokens())\r\n  const filteredInactive = activeTokensAddresses\r\n    ? Object.keys(inactiveTokens).reduce<{ [address: string]: Token }>((newMap, address) => {\r\n        if (!activeTokensAddresses.includes(address)) {\r\n          newMap[address] = inactiveTokens[address]\r\n        }\r\n        return newMap\r\n      }, {})\r\n    : inactiveTokens\r\n\r\n  return filteredInactive\r\n}\r\n\r\nexport function useUnsupportedTokens(): { [address: string]: Token } {\r\n  const unsupportedTokensMap = useUnsupportedTokenList()\r\n  return useTokensFromMap(unsupportedTokensMap, false)\r\n}\r\n\r\nexport function useIsTokenActive(token: Token | undefined | null): boolean {\r\n  const activeTokens = useAllTokens()\r\n\r\n  if (!activeTokens || !token) {\r\n    return false\r\n  }\r\n\r\n  return !!activeTokens[token.address]\r\n}\r\n\r\n// used to detect extra search results\r\nexport function useFoundOnInactiveList(searchQuery: string): Token[] | undefined {\r\n  const { chainId } = useActiveWeb3React()\r\n  const inactiveTokens = useAllInactiveTokens()\r\n\r\n  return useMemo(() => {\r\n    if (!chainId || searchQuery === '') {\r\n      return undefined\r\n    }\r\n    const tokens = filterTokens(Object.values(inactiveTokens), searchQuery)\r\n    return tokens\r\n  }, [chainId, inactiveTokens, searchQuery])\r\n}\r\n\r\n// Check if currency is included in custom list from user storage\r\nexport function useIsUserAddedToken(currency: Currency | undefined | null): boolean {\r\n  const userAddedTokens = useUserAddedTokens()\r\n\r\n  if (!currency) {\r\n    return false\r\n  }\r\n\r\n  return !!userAddedTokens.find((token) => currencyEquals(currency, token))\r\n}\r\n\r\n// parse a name or symbol from a token response\r\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\r\n\r\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\r\n  return str && str.length > 0\r\n    ? str\r\n    : // need to check for proper bytes string and valid terminator\r\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\r\n    ? parseBytes32String(bytes32)\r\n    : defaultValue\r\n}\r\n\r\n// undefined if invalid or does not exist\r\n// null if loading\r\n// otherwise returns the token\r\nexport function useToken(tokenAddress?: string): Token | undefined | null {\r\n  const { chainId } = useActiveWeb3React()\r\n  const tokens = useAllTokens()\r\n\r\n  const address = isAddress(tokenAddress)\r\n\r\n  const tokenContract = useTokenContract(address || undefined, false)\r\n  const tokenContractBytes32 = useBytes32TokenContract(address || undefined, false)\r\n  const token: Token | undefined = address ? tokens[address] : undefined\r\n\r\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\r\n  const tokenNameBytes32 = useSingleCallResult(\r\n    token ? undefined : tokenContractBytes32,\r\n    'name',\r\n    undefined,\r\n    NEVER_RELOAD,\r\n  )\r\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\r\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\r\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\r\n\r\n  return useMemo(() => {\r\n    if (token) return token\r\n    if (!chainId || !address) return undefined\r\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\r\n    if (decimals.result) {\r\n      return new Token(\r\n        chainId,\r\n        address,\r\n        decimals.result[0],\r\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\r\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token'),\r\n      )\r\n    }\r\n    return undefined\r\n  }, [\r\n    address,\r\n    chainId,\r\n    decimals.loading,\r\n    decimals.result,\r\n    symbol.loading,\r\n    symbol.result,\r\n    symbolBytes32.result,\r\n    token,\r\n    tokenName.loading,\r\n    tokenName.result,\r\n    tokenNameBytes32.result,\r\n  ])\r\n}\r\n\r\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\r\n  const isBNB = currencyId?.toUpperCase() === 'BNB'\r\n  const token = useToken(isBNB ? undefined : currencyId)\r\n  return isBNB ? ETHER : token\r\n}\r\n"]},"metadata":{},"sourceType":"module"}