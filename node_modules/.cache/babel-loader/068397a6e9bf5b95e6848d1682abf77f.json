{"ast":null,"code":"import CID from 'cids';\nimport { getCodec, rmPrefix } from 'multicodec';\nimport { decode, toB58String } from 'multihashes';\n\nfunction hexToUint8Array(hex) {\n  // eslint-disable-next-line no-param-reassign\n  hex = hex.startsWith('0x') ? hex.substr(2) : hex;\n  if (hex.length % 2 !== 0) throw new Error('hex must have length that is multiple of 2');\n  const arr = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = parseInt(hex.substr(i * 2, 2), 16);\n  }\n\n  return arr;\n}\n\nconst UTF_8_DECODER = new TextDecoder();\n/**\r\n * Returns the URI representation of the content hash for supported codecs\r\n * @param contenthash to decode\r\n */\n\nexport default function contenthashToUri(contenthash) {\n  const buff = hexToUint8Array(contenthash);\n  const codec = getCodec(buff); // the typing is wrong for @types/multicodec\n\n  switch (codec) {\n    case 'ipfs-ns':\n      {\n        const data = rmPrefix(buff);\n        const cid = new CID(data);\n        return `ipfs://${toB58String(cid.multihash)}`;\n      }\n\n    case 'ipns-ns':\n      {\n        const data = rmPrefix(buff);\n        const cid = new CID(data);\n        const multihash = decode(cid.multihash);\n\n        if (multihash.name === 'identity') {\n          return `ipns://${UTF_8_DECODER.decode(multihash.digest).trim()}`;\n        }\n\n        return `ipns://${toB58String(cid.multihash)}`;\n      }\n\n    default:\n      throw new Error(`Unrecognized codec: ${codec}`);\n  }\n}","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/utils/contenthashToUri.ts"],"names":["CID","getCodec","rmPrefix","decode","toB58String","hexToUint8Array","hex","startsWith","substr","length","Error","arr","Uint8Array","i","parseInt","UTF_8_DECODER","TextDecoder","contenthashToUri","contenthash","buff","codec","data","cid","multihash","name","digest","trim"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,MAAhB;AACA,SAASC,QAAT,EAAmBC,QAAnB,QAAmC,YAAnC;AACA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,aAApC;;AAEA,SAASC,eAAT,CAAyBC,GAAzB,EAAkD;AAChD;AACAA,EAAAA,GAAG,GAAGA,GAAG,CAACC,UAAJ,CAAe,IAAf,IAAuBD,GAAG,CAACE,MAAJ,CAAW,CAAX,CAAvB,GAAuCF,GAA7C;AACA,MAAIA,GAAG,CAACG,MAAJ,GAAa,CAAb,KAAmB,CAAvB,EAA0B,MAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;AAC1B,QAAMC,GAAG,GAAG,IAAIC,UAAJ,CAAeN,GAAG,CAACG,MAAJ,GAAa,CAA5B,CAAZ;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACF,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;AACnCF,IAAAA,GAAG,CAACE,CAAD,CAAH,GAASC,QAAQ,CAACR,GAAG,CAACE,MAAJ,CAAWK,CAAC,GAAG,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAjB;AACD;;AACD,SAAOF,GAAP;AACD;;AAED,MAAMI,aAAa,GAAG,IAAIC,WAAJ,EAAtB;AAEA;AACA;AACA;AACA;;AACA,eAAe,SAASC,gBAAT,CAA0BC,WAA1B,EAAuD;AACpE,QAAMC,IAAI,GAAGd,eAAe,CAACa,WAAD,CAA5B;AACA,QAAME,KAAK,GAAGnB,QAAQ,CAACkB,IAAD,CAAtB,CAFoE,CAE7B;;AACvC,UAAQC,KAAR;AACE,SAAK,SAAL;AAAgB;AACd,cAAMC,IAAI,GAAGnB,QAAQ,CAACiB,IAAD,CAArB;AACA,cAAMG,GAAG,GAAG,IAAItB,GAAJ,CAAQqB,IAAR,CAAZ;AACA,eAAQ,UAASjB,WAAW,CAACkB,GAAG,CAACC,SAAL,CAAgB,EAA5C;AACD;;AACD,SAAK,SAAL;AAAgB;AACd,cAAMF,IAAI,GAAGnB,QAAQ,CAACiB,IAAD,CAArB;AACA,cAAMG,GAAG,GAAG,IAAItB,GAAJ,CAAQqB,IAAR,CAAZ;AACA,cAAME,SAAS,GAAGpB,MAAM,CAACmB,GAAG,CAACC,SAAL,CAAxB;;AACA,YAAIA,SAAS,CAACC,IAAV,KAAmB,UAAvB,EAAmC;AACjC,iBAAQ,UAAST,aAAa,CAACZ,MAAd,CAAqBoB,SAAS,CAACE,MAA/B,EAAuCC,IAAvC,EAA8C,EAA/D;AACD;;AACD,eAAQ,UAAStB,WAAW,CAACkB,GAAG,CAACC,SAAL,CAAgB,EAA5C;AACD;;AACD;AACE,YAAM,IAAIb,KAAJ,CAAW,uBAAsBU,KAAM,EAAvC,CAAN;AAhBJ;AAkBD","sourcesContent":["import CID from 'cids'\r\nimport { getCodec, rmPrefix } from 'multicodec'\r\nimport { decode, toB58String } from 'multihashes'\r\n\r\nfunction hexToUint8Array(hex: string): Uint8Array {\r\n  // eslint-disable-next-line no-param-reassign\r\n  hex = hex.startsWith('0x') ? hex.substr(2) : hex\r\n  if (hex.length % 2 !== 0) throw new Error('hex must have length that is multiple of 2')\r\n  const arr = new Uint8Array(hex.length / 2)\r\n  for (let i = 0; i < arr.length; i++) {\r\n    arr[i] = parseInt(hex.substr(i * 2, 2), 16)\r\n  }\r\n  return arr\r\n}\r\n\r\nconst UTF_8_DECODER = new TextDecoder()\r\n\r\n/**\r\n * Returns the URI representation of the content hash for supported codecs\r\n * @param contenthash to decode\r\n */\r\nexport default function contenthashToUri(contenthash: string): string {\r\n  const buff = hexToUint8Array(contenthash)\r\n  const codec = getCodec(buff as Buffer) // the typing is wrong for @types/multicodec\r\n  switch (codec) {\r\n    case 'ipfs-ns': {\r\n      const data = rmPrefix(buff as Buffer)\r\n      const cid = new CID(data)\r\n      return `ipfs://${toB58String(cid.multihash)}`\r\n    }\r\n    case 'ipns-ns': {\r\n      const data = rmPrefix(buff as Buffer)\r\n      const cid = new CID(data)\r\n      const multihash = decode(cid.multihash)\r\n      if (multihash.name === 'identity') {\r\n        return `ipns://${UTF_8_DECODER.decode(multihash.digest).trim()}`\r\n      }\r\n      return `ipns://${toB58String(cid.multihash)}`\r\n    }\r\n    default:\r\n      throw new Error(`Unrecognized codec: ${codec}`)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}