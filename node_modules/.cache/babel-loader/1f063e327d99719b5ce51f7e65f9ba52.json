{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport BigNumber from 'bignumber.js';\nimport poolsConfig from 'config/constants/pools';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { getPoolApr } from 'utils/apr';\nimport { getBalanceNumber } from 'utils/formatBalance';\nimport { getAddress } from 'utils/addressHelpers';\nimport { fetchPoolsBlockLimits, fetchPoolsStakingLimits, fetchPoolsTotalStaking } from './fetchPools';\nimport { fetchPoolsAllowance, fetchUserBalances, fetchUserStakeBalances, fetchUserPendingRewards } from './fetchPoolsUser';\nimport { fetchPublicVaultData, fetchVaultFees } from './fetchVaultPublic';\nimport fetchVaultUser from './fetchVaultUser';\nimport { getTokenPricesFromFarm } from './helpers';\nconst initialState = {\n  data: [...poolsConfig],\n  userDataLoaded: false,\n  cakeVault: {\n    totalShares: null,\n    pricePerFullShare: null,\n    totalCakeInVault: null,\n    estimatedCakeBountyReward: null,\n    totalPendingCakeHarvest: null,\n    fees: {\n      performanceFee: null,\n      callFee: null,\n      withdrawalFee: null,\n      withdrawalFeePeriod: null\n    },\n    userData: {\n      isLoading: true,\n      userShares: null,\n      cakeAtLastUserAction: null,\n      lastDepositedTime: null,\n      lastUserActionTime: null\n    }\n  }\n}; // Thunks\n\nexport const fetchPoolsPublicDataAsync = currentBlock => async (dispatch, getState) => {\n  const blockLimits = await fetchPoolsBlockLimits();\n  const totalStakings = await fetchPoolsTotalStaking();\n  const prices = getTokenPricesFromFarm(getState().farms.data);\n  const liveData = poolsConfig.map(pool => {\n    const blockLimit = blockLimits.find(entry => entry.sousId === pool.sousId);\n    const totalStaking = totalStakings.find(entry => entry.sousId === pool.sousId);\n    const isPoolEndBlockExceeded = currentBlock > 0 && blockLimit ? currentBlock > Number(blockLimit.endBlock) : false;\n    const isPoolFinished = pool.isFinished || isPoolEndBlockExceeded;\n    const stakingTokenAddress = pool.stakingToken.address ? getAddress(pool.stakingToken.address).toLowerCase() : null;\n    const stakingTokenPrice = stakingTokenAddress ? prices[stakingTokenAddress] : 0;\n    const earningTokenAddress = pool.earningToken.address ? getAddress(pool.earningToken.address).toLowerCase() : null;\n    const earningTokenPrice = earningTokenAddress ? prices[earningTokenAddress] : 0;\n    const apr = !isPoolFinished ? getPoolApr(stakingTokenPrice, earningTokenPrice, getBalanceNumber(new BigNumber(totalStaking.totalStaked), pool.stakingToken.decimals), parseFloat(pool.tokenPerBlock)) : 0;\n    return { ...blockLimit,\n      ...totalStaking,\n      stakingTokenPrice,\n      earningTokenPrice,\n      apr,\n      isFinished: isPoolFinished\n    };\n  });\n  dispatch(setPoolsPublicData(liveData));\n};\nexport const fetchPoolsStakingLimitsAsync = () => async (dispatch, getState) => {\n  const poolsWithStakingLimit = getState().pools.data.filter(({\n    stakingLimit\n  }) => stakingLimit !== null && stakingLimit !== undefined).map(pool => pool.sousId);\n  const stakingLimits = await fetchPoolsStakingLimits(poolsWithStakingLimit);\n  const stakingLimitData = poolsConfig.map(pool => {\n    if (poolsWithStakingLimit.includes(pool.sousId)) {\n      return {\n        sousId: pool.sousId\n      };\n    }\n\n    const stakingLimit = stakingLimits[pool.sousId] || BIG_ZERO;\n    return {\n      sousId: pool.sousId,\n      stakingLimit: stakingLimit.toJSON()\n    };\n  });\n  dispatch(setPoolsPublicData(stakingLimitData));\n};\nexport const fetchPoolsUserDataAsync = account => async dispatch => {\n  const allowances = await fetchPoolsAllowance(account);\n  const stakingTokenBalances = await fetchUserBalances(account);\n  const stakedBalances = await fetchUserStakeBalances(account);\n  const pendingRewards = await fetchUserPendingRewards(account);\n  const userData = poolsConfig.map(pool => ({\n    sousId: pool.sousId,\n    allowance: allowances[pool.sousId],\n    stakingTokenBalance: stakingTokenBalances[pool.sousId],\n    stakedBalance: stakedBalances[pool.sousId],\n    pendingReward: pendingRewards[pool.sousId]\n  }));\n  dispatch(setPoolsUserData(userData));\n};\nexport const updateUserAllowance = (sousId, account) => async dispatch => {\n  const allowances = await fetchPoolsAllowance(account);\n  dispatch(updatePoolsUserData({\n    sousId,\n    field: 'allowance',\n    value: allowances[sousId]\n  }));\n};\nexport const updateUserBalance = (sousId, account) => async dispatch => {\n  const tokenBalances = await fetchUserBalances(account);\n  dispatch(updatePoolsUserData({\n    sousId,\n    field: 'stakingTokenBalance',\n    value: tokenBalances[sousId]\n  }));\n};\nexport const updateUserStakedBalance = (sousId, account) => async dispatch => {\n  const stakedBalances = await fetchUserStakeBalances(account);\n  dispatch(updatePoolsUserData({\n    sousId,\n    field: 'stakedBalance',\n    value: stakedBalances[sousId]\n  }));\n};\nexport const updateUserPendingReward = (sousId, account) => async dispatch => {\n  const pendingRewards = await fetchUserPendingRewards(account);\n  dispatch(updatePoolsUserData({\n    sousId,\n    field: 'pendingReward',\n    value: pendingRewards[sousId]\n  }));\n};\nexport const fetchCakeVaultPublicData = createAsyncThunk('cakeVault/fetchPublicData', async () => {\n  const publicVaultInfo = await fetchPublicVaultData();\n  return publicVaultInfo;\n});\nexport const fetchCakeVaultFees = createAsyncThunk('cakeVault/fetchFees', async () => {\n  const vaultFees = await fetchVaultFees();\n  return vaultFees;\n});\nexport const fetchCakeVaultUserData = createAsyncThunk('cakeVault/fetchUser', async ({\n  account\n}) => {\n  const userData = await fetchVaultUser(account);\n  return userData;\n});\nexport const PoolsSlice = createSlice({\n  name: 'Pools',\n  initialState,\n  reducers: {\n    setPoolsPublicData: (state, action) => {\n      const livePoolsData = action.payload;\n      state.data = state.data.map(pool => {\n        const livePoolData = livePoolsData.find(entry => entry.sousId === pool.sousId);\n        return { ...pool,\n          ...livePoolData\n        };\n      });\n    },\n    setPoolsUserData: (state, action) => {\n      const userData = action.payload;\n      state.data = state.data.map(pool => {\n        const userPoolData = userData.find(entry => entry.sousId === pool.sousId);\n        return { ...pool,\n          userData: userPoolData\n        };\n      });\n      state.userDataLoaded = true;\n    },\n    updatePoolsUserData: (state, action) => {\n      const {\n        field,\n        value,\n        sousId\n      } = action.payload;\n      const index = state.data.findIndex(p => p.sousId === sousId);\n\n      if (index >= 0) {\n        state.data[index] = { ...state.data[index],\n          userData: { ...state.data[index].userData,\n            [field]: value\n          }\n        };\n      }\n    }\n  },\n  extraReducers: builder => {\n    // Vault public data that updates frequently\n    builder.addCase(fetchCakeVaultPublicData.fulfilled, (state, action) => {\n      state.cakeVault = { ...state.cakeVault,\n        ...action.payload\n      };\n    }); // Vault fees\n\n    builder.addCase(fetchCakeVaultFees.fulfilled, (state, action) => {\n      const fees = action.payload;\n      state.cakeVault = { ...state.cakeVault,\n        fees\n      };\n    }); // Vault user data\n\n    builder.addCase(fetchCakeVaultUserData.fulfilled, (state, action) => {\n      const userData = action.payload;\n      userData.isLoading = false;\n      state.cakeVault = { ...state.cakeVault,\n        userData\n      };\n    });\n  }\n}); // Actions\n\nexport const {\n  setPoolsPublicData,\n  setPoolsUserData,\n  updatePoolsUserData\n} = PoolsSlice.actions;\nexport default PoolsSlice.reducer;","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/pools/index.ts"],"names":["createAsyncThunk","createSlice","BigNumber","poolsConfig","BIG_ZERO","getPoolApr","getBalanceNumber","getAddress","fetchPoolsBlockLimits","fetchPoolsStakingLimits","fetchPoolsTotalStaking","fetchPoolsAllowance","fetchUserBalances","fetchUserStakeBalances","fetchUserPendingRewards","fetchPublicVaultData","fetchVaultFees","fetchVaultUser","getTokenPricesFromFarm","initialState","data","userDataLoaded","cakeVault","totalShares","pricePerFullShare","totalCakeInVault","estimatedCakeBountyReward","totalPendingCakeHarvest","fees","performanceFee","callFee","withdrawalFee","withdrawalFeePeriod","userData","isLoading","userShares","cakeAtLastUserAction","lastDepositedTime","lastUserActionTime","fetchPoolsPublicDataAsync","currentBlock","dispatch","getState","blockLimits","totalStakings","prices","farms","liveData","map","pool","blockLimit","find","entry","sousId","totalStaking","isPoolEndBlockExceeded","Number","endBlock","isPoolFinished","isFinished","stakingTokenAddress","stakingToken","address","toLowerCase","stakingTokenPrice","earningTokenAddress","earningToken","earningTokenPrice","apr","totalStaked","decimals","parseFloat","tokenPerBlock","setPoolsPublicData","fetchPoolsStakingLimitsAsync","poolsWithStakingLimit","pools","filter","stakingLimit","undefined","stakingLimits","stakingLimitData","includes","toJSON","fetchPoolsUserDataAsync","account","allowances","stakingTokenBalances","stakedBalances","pendingRewards","allowance","stakingTokenBalance","stakedBalance","pendingReward","setPoolsUserData","updateUserAllowance","updatePoolsUserData","field","value","updateUserBalance","tokenBalances","updateUserStakedBalance","updateUserPendingReward","fetchCakeVaultPublicData","publicVaultInfo","fetchCakeVaultFees","vaultFees","fetchCakeVaultUserData","PoolsSlice","name","reducers","state","action","livePoolsData","payload","livePoolData","userPoolData","index","findIndex","p","extraReducers","builder","addCase","fulfilled","actions","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\r\nimport BigNumber from 'bignumber.js'\r\nimport poolsConfig from 'config/constants/pools'\r\nimport { BIG_ZERO } from 'utils/bigNumber'\r\nimport { PoolsState, Pool, CakeVault, VaultFees, VaultUser, AppThunk } from 'state/types'\r\nimport { getPoolApr } from 'utils/apr'\r\nimport { getBalanceNumber } from 'utils/formatBalance'\r\nimport { getAddress } from 'utils/addressHelpers'\r\nimport { fetchPoolsBlockLimits, fetchPoolsStakingLimits, fetchPoolsTotalStaking } from './fetchPools'\r\nimport {\r\n  fetchPoolsAllowance,\r\n  fetchUserBalances,\r\n  fetchUserStakeBalances,\r\n  fetchUserPendingRewards,\r\n} from './fetchPoolsUser'\r\nimport { fetchPublicVaultData, fetchVaultFees } from './fetchVaultPublic'\r\nimport fetchVaultUser from './fetchVaultUser'\r\nimport { getTokenPricesFromFarm } from './helpers'\r\n\r\nconst initialState: PoolsState = {\r\n  data: [...poolsConfig],\r\n  userDataLoaded: false,\r\n  cakeVault: {\r\n    totalShares: null,\r\n    pricePerFullShare: null,\r\n    totalCakeInVault: null,\r\n    estimatedCakeBountyReward: null,\r\n    totalPendingCakeHarvest: null,\r\n    fees: {\r\n      performanceFee: null,\r\n      callFee: null,\r\n      withdrawalFee: null,\r\n      withdrawalFeePeriod: null,\r\n    },\r\n    userData: {\r\n      isLoading: true,\r\n      userShares: null,\r\n      cakeAtLastUserAction: null,\r\n      lastDepositedTime: null,\r\n      lastUserActionTime: null,\r\n    },\r\n  },\r\n}\r\n\r\n// Thunks\r\nexport const fetchPoolsPublicDataAsync = (currentBlock: number) => async (dispatch, getState) => {\r\n  const blockLimits = await fetchPoolsBlockLimits()\r\n  const totalStakings = await fetchPoolsTotalStaking()\r\n\r\n  const prices = getTokenPricesFromFarm(getState().farms.data)\r\n\r\n  const liveData = poolsConfig.map((pool) => {\r\n    const blockLimit = blockLimits.find((entry) => entry.sousId === pool.sousId)\r\n    const totalStaking = totalStakings.find((entry) => entry.sousId === pool.sousId)\r\n    const isPoolEndBlockExceeded = currentBlock > 0 && blockLimit ? currentBlock > Number(blockLimit.endBlock) : false\r\n    const isPoolFinished = pool.isFinished || isPoolEndBlockExceeded\r\n\r\n    const stakingTokenAddress = pool.stakingToken.address ? getAddress(pool.stakingToken.address).toLowerCase() : null\r\n    const stakingTokenPrice = stakingTokenAddress ? prices[stakingTokenAddress] : 0\r\n\r\n    const earningTokenAddress = pool.earningToken.address ? getAddress(pool.earningToken.address).toLowerCase() : null\r\n    const earningTokenPrice = earningTokenAddress ? prices[earningTokenAddress] : 0\r\n    const apr = !isPoolFinished\r\n      ? getPoolApr(\r\n          stakingTokenPrice,\r\n          earningTokenPrice,\r\n          getBalanceNumber(new BigNumber(totalStaking.totalStaked), pool.stakingToken.decimals),\r\n          parseFloat(pool.tokenPerBlock),\r\n        )\r\n      : 0\r\n\r\n    return {\r\n      ...blockLimit,\r\n      ...totalStaking,\r\n      stakingTokenPrice,\r\n      earningTokenPrice,\r\n      apr,\r\n      isFinished: isPoolFinished,\r\n    }\r\n  })\r\n\r\n  dispatch(setPoolsPublicData(liveData))\r\n}\r\n\r\nexport const fetchPoolsStakingLimitsAsync = () => async (dispatch, getState) => {\r\n  const poolsWithStakingLimit = getState()\r\n    .pools.data.filter(({ stakingLimit }) => stakingLimit !== null && stakingLimit !== undefined)\r\n    .map((pool) => pool.sousId)\r\n\r\n  const stakingLimits = await fetchPoolsStakingLimits(poolsWithStakingLimit)\r\n\r\n  const stakingLimitData = poolsConfig.map((pool) => {\r\n    if (poolsWithStakingLimit.includes(pool.sousId)) {\r\n      return { sousId: pool.sousId }\r\n    }\r\n    const stakingLimit = stakingLimits[pool.sousId] || BIG_ZERO\r\n    return {\r\n      sousId: pool.sousId,\r\n      stakingLimit: stakingLimit.toJSON(),\r\n    }\r\n  })\r\n\r\n  dispatch(setPoolsPublicData(stakingLimitData))\r\n}\r\n\r\nexport const fetchPoolsUserDataAsync =\r\n  (account: string): AppThunk =>\r\n  async (dispatch) => {\r\n    const allowances = await fetchPoolsAllowance(account)\r\n    const stakingTokenBalances = await fetchUserBalances(account)\r\n    const stakedBalances = await fetchUserStakeBalances(account)\r\n    const pendingRewards = await fetchUserPendingRewards(account)\r\n\r\n    const userData = poolsConfig.map((pool) => ({\r\n      sousId: pool.sousId,\r\n      allowance: allowances[pool.sousId],\r\n      stakingTokenBalance: stakingTokenBalances[pool.sousId],\r\n      stakedBalance: stakedBalances[pool.sousId],\r\n      pendingReward: pendingRewards[pool.sousId],\r\n    }))\r\n\r\n    dispatch(setPoolsUserData(userData))\r\n  }\r\n\r\nexport const updateUserAllowance =\r\n  (sousId: number, account: string): AppThunk =>\r\n  async (dispatch) => {\r\n    const allowances = await fetchPoolsAllowance(account)\r\n    dispatch(updatePoolsUserData({ sousId, field: 'allowance', value: allowances[sousId] }))\r\n  }\r\n\r\nexport const updateUserBalance =\r\n  (sousId: number, account: string): AppThunk =>\r\n  async (dispatch) => {\r\n    const tokenBalances = await fetchUserBalances(account)\r\n    dispatch(updatePoolsUserData({ sousId, field: 'stakingTokenBalance', value: tokenBalances[sousId] }))\r\n  }\r\n\r\nexport const updateUserStakedBalance =\r\n  (sousId: number, account: string): AppThunk =>\r\n  async (dispatch) => {\r\n    const stakedBalances = await fetchUserStakeBalances(account)\r\n    dispatch(updatePoolsUserData({ sousId, field: 'stakedBalance', value: stakedBalances[sousId] }))\r\n  }\r\n\r\nexport const updateUserPendingReward =\r\n  (sousId: number, account: string): AppThunk =>\r\n  async (dispatch) => {\r\n    const pendingRewards = await fetchUserPendingRewards(account)\r\n    dispatch(updatePoolsUserData({ sousId, field: 'pendingReward', value: pendingRewards[sousId] }))\r\n  }\r\n\r\nexport const fetchCakeVaultPublicData = createAsyncThunk<CakeVault>('cakeVault/fetchPublicData', async () => {\r\n  const publicVaultInfo = await fetchPublicVaultData()\r\n  return publicVaultInfo\r\n})\r\n\r\nexport const fetchCakeVaultFees = createAsyncThunk<VaultFees>('cakeVault/fetchFees', async () => {\r\n  const vaultFees = await fetchVaultFees()\r\n  return vaultFees\r\n})\r\n\r\nexport const fetchCakeVaultUserData = createAsyncThunk<VaultUser, { account: string }>(\r\n  'cakeVault/fetchUser',\r\n  async ({ account }) => {\r\n    const userData = await fetchVaultUser(account)\r\n    return userData\r\n  },\r\n)\r\n\r\nexport const PoolsSlice = createSlice({\r\n  name: 'Pools',\r\n  initialState,\r\n  reducers: {\r\n    setPoolsPublicData: (state, action) => {\r\n      const livePoolsData: Pool[] = action.payload\r\n      state.data = state.data.map((pool) => {\r\n        const livePoolData = livePoolsData.find((entry) => entry.sousId === pool.sousId)\r\n        return { ...pool, ...livePoolData }\r\n      })\r\n    },\r\n    setPoolsUserData: (state, action) => {\r\n      const userData = action.payload\r\n      state.data = state.data.map((pool) => {\r\n        const userPoolData = userData.find((entry) => entry.sousId === pool.sousId)\r\n        return { ...pool, userData: userPoolData }\r\n      })\r\n      state.userDataLoaded = true\r\n    },\r\n    updatePoolsUserData: (state, action) => {\r\n      const { field, value, sousId } = action.payload\r\n      const index = state.data.findIndex((p) => p.sousId === sousId)\r\n\r\n      if (index >= 0) {\r\n        state.data[index] = { ...state.data[index], userData: { ...state.data[index].userData, [field]: value } }\r\n      }\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    // Vault public data that updates frequently\r\n    builder.addCase(fetchCakeVaultPublicData.fulfilled, (state, action: PayloadAction<CakeVault>) => {\r\n      state.cakeVault = { ...state.cakeVault, ...action.payload }\r\n    })\r\n    // Vault fees\r\n    builder.addCase(fetchCakeVaultFees.fulfilled, (state, action: PayloadAction<VaultFees>) => {\r\n      const fees = action.payload\r\n      state.cakeVault = { ...state.cakeVault, fees }\r\n    })\r\n    // Vault user data\r\n    builder.addCase(fetchCakeVaultUserData.fulfilled, (state, action: PayloadAction<VaultUser>) => {\r\n      const userData = action.payload\r\n      userData.isLoading = false\r\n      state.cakeVault = { ...state.cakeVault, userData }\r\n    })\r\n  },\r\n})\r\n\r\n// Actions\r\nexport const { setPoolsPublicData, setPoolsUserData, updatePoolsUserData } = PoolsSlice.actions\r\n\r\nexport default PoolsSlice.reducer\r\n"]},"metadata":{},"sourceType":"module"}