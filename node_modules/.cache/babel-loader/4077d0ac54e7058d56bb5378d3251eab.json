{"ast":null,"code":"import { format, parseISO, isValid } from 'date-fns';\nimport { MINIMUM_CHOICES } from './Choices';\nexport const combineDateAndTime = (date, time) => {\n  if (!isValid(date) || !isValid(time)) {\n    return null;\n  }\n\n  const dateStr = format(date, 'yyyy-MM-dd');\n  const timeStr = format(time, 'HH:mm:ss');\n  return parseISO(`${dateStr}T${timeStr}`).getTime() / 1e3;\n};\nexport const getFormErrors = (formData, t) => {\n  const {\n    name,\n    body,\n    choices,\n    startDate,\n    startTime,\n    endDate,\n    endTime,\n    snapshot\n  } = formData;\n  const errors = {};\n\n  if (!name) {\n    errors.name = [t('%field% is required', {\n      field: 'Title'\n    })];\n  }\n\n  if (!body) {\n    errors.body = [t('%field% is required', {\n      field: 'Body'\n    })];\n  }\n\n  if (choices.length < MINIMUM_CHOICES) {\n    errors.choices = [t('Please create a minimum of %num% choices', {\n      num: MINIMUM_CHOICES\n    })];\n  }\n\n  const hasEmptyChoice = choices.some(choice => !choice.value);\n\n  if (choices.length === MINIMUM_CHOICES && hasEmptyChoice) {\n    errors.choices = Array.isArray(errors.choices) ? [...errors.choices, t('Choices must not be empty')] : errors.choices = [t('Choices must not be empty')];\n  }\n\n  if (!isValid(startDate)) {\n    errors.startDate = [t('Please select a valid date')];\n  }\n\n  if (!isValid(startTime)) {\n    errors.startTime = [t('Please select a valid time')];\n  }\n\n  if (!isValid(endDate)) {\n    errors.endDate = [t('Please select a valid date')];\n  }\n\n  if (!isValid(endTime)) {\n    errors.endTime = [t('Please select a valid time')];\n  }\n\n  const startDateTimestamp = combineDateAndTime(startDate, startTime);\n  const endDateTimestamp = combineDateAndTime(endDate, endTime);\n\n  if (endDateTimestamp < startDateTimestamp) {\n    errors.endDate = Array.isArray(errors.endDate) ? [...errors.endDate, t('End date must be after the start date')] : errors.endDate = [t('End date must be after the start date')];\n  }\n\n  if (snapshot === 0) {\n    errors.snapshot = [t('Invalid snapshot')];\n  }\n\n  return errors;\n};","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/views/Voting/CreateProposal/helpers.ts"],"names":["format","parseISO","isValid","MINIMUM_CHOICES","combineDateAndTime","date","time","dateStr","timeStr","getTime","getFormErrors","formData","t","name","body","choices","startDate","startTime","endDate","endTime","snapshot","errors","field","length","num","hasEmptyChoice","some","choice","value","Array","isArray","startDateTimestamp","endDateTimestamp"],"mappings":"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","sourcesContent":["import { ContextApi } from 'contexts/Localization/types'\r\nimport { format, parseISO, isValid } from 'date-fns'\r\nimport { MINIMUM_CHOICES } from './Choices'\r\nimport { FormState } from './types'\r\n\r\nexport const combineDateAndTime = (date: Date, time: Date) => {\r\n  if (!isValid(date) || !isValid(time)) {\r\n    return null\r\n  }\r\n\r\n  const dateStr = format(date, 'yyyy-MM-dd')\r\n  const timeStr = format(time, 'HH:mm:ss')\r\n\r\n  return parseISO(`${dateStr}T${timeStr}`).getTime() / 1e3\r\n}\r\n\r\nexport const getFormErrors = (formData: FormState, t: ContextApi['t']) => {\r\n  const { name, body, choices, startDate, startTime, endDate, endTime, snapshot } = formData\r\n  const errors: { [key: string]: string[] } = {}\r\n\r\n  if (!name) {\r\n    errors.name = [t('%field% is required', { field: 'Title' })]\r\n  }\r\n\r\n  if (!body) {\r\n    errors.body = [t('%field% is required', { field: 'Body' })]\r\n  }\r\n\r\n  if (choices.length < MINIMUM_CHOICES) {\r\n    errors.choices = [t('Please create a minimum of %num% choices', { num: MINIMUM_CHOICES })]\r\n  }\r\n\r\n  const hasEmptyChoice = choices.some((choice) => !choice.value)\r\n  if (choices.length === MINIMUM_CHOICES && hasEmptyChoice) {\r\n    errors.choices = Array.isArray(errors.choices)\r\n      ? [...errors.choices, t('Choices must not be empty')]\r\n      : (errors.choices = [t('Choices must not be empty')])\r\n  }\r\n\r\n  if (!isValid(startDate)) {\r\n    errors.startDate = [t('Please select a valid date')]\r\n  }\r\n\r\n  if (!isValid(startTime)) {\r\n    errors.startTime = [t('Please select a valid time')]\r\n  }\r\n\r\n  if (!isValid(endDate)) {\r\n    errors.endDate = [t('Please select a valid date')]\r\n  }\r\n\r\n  if (!isValid(endTime)) {\r\n    errors.endTime = [t('Please select a valid time')]\r\n  }\r\n\r\n  const startDateTimestamp = combineDateAndTime(startDate, startTime)\r\n  const endDateTimestamp = combineDateAndTime(endDate, endTime)\r\n\r\n  if (endDateTimestamp < startDateTimestamp) {\r\n    errors.endDate = Array.isArray(errors.endDate)\r\n      ? [...errors.endDate, t('End date must be after the start date')]\r\n      : (errors.endDate = [t('End date must be after the start date')])\r\n  }\r\n\r\n  if (snapshot === 0) {\r\n    errors.snapshot = [t('Invalid snapshot')]\r\n  }\r\n\r\n  return errors\r\n}\r\n"]},"metadata":{},"sourceType":"module"}