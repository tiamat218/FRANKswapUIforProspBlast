{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { BLOCKS_PER_YEAR, CAKE_PER_YEAR } from 'config';\nimport lpAprs from 'config/constants/lpAprs.json';\n\n/**\r\n * Get the APR value in %\r\n * @param stakingTokenPrice Token price in the same quote currency\r\n * @param rewardTokenPrice Token price in the same quote currency\r\n * @param totalStaked Total amount of stakingToken in the pool\r\n * @param tokenPerBlock Amount of new cake allocated to the pool for each new block\r\n * @returns Null if the APR is NaN or infinite.\r\n */\nexport const getPoolApr = (stakingTokenPrice, rewardTokenPrice, totalStaked, tokenPerBlock) => {\n  const totalRewardPricePerYear = new BigNumber(rewardTokenPrice).times(tokenPerBlock).times(BLOCKS_PER_YEAR);\n  const totalStakingTokenInPool = new BigNumber(stakingTokenPrice).times(totalStaked);\n  const apr = totalRewardPricePerYear.div(totalStakingTokenInPool).times(100);\n  return apr.isNaN() || !apr.isFinite() ? null : apr.toNumber();\n};\n\n/**\r\n * Get farm APR value in %\r\n * @param poolWeight allocationPoint / totalAllocationPoint\r\n * @param cakePriceUsd Cake price in USD\r\n * @param poolLiquidityUsd Total pool liquidity in USD\r\n * @returns\r\n */\nexport const getFarmApr = (poolWeight, cakePriceUsd, poolLiquidityUsd, farmAddress) => {\n  var _lpAprs$farmAddress$t;\n  const yearlyCakeRewardAllocation = CAKE_PER_YEAR.times(poolWeight);\n  const cakeRewardsApr = yearlyCakeRewardAllocation.times(cakePriceUsd).div(poolLiquidityUsd).times(100);\n  let cakeRewardsAprAsNumber = null;\n  if (!cakeRewardsApr.isNaN() && cakeRewardsApr.isFinite()) {\n    cakeRewardsAprAsNumber = cakeRewardsApr.toNumber();\n  }\n  const lpRewardsApr = (_lpAprs$farmAddress$t = lpAprs[farmAddress === null || farmAddress === void 0 ? void 0 : farmAddress.toLocaleLowerCase()]) !== null && _lpAprs$farmAddress$t !== void 0 ? _lpAprs$farmAddress$t : 0;\n  return {\n    cakeRewardsApr: cakeRewardsAprAsNumber,\n    lpRewardsApr\n  };\n};\nexport default null;","map":{"version":3,"names":["BigNumber","BLOCKS_PER_YEAR","CAKE_PER_YEAR","lpAprs","getPoolApr","stakingTokenPrice","rewardTokenPrice","totalStaked","tokenPerBlock","totalRewardPricePerYear","times","totalStakingTokenInPool","apr","div","isNaN","isFinite","toNumber","getFarmApr","poolWeight","cakePriceUsd","poolLiquidityUsd","farmAddress","_lpAprs$farmAddress$t","yearlyCakeRewardAllocation","cakeRewardsApr","cakeRewardsAprAsNumber","lpRewardsApr","toLocaleLowerCase"],"sources":["C:/Users/Devrim/Documents/swapUIforProspBlast/src/utils/apr.ts"],"sourcesContent":["import BigNumber from 'bignumber.js'\r\nimport { BLOCKS_PER_YEAR, CAKE_PER_YEAR } from 'config'\r\nimport lpAprs from 'config/constants/lpAprs.json'\r\n\r\n/**\r\n * Get the APR value in %\r\n * @param stakingTokenPrice Token price in the same quote currency\r\n * @param rewardTokenPrice Token price in the same quote currency\r\n * @param totalStaked Total amount of stakingToken in the pool\r\n * @param tokenPerBlock Amount of new cake allocated to the pool for each new block\r\n * @returns Null if the APR is NaN or infinite.\r\n */\r\nexport const getPoolApr = (\r\n  stakingTokenPrice: number,\r\n  rewardTokenPrice: number,\r\n  totalStaked: number,\r\n  tokenPerBlock: number,\r\n): number => {\r\n  const totalRewardPricePerYear = new BigNumber(rewardTokenPrice).times(tokenPerBlock).times(BLOCKS_PER_YEAR)\r\n  const totalStakingTokenInPool = new BigNumber(stakingTokenPrice).times(totalStaked)\r\n  const apr = totalRewardPricePerYear.div(totalStakingTokenInPool).times(100)\r\n  return apr.isNaN() || !apr.isFinite() ? null : apr.toNumber()\r\n}\r\n\r\n/**\r\n * Get farm APR value in %\r\n * @param poolWeight allocationPoint / totalAllocationPoint\r\n * @param cakePriceUsd Cake price in USD\r\n * @param poolLiquidityUsd Total pool liquidity in USD\r\n * @returns\r\n */\r\nexport const getFarmApr = (\r\n  poolWeight: BigNumber,\r\n  cakePriceUsd: BigNumber,\r\n  poolLiquidityUsd: BigNumber,\r\n  farmAddress: string,\r\n): { cakeRewardsApr: number; lpRewardsApr: number } => {\r\n  const yearlyCakeRewardAllocation = CAKE_PER_YEAR.times(poolWeight)\r\n  const cakeRewardsApr = yearlyCakeRewardAllocation.times(cakePriceUsd).div(poolLiquidityUsd).times(100)\r\n  let cakeRewardsAprAsNumber = null\r\n  if (!cakeRewardsApr.isNaN() && cakeRewardsApr.isFinite()) {\r\n    cakeRewardsAprAsNumber = cakeRewardsApr.toNumber()\r\n  }\r\n  const lpRewardsApr = lpAprs[farmAddress?.toLocaleLowerCase()] ?? 0\r\n  return { cakeRewardsApr: cakeRewardsAprAsNumber, lpRewardsApr }\r\n}\r\n\r\nexport default null\r\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,cAAc;AACpC,SAASC,eAAe,EAAEC,aAAa,QAAQ,QAAQ;AACvD,OAAOC,MAAM,MAAM,8BAA8B;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAGA,CACxBC,iBAAyB,EACzBC,gBAAwB,EACxBC,WAAmB,EACnBC,aAAqB,KACV;EACX,MAAMC,uBAAuB,GAAG,IAAIT,SAAS,CAACM,gBAAgB,CAAC,CAACI,KAAK,CAACF,aAAa,CAAC,CAACE,KAAK,CAACT,eAAe,CAAC;EAC3G,MAAMU,uBAAuB,GAAG,IAAIX,SAAS,CAACK,iBAAiB,CAAC,CAACK,KAAK,CAACH,WAAW,CAAC;EACnF,MAAMK,GAAG,GAAGH,uBAAuB,CAACI,GAAG,CAACF,uBAAuB,CAAC,CAACD,KAAK,CAAC,GAAG,CAAC;EAC3E,OAAOE,GAAG,CAACE,KAAK,CAAC,CAAC,IAAI,CAACF,GAAG,CAACG,QAAQ,CAAC,CAAC,GAAG,IAAI,GAAGH,GAAG,CAACI,QAAQ,CAAC,CAAC;AAC/D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAGA,CACxBC,UAAqB,EACrBC,YAAuB,EACvBC,gBAA2B,EAC3BC,WAAmB,KACkC;EAAA,IAAAC,qBAAA;EACrD,MAAMC,0BAA0B,GAAGrB,aAAa,CAACQ,KAAK,CAACQ,UAAU,CAAC;EAClE,MAAMM,cAAc,GAAGD,0BAA0B,CAACb,KAAK,CAACS,YAAY,CAAC,CAACN,GAAG,CAACO,gBAAgB,CAAC,CAACV,KAAK,CAAC,GAAG,CAAC;EACtG,IAAIe,sBAAsB,GAAG,IAAI;EACjC,IAAI,CAACD,cAAc,CAACV,KAAK,CAAC,CAAC,IAAIU,cAAc,CAACT,QAAQ,CAAC,CAAC,EAAE;IACxDU,sBAAsB,GAAGD,cAAc,CAACR,QAAQ,CAAC,CAAC;EACpD;EACA,MAAMU,YAAY,IAAAJ,qBAAA,GAAGnB,MAAM,CAACkB,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEM,iBAAiB,CAAC,CAAC,CAAC,cAAAL,qBAAA,cAAAA,qBAAA,GAAI,CAAC;EAClE,OAAO;IAAEE,cAAc,EAAEC,sBAAsB;IAAEC;EAAa,CAAC;AACjE,CAAC;AAED,eAAe,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module"}