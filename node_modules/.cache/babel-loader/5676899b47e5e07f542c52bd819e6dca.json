{"ast":null,"code":"import{createAsyncThunk,createSlice}from'@reduxjs/toolkit';import maxBy from'lodash/maxBy';import merge from'lodash/merge';import range from'lodash/range';import{BIG_ZERO}from'utils/bigNumber';import{HistoryFilter,PredictionStatus}from'state/types';import{getPredictionsContract}from'utils/contractHelpers';import{getBetHistory,transformBetResponse,makeFutureRoundResponse,makeRoundData,getRoundsData,getPredictionData,getLedgerData,makeLedgerData,serializePredictionsRoundsResponse,getClaimStatuses}from'./helpers';const PAST_ROUND_COUNT=5;const FUTURE_ROUND_COUNT=2;// The estimated time it takes to broadcast\nexport const BLOCK_PADDING=3;const initialState={status:PredictionStatus.INITIAL,isLoading:false,isHistoryPaneOpen:false,isChartPaneOpen:false,isFetchingHistory:false,historyFilter:HistoryFilter.ALL,currentEpoch:0,currentRoundStartBlockNumber:0,intervalBlocks:100,bufferBlocks:20,minBetAmount:'1000000000000000',rewardRate:97,lastOraclePrice:BIG_ZERO.toJSON(),rounds:{},history:{},ledgers:{},claimableStatuses:{}};// Thunks\n// V2 REFACTOR\nexport const initializePredictions=createAsyncThunk('predictions/intialize',async function(){let account=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;// Static values\nconst marketData=await getPredictionData();const epochs=range(marketData.currentEpoch,marketData.currentEpoch-PAST_ROUND_COUNT);// Round data\nconst roundsResponse=await getRoundsData(epochs);const initialRoundData=roundsResponse.reduce((accum,roundResponse)=>{const reduxNodeRound=serializePredictionsRoundsResponse(roundResponse);return{...accum,[reduxNodeRound.epoch.toString()]:reduxNodeRound};},{});const initializedData={...marketData,rounds:initialRoundData,ledgers:{},claimableStatuses:{}};if(!account){return initializedData;}// Bet data\nconst ledgerResponses=await getLedgerData(account,epochs);// Claim statuses\nconst claimableStatuses=await getClaimStatuses(account,epochs);return merge({},initializedData,{ledgers:makeLedgerData(account,ledgerResponses,epochs),claimableStatuses});});export const fetchRound=createAsyncThunk('predictions/fetchRound',async epoch=>{const predictionContract=getPredictionsContract();const response=await predictionContract.rounds(epoch);return serializePredictionsRoundsResponse(response);});export const fetchRounds=createAsyncThunk('predictions/fetchRounds',async epochs=>{const rounds=await getRoundsData(epochs);return rounds.reduce((accum,round)=>{if(!round){return accum;}const reduxNodeRound=serializePredictionsRoundsResponse(round);return{...accum,[reduxNodeRound.epoch.toString()]:reduxNodeRound};},{});});export const fetchMarketData=createAsyncThunk('predictions/fetchMarketData',async()=>{const marketData=await getPredictionData();return marketData;});export const fetchLedgerData=createAsyncThunk('predictions/fetchLedgerData',async _ref=>{let{account,epochs}=_ref;const ledgers=await getLedgerData(account,epochs);return makeLedgerData(account,ledgers,epochs);});export const fetchClaimableStatuses=createAsyncThunk('predictions/fetchClaimableStatuses',async _ref2=>{let{account,epochs}=_ref2;const ledgers=await getClaimStatuses(account,epochs);return ledgers;});// END V2 REFACTOR\nexport const fetchHistory=createAsyncThunk('predictions/fetchHistory',async _ref3=>{let{account,claimed}=_ref3;const response=await getBetHistory({user:account.toLowerCase(),claimed});const bets=response.map(transformBetResponse);return{account,bets};});export const predictionsSlice=createSlice({name:'predictions',initialState,reducers:{setPredictionStatus:(state,action)=>{state.status=action.payload;},setHistoryPaneState:(state,action)=>{state.isHistoryPaneOpen=action.payload;state.historyFilter=HistoryFilter.ALL;},setChartPaneState:(state,action)=>{state.isChartPaneOpen=action.payload;},setHistoryFilter:(state,action)=>{state.historyFilter=action.payload;},setCurrentEpoch:(state,action)=>{state.currentEpoch=action.payload;},setLastOraclePrice:(state,action)=>{state.lastOraclePrice=action.payload;},markBetHistoryAsCollected:(state,action)=>{const{account,betId}=action.payload;if(state.history[account]){const betIndex=state.history[account].findIndex(bet=>bet.id===betId);if(betIndex>=0){state.history[account][betIndex].claimed=true;}}}},extraReducers:builder=>{// Claimable statuses\nbuilder.addCase(fetchClaimableStatuses.fulfilled,(state,action)=>{state.claimableStatuses=merge({},state.claimableStatuses,action.payload);});// Ledger (bet) records\nbuilder.addCase(fetchLedgerData.fulfilled,(state,action)=>{state.ledgers=merge({},state.ledgers,action.payload);});// Get static market data\nbuilder.addCase(fetchMarketData.fulfilled,(state,action)=>{const{status,currentEpoch,intervalBlocks,bufferBlocks,minBetAmount,rewardRate}=action.payload;// If the round has change add a new future round\nif(state.currentEpoch!==currentEpoch){const newestRound=maxBy(Object.values(state.rounds),'epoch');const futureRound=makeFutureRoundResponse(newestRound.epoch+1,newestRound.startBlock+(state.intervalBlocks+BLOCK_PADDING));state.rounds[futureRound.epoch]=futureRound;state.currentRoundStartBlockNumber=state.currentRoundStartBlockNumber+state.intervalBlocks+BLOCK_PADDING;}state.status=status;state.currentEpoch=currentEpoch;state.intervalBlocks=intervalBlocks;state.bufferBlocks=bufferBlocks;state.minBetAmount=minBetAmount;state.rewardRate=rewardRate;});// Initialize predictions\nbuilder.addCase(initializePredictions.fulfilled,(state,action)=>{const{status,currentEpoch,bufferBlocks,intervalBlocks,rounds,claimableStatuses,rewardRate,ledgers}=action.payload;const currentRoundStartBlockNumber=action.payload.rounds[currentEpoch].startBlock;const futureRounds=[];for(let i=1;i<=FUTURE_ROUND_COUNT;i++){futureRounds.push(makeFutureRoundResponse(currentEpoch+i,currentRoundStartBlockNumber+(intervalBlocks+BLOCK_PADDING)*i));}return{...state,status,currentEpoch,bufferBlocks,intervalBlocks,rewardRate,currentRoundStartBlockNumber,claimableStatuses,ledgers,rounds:merge({},rounds,makeRoundData(futureRounds))};});// Get single round\nbuilder.addCase(fetchRound.fulfilled,(state,action)=>{state.rounds=merge({},state.rounds,{[action.payload.epoch.toString()]:action.payload});});// Get multiple rounds\nbuilder.addCase(fetchRounds.fulfilled,(state,action)=>{state.rounds=merge({},state.rounds,action.payload);});// Show History\nbuilder.addCase(fetchHistory.pending,state=>{state.isFetchingHistory=true;});builder.addCase(fetchHistory.rejected,state=>{state.isFetchingHistory=false;});builder.addCase(fetchHistory.fulfilled,(state,action)=>{const{account,bets}=action.payload;state.isFetchingHistory=false;state.history[account]=bets;});}});// Actions\nexport const{setChartPaneState,setCurrentEpoch,setHistoryFilter,setHistoryPaneState,setPredictionStatus,setLastOraclePrice,markBetHistoryAsCollected}=predictionsSlice.actions;export default predictionsSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","maxBy","merge","range","BIG_ZERO","HistoryFilter","PredictionStatus","getPredictionsContract","getBetHistory","transformBetResponse","makeFutureRoundResponse","makeRoundData","getRoundsData","getPredictionData","getLedgerData","makeLedgerData","serializePredictionsRoundsResponse","getClaimStatuses","PAST_ROUND_COUNT","FUTURE_ROUND_COUNT","BLOCK_PADDING","initialState","status","INITIAL","isLoading","isHistoryPaneOpen","isChartPaneOpen","isFetchingHistory","historyFilter","ALL","currentEpoch","currentRoundStartBlockNumber","intervalBlocks","bufferBlocks","minBetAmount","rewardRate","lastOraclePrice","toJSON","rounds","history","ledgers","claimableStatuses","initializePredictions","account","arguments","length","undefined","marketData","epochs","roundsResponse","initialRoundData","reduce","accum","roundResponse","reduxNodeRound","epoch","toString","initializedData","ledgerResponses","fetchRound","predictionContract","response","fetchRounds","round","fetchMarketData","fetchLedgerData","_ref","fetchClaimableStatuses","_ref2","fetchHistory","_ref3","claimed","user","toLowerCase","bets","map","predictionsSlice","name","reducers","setPredictionStatus","state","action","payload","setHistoryPaneState","setChartPaneState","setHistoryFilter","setCurrentEpoch","setLastOraclePrice","markBetHistoryAsCollected","betId","betIndex","findIndex","bet","id","extraReducers","builder","addCase","fulfilled","newestRound","Object","values","futureRound","startBlock","futureRounds","i","push","pending","rejected","actions","reducer"],"sources":["C:/Users/frkul/Documents/swapUI_pancake-frontend/src/state/predictions/index.ts"],"sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\r\nimport maxBy from 'lodash/maxBy'\r\nimport merge from 'lodash/merge'\r\nimport range from 'lodash/range'\r\nimport { BIG_ZERO } from 'utils/bigNumber'\r\nimport { Bet, LedgerData, HistoryFilter, PredictionsState, PredictionStatus, ReduxNodeRound } from 'state/types'\r\nimport { getPredictionsContract } from 'utils/contractHelpers'\r\nimport {\r\n  getBetHistory,\r\n  transformBetResponse,\r\n  makeFutureRoundResponse,\r\n  makeRoundData,\r\n  getRoundsData,\r\n  getPredictionData,\r\n  MarketData,\r\n  getLedgerData,\r\n  makeLedgerData,\r\n  serializePredictionsRoundsResponse,\r\n  getClaimStatuses,\r\n} from './helpers'\r\n\r\nconst PAST_ROUND_COUNT = 5\r\nconst FUTURE_ROUND_COUNT = 2\r\n\r\n// The estimated time it takes to broadcast\r\nexport const BLOCK_PADDING = 3\r\n\r\nconst initialState: PredictionsState = {\r\n  status: PredictionStatus.INITIAL,\r\n  isLoading: false,\r\n  isHistoryPaneOpen: false,\r\n  isChartPaneOpen: false,\r\n  isFetchingHistory: false,\r\n  historyFilter: HistoryFilter.ALL,\r\n  currentEpoch: 0,\r\n  currentRoundStartBlockNumber: 0,\r\n  intervalBlocks: 100,\r\n  bufferBlocks: 20,\r\n  minBetAmount: '1000000000000000',\r\n  rewardRate: 97,\r\n  lastOraclePrice: BIG_ZERO.toJSON(),\r\n  rounds: {},\r\n  history: {},\r\n  ledgers: {},\r\n  claimableStatuses: {},\r\n}\r\n\r\n// Thunks\r\n// V2 REFACTOR\r\ntype PredictionInitialization = Pick<\r\n  PredictionsState,\r\n  | 'status'\r\n  | 'currentEpoch'\r\n  | 'intervalBlocks'\r\n  | 'bufferBlocks'\r\n  | 'minBetAmount'\r\n  | 'rewardRate'\r\n  | 'rounds'\r\n  | 'ledgers'\r\n  | 'claimableStatuses'\r\n>\r\nexport const initializePredictions = createAsyncThunk<PredictionInitialization, string>(\r\n  'predictions/intialize',\r\n  async (account = null) => {\r\n    // Static values\r\n    const marketData = await getPredictionData()\r\n    const epochs = range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT)\r\n\r\n    // Round data\r\n    const roundsResponse = await getRoundsData(epochs)\r\n    const initialRoundData: { [key: string]: ReduxNodeRound } = roundsResponse.reduce((accum, roundResponse) => {\r\n      const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse)\r\n\r\n      return {\r\n        ...accum,\r\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\r\n      }\r\n    }, {})\r\n\r\n    const initializedData = {\r\n      ...marketData,\r\n      rounds: initialRoundData,\r\n      ledgers: {},\r\n      claimableStatuses: {},\r\n    }\r\n\r\n    if (!account) {\r\n      return initializedData\r\n    }\r\n\r\n    // Bet data\r\n    const ledgerResponses = await getLedgerData(account, epochs)\r\n\r\n    // Claim statuses\r\n    const claimableStatuses = await getClaimStatuses(account, epochs)\r\n\r\n    return merge({}, initializedData, {\r\n      ledgers: makeLedgerData(account, ledgerResponses, epochs),\r\n      claimableStatuses,\r\n    })\r\n  },\r\n)\r\n\r\nexport const fetchRound = createAsyncThunk<ReduxNodeRound, number>('predictions/fetchRound', async (epoch) => {\r\n  const predictionContract = getPredictionsContract()\r\n  const response = await predictionContract.rounds(epoch)\r\n  return serializePredictionsRoundsResponse(response)\r\n})\r\n\r\nexport const fetchRounds = createAsyncThunk<{ [key: string]: ReduxNodeRound }, number[]>(\r\n  'predictions/fetchRounds',\r\n  async (epochs) => {\r\n    const rounds = await getRoundsData(epochs)\r\n    return rounds.reduce((accum, round) => {\r\n      if (!round) {\r\n        return accum\r\n      }\r\n\r\n      const reduxNodeRound = serializePredictionsRoundsResponse(round)\r\n\r\n      return {\r\n        ...accum,\r\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\r\n      }\r\n    }, {})\r\n  },\r\n)\r\n\r\nexport const fetchMarketData = createAsyncThunk<MarketData>('predictions/fetchMarketData', async () => {\r\n  const marketData = await getPredictionData()\r\n  return marketData\r\n})\r\n\r\nexport const fetchLedgerData = createAsyncThunk<LedgerData, { account: string; epochs: number[] }>(\r\n  'predictions/fetchLedgerData',\r\n  async ({ account, epochs }) => {\r\n    const ledgers = await getLedgerData(account, epochs)\r\n    return makeLedgerData(account, ledgers, epochs)\r\n  },\r\n)\r\n\r\nexport const fetchClaimableStatuses = createAsyncThunk<\r\n  PredictionsState['claimableStatuses'],\r\n  { account: string; epochs: number[] }\r\n>('predictions/fetchClaimableStatuses', async ({ account, epochs }) => {\r\n  const ledgers = await getClaimStatuses(account, epochs)\r\n  return ledgers\r\n})\r\n// END V2 REFACTOR\r\n\r\nexport const fetchHistory = createAsyncThunk<{ account: string; bets: Bet[] }, { account: string; claimed?: boolean }>(\r\n  'predictions/fetchHistory',\r\n  async ({ account, claimed }) => {\r\n    const response = await getBetHistory({\r\n      user: account.toLowerCase(),\r\n      claimed,\r\n    })\r\n    const bets = response.map(transformBetResponse)\r\n\r\n    return { account, bets }\r\n  },\r\n)\r\n\r\nexport const predictionsSlice = createSlice({\r\n  name: 'predictions',\r\n  initialState,\r\n  reducers: {\r\n    setPredictionStatus: (state, action: PayloadAction<PredictionStatus>) => {\r\n      state.status = action.payload\r\n    },\r\n    setHistoryPaneState: (state, action: PayloadAction<boolean>) => {\r\n      state.isHistoryPaneOpen = action.payload\r\n      state.historyFilter = HistoryFilter.ALL\r\n    },\r\n    setChartPaneState: (state, action: PayloadAction<boolean>) => {\r\n      state.isChartPaneOpen = action.payload\r\n    },\r\n    setHistoryFilter: (state, action: PayloadAction<HistoryFilter>) => {\r\n      state.historyFilter = action.payload\r\n    },\r\n    setCurrentEpoch: (state, action: PayloadAction<number>) => {\r\n      state.currentEpoch = action.payload\r\n    },\r\n    setLastOraclePrice: (state, action: PayloadAction<string>) => {\r\n      state.lastOraclePrice = action.payload\r\n    },\r\n    markBetHistoryAsCollected: (state, action: PayloadAction<{ account: string; betId: string }>) => {\r\n      const { account, betId } = action.payload\r\n\r\n      if (state.history[account]) {\r\n        const betIndex = state.history[account].findIndex((bet) => bet.id === betId)\r\n\r\n        if (betIndex >= 0) {\r\n          state.history[account][betIndex].claimed = true\r\n        }\r\n      }\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    // Claimable statuses\r\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\r\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload)\r\n    })\r\n\r\n    // Ledger (bet) records\r\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\r\n      state.ledgers = merge({}, state.ledgers, action.payload)\r\n    })\r\n\r\n    // Get static market data\r\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\r\n      const { status, currentEpoch, intervalBlocks, bufferBlocks, minBetAmount, rewardRate } = action.payload\r\n\r\n      // If the round has change add a new future round\r\n      if (state.currentEpoch !== currentEpoch) {\r\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch')\r\n        const futureRound = makeFutureRoundResponse(\r\n          newestRound.epoch + 1,\r\n          newestRound.startBlock + (state.intervalBlocks + BLOCK_PADDING),\r\n        )\r\n\r\n        state.rounds[futureRound.epoch] = futureRound\r\n        state.currentRoundStartBlockNumber = state.currentRoundStartBlockNumber + state.intervalBlocks + BLOCK_PADDING\r\n      }\r\n\r\n      state.status = status\r\n      state.currentEpoch = currentEpoch\r\n      state.intervalBlocks = intervalBlocks\r\n      state.bufferBlocks = bufferBlocks\r\n      state.minBetAmount = minBetAmount\r\n      state.rewardRate = rewardRate\r\n    })\r\n\r\n    // Initialize predictions\r\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\r\n      const { status, currentEpoch, bufferBlocks, intervalBlocks, rounds, claimableStatuses, rewardRate, ledgers } =\r\n        action.payload\r\n      const currentRoundStartBlockNumber = action.payload.rounds[currentEpoch].startBlock\r\n      const futureRounds: ReduxNodeRound[] = []\r\n\r\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\r\n        futureRounds.push(\r\n          makeFutureRoundResponse(\r\n            currentEpoch + i,\r\n            currentRoundStartBlockNumber + (intervalBlocks + BLOCK_PADDING) * i,\r\n          ),\r\n        )\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        status,\r\n        currentEpoch,\r\n        bufferBlocks,\r\n        intervalBlocks,\r\n        rewardRate,\r\n        currentRoundStartBlockNumber,\r\n        claimableStatuses,\r\n        ledgers,\r\n        rounds: merge({}, rounds, makeRoundData(futureRounds)),\r\n      }\r\n    })\r\n\r\n    // Get single round\r\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\r\n      state.rounds = merge({}, state.rounds, {\r\n        [action.payload.epoch.toString()]: action.payload,\r\n      })\r\n    })\r\n\r\n    // Get multiple rounds\r\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\r\n      state.rounds = merge({}, state.rounds, action.payload)\r\n    })\r\n\r\n    // Show History\r\n    builder.addCase(fetchHistory.pending, (state) => {\r\n      state.isFetchingHistory = true\r\n    })\r\n    builder.addCase(fetchHistory.rejected, (state) => {\r\n      state.isFetchingHistory = false\r\n    })\r\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\r\n      const { account, bets } = action.payload\r\n\r\n      state.isFetchingHistory = false\r\n      state.history[account] = bets\r\n    })\r\n  },\r\n})\r\n\r\n// Actions\r\nexport const {\r\n  setChartPaneState,\r\n  setCurrentEpoch,\r\n  setHistoryFilter,\r\n  setHistoryPaneState,\r\n  setPredictionStatus,\r\n  setLastOraclePrice,\r\n  markBetHistoryAsCollected,\r\n} = predictionsSlice.actions\r\n\r\nexport default predictionsSlice.reducer\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}