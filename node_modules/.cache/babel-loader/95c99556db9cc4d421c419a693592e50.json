{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\n/* eslint-disable no-param-reassign */\nimport { isTradeBetter } from 'utils/trades';\nimport { Trade } from '@pancakeswap/sdk';\nimport flatMap from 'lodash/flatMap';\nimport { useMemo } from 'react';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { useUserSingleHopOnly } from 'state/user/hooks';\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES, BETTER_TRADE_LESS_HOPS_THRESHOLD, ADDITIONAL_BASES } from '../config/constants';\nimport { PairState, usePairs } from './usePairs';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useUnsupportedTokens } from './Tokens';\n\nfunction useAllCommonPairs(currencyA, currencyB) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const [tokenA, tokenB] = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined];\n  const bases = useMemo(() => {\n    var _BASES_TO_CHECK_TRADE, _ADDITIONAL_BASES$cha, _ADDITIONAL_BASES$cha2, _ADDITIONAL_BASES$cha3, _ADDITIONAL_BASES$cha4;\n\n    if (!chainId) return [];\n    const common = (_BASES_TO_CHECK_TRADE = BASES_TO_CHECK_TRADES_AGAINST[chainId]) !== null && _BASES_TO_CHECK_TRADE !== void 0 ? _BASES_TO_CHECK_TRADE : [];\n    const additionalA = tokenA ? (_ADDITIONAL_BASES$cha = (_ADDITIONAL_BASES$cha2 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha2 === void 0 ? void 0 : _ADDITIONAL_BASES$cha2[tokenA.address]) !== null && _ADDITIONAL_BASES$cha !== void 0 ? _ADDITIONAL_BASES$cha : [] : [];\n    const additionalB = tokenB ? (_ADDITIONAL_BASES$cha3 = (_ADDITIONAL_BASES$cha4 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha4 === void 0 ? void 0 : _ADDITIONAL_BASES$cha4[tokenB.address]) !== null && _ADDITIONAL_BASES$cha3 !== void 0 ? _ADDITIONAL_BASES$cha3 : [] : [];\n    return [...common, ...additionalA, ...additionalB];\n  }, [chainId, tokenA, tokenB]);\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])), [bases]);\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [// the direct pair\n  [tokenA, tokenB], // token A against all bases\n  ...bases.map(base => [tokenA, base]), // token B against all bases\n  ...bases.map(base => [tokenB, base]), // each base against all bases\n  ...basePairs].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(([t0, t1]) => t0.address !== t1.address).filter(([tokenA_, tokenB_]) => {\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    const customBasesA = customBases === null || customBases === void 0 ? void 0 : customBases[tokenA_.address];\n    const customBasesB = customBases === null || customBases === void 0 ? void 0 : customBases[tokenB_.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && !customBasesA.find(base => tokenB_.equals(base))) return false;\n    if (customBasesB && !customBasesB.find(base => tokenA_.equals(base))) return false;\n    return true;\n  }) : [], [tokenA, tokenB, bases, basePairs, chainId]);\n  const allPairs = usePairs(allPairCombinations); // only pass along valid pairs, non-duplicated pairs\n\n  return useMemo(() => Object.values(allPairs // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1])) // filter out duplicated pairs\n  .reduce((memo, [, curr]) => {\n    var _memo$curr$liquidityT;\n\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n\n_s(useAllCommonPairs, \"yOlOGLSe6CG5zU7a8alITxmtf8s=\", false, function () {\n  return [useActiveWeb3React, usePairs];\n});\n\nconst MAX_HOPS = 3;\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\n\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  _s2();\n\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact;\n\n        return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact2;\n\n        const currentTrade = (_Trade$bestTradeExact2 = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null; // if current trade is best yet, save it\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\n\n_s2(useTradeExactIn, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});\n\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  _s3();\n\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact3;\n\n        return (_Trade$bestTradeExact3 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact3 !== void 0 ? _Trade$bestTradeExact3 : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact4;\n\n        const currentTrade = (_Trade$bestTradeExact4 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact4 !== void 0 ? _Trade$bestTradeExact4 : null;\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}\n\n_s3(useTradeExactOut, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});\n\nexport function useIsTransactionUnsupported(currencyIn, currencyOut) {\n  _s4();\n\n  const unsupportedTokens = useUnsupportedTokens();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokenIn = wrappedCurrency(currencyIn, chainId);\n  const tokenOut = wrappedCurrency(currencyOut, chainId); // if unsupported list loaded & either token on list, mark as unsupported\n\n  if (unsupportedTokens) {\n    if (tokenIn && Object.keys(unsupportedTokens).includes(tokenIn.address)) {\n      return true;\n    }\n\n    if (tokenOut && Object.keys(unsupportedTokens).includes(tokenOut.address)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n_s4(useIsTransactionUnsupported, \"mh+vbeh73y5JIEumpyTy9rh8i2g=\", false, function () {\n  return [useUnsupportedTokens, useActiveWeb3React];\n});","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/hooks/Trades.ts"],"names":["isTradeBetter","Trade","flatMap","useMemo","useActiveWeb3React","useUserSingleHopOnly","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","BETTER_TRADE_LESS_HOPS_THRESHOLD","ADDITIONAL_BASES","PairState","usePairs","wrappedCurrency","useUnsupportedTokens","useAllCommonPairs","currencyA","currencyB","chainId","tokenA","tokenB","undefined","bases","common","additionalA","address","additionalB","basePairs","base","map","otherBase","allPairCombinations","filter","tokens","Boolean","t0","t1","tokenA_","tokenB_","customBases","customBasesA","customBasesB","find","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","MAX_HOPS","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","singleHopOnly","length","bestTradeExactIn","maxHops","maxNumResults","bestTradeSoFar","i","currentTrade","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut","useIsTransactionUnsupported","unsupportedTokens","tokenIn","tokenOut","keys","includes"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\r\nimport { isTradeBetter } from 'utils/trades'\r\nimport { Currency, CurrencyAmount, Pair, Token, Trade } from '@pancakeswap/sdk'\r\nimport flatMap from 'lodash/flatMap'\r\nimport { useMemo } from 'react'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\n\r\nimport { useUserSingleHopOnly } from 'state/user/hooks'\r\nimport {\r\n  BASES_TO_CHECK_TRADES_AGAINST,\r\n  CUSTOM_BASES,\r\n  BETTER_TRADE_LESS_HOPS_THRESHOLD,\r\n  ADDITIONAL_BASES,\r\n} from '../config/constants'\r\nimport { PairState, usePairs } from './usePairs'\r\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\r\n\r\nimport { useUnsupportedTokens } from './Tokens'\r\n\r\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\r\n  const { chainId } = useActiveWeb3React()\r\n\r\n  const [tokenA, tokenB] = chainId\r\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\r\n    : [undefined, undefined]\r\n\r\n  const bases: Token[] = useMemo(() => {\r\n    if (!chainId) return []\r\n\r\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\r\n    const additionalA = tokenA ? ADDITIONAL_BASES[chainId]?.[tokenA.address] ?? [] : []\r\n    const additionalB = tokenB ? ADDITIONAL_BASES[chainId]?.[tokenB.address] ?? [] : []\r\n\r\n    return [...common, ...additionalA, ...additionalB]\r\n  }, [chainId, tokenA, tokenB])\r\n\r\n  const basePairs: [Token, Token][] = useMemo(\r\n    () => flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])),\r\n    [bases],\r\n  )\r\n\r\n  const allPairCombinations: [Token, Token][] = useMemo(\r\n    () =>\r\n      tokenA && tokenB\r\n        ? [\r\n            // the direct pair\r\n            [tokenA, tokenB],\r\n            // token A against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\r\n            // token B against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\r\n            // each base against all bases\r\n            ...basePairs,\r\n          ]\r\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\r\n            .filter(([t0, t1]) => t0.address !== t1.address)\r\n            .filter(([tokenA_, tokenB_]) => {\r\n              if (!chainId) return true\r\n              const customBases = CUSTOM_BASES[chainId]\r\n\r\n              const customBasesA: Token[] | undefined = customBases?.[tokenA_.address]\r\n              const customBasesB: Token[] | undefined = customBases?.[tokenB_.address]\r\n\r\n              if (!customBasesA && !customBasesB) return true\r\n\r\n              if (customBasesA && !customBasesA.find((base) => tokenB_.equals(base))) return false\r\n              if (customBasesB && !customBasesB.find((base) => tokenA_.equals(base))) return false\r\n\r\n              return true\r\n            })\r\n        : [],\r\n    [tokenA, tokenB, bases, basePairs, chainId],\r\n  )\r\n\r\n  const allPairs = usePairs(allPairCombinations)\r\n\r\n  // only pass along valid pairs, non-duplicated pairs\r\n  return useMemo(\r\n    () =>\r\n      Object.values(\r\n        allPairs\r\n          // filter out invalid pairs\r\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\r\n          // filter out duplicated pairs\r\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\r\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\r\n            return memo\r\n          }, {}),\r\n      ),\r\n    [allPairs],\r\n  )\r\n}\r\n\r\nconst MAX_HOPS = 3\r\n\r\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\r\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\r\n\r\n  const [singleHopOnly] = useUserSingleHopOnly()\r\n\r\n  return useMemo(() => {\r\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\r\n      if (singleHopOnly) {\r\n        return (\r\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\r\n          null\r\n        )\r\n      }\r\n      // search through trades with varying hops, find best trade out of them\r\n      let bestTradeSoFar: Trade | null = null\r\n      for (let i = 1; i <= MAX_HOPS; i++) {\r\n        const currentTrade: Trade | null =\r\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\r\n          null\r\n        // if current trade is best yet, save it\r\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\r\n          bestTradeSoFar = currentTrade\r\n        }\r\n      }\r\n      return bestTradeSoFar\r\n    }\r\n\r\n    return null\r\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly])\r\n}\r\n\r\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\r\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\r\n\r\n  const [singleHopOnly] = useUserSingleHopOnly()\r\n\r\n  return useMemo(() => {\r\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\r\n      if (singleHopOnly) {\r\n        return (\r\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\r\n          null\r\n        )\r\n      }\r\n      // search through trades with varying hops, find best trade out of them\r\n      let bestTradeSoFar: Trade | null = null\r\n      for (let i = 1; i <= MAX_HOPS; i++) {\r\n        const currentTrade =\r\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\r\n          null\r\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\r\n          bestTradeSoFar = currentTrade\r\n        }\r\n      }\r\n      return bestTradeSoFar\r\n    }\r\n    return null\r\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly])\r\n}\r\n\r\nexport function useIsTransactionUnsupported(currencyIn?: Currency, currencyOut?: Currency): boolean {\r\n  const unsupportedTokens: { [address: string]: Token } = useUnsupportedTokens()\r\n  const { chainId } = useActiveWeb3React()\r\n\r\n  const tokenIn = wrappedCurrency(currencyIn, chainId)\r\n  const tokenOut = wrappedCurrency(currencyOut, chainId)\r\n\r\n  // if unsupported list loaded & either token on list, mark as unsupported\r\n  if (unsupportedTokens) {\r\n    if (tokenIn && Object.keys(unsupportedTokens).includes(tokenIn.address)) {\r\n      return true\r\n    }\r\n    if (tokenOut && Object.keys(unsupportedTokens).includes(tokenOut.address)) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n"]},"metadata":{},"sourceType":"module"}