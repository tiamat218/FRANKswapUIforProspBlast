{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { namehash } from 'ethers/lib/utils';\nimport { useMemo } from 'react';\nimport { useSingleCallResult } from '../../state/multicall/hooks';\nimport { isAddress } from '../../utils';\nimport isZero from '../../utils/isZero';\nimport { useENSRegistrarContract, useENSResolverContract } from '../useContract';\nimport useDebounce from '../useDebounce';\n/**\r\n * Does a reverse lookup for an address to find its ENS name.\r\n * Note this is not the same as looking up an ENS name to find an address.\r\n */\n\nexport default function useENSName(address) {\n  _s();\n\n  var _resolverAddress$resu, _name$result$, _name$result;\n\n  const debouncedAddress = useDebounce(address, 200);\n  const ensNodeArgument = useMemo(() => {\n    if (!debouncedAddress || !isAddress(debouncedAddress)) return [undefined];\n\n    try {\n      return [namehash(`${debouncedAddress.toLowerCase().substr(2)}.addr.reverse`)];\n    } catch (error) {\n      console.error('Invalid address for ENS name lookup:', error);\n      return [undefined];\n    }\n  }, [debouncedAddress]);\n  const registrarContract = useENSRegistrarContract(false);\n  const resolverAddress = useSingleCallResult(registrarContract, 'resolver', ensNodeArgument);\n  const resolverAddressResult = (_resolverAddress$resu = resolverAddress.result) === null || _resolverAddress$resu === void 0 ? void 0 : _resolverAddress$resu[0];\n  const resolverContract = useENSResolverContract(resolverAddressResult || undefined, false);\n  const name = useSingleCallResult(resolverContract, 'name', ensNodeArgument);\n  const isResolverAddressValid = resolverAddressResult && !isZero(resolverAddressResult);\n  return {\n    ENSName: isResolverAddressValid ? (_name$result$ = (_name$result = name.result) === null || _name$result === void 0 ? void 0 : _name$result[0]) !== null && _name$result$ !== void 0 ? _name$result$ : null : null,\n    loading: resolverAddress.loading || name.loading\n  };\n}\n\n_s(useENSName, \"8g3MyTb9JnGx6yiMJXxKZlnslKc=\", false, function () {\n  return [useDebounce, useENSRegistrarContract, useSingleCallResult, useENSResolverContract, useSingleCallResult];\n});","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/hooks/ENS/useENSName.ts"],"names":["namehash","useMemo","useSingleCallResult","isAddress","isZero","useENSRegistrarContract","useENSResolverContract","useDebounce","useENSName","address","debouncedAddress","ensNodeArgument","undefined","toLowerCase","substr","error","console","registrarContract","resolverAddress","resolverAddressResult","result","resolverContract","name","isResolverAddressValid","ENSName","loading"],"mappings":";;AAAA,SAASA,QAAT,QAAyB,kBAAzB;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,mBAAT,QAAoC,6BAApC;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,OAAOC,MAAP,MAAmB,oBAAnB;AACA,SAASC,uBAAT,EAAkCC,sBAAlC,QAAgE,gBAAhE;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AAEA;AACA;AACA;AACA;;AACA,eAAe,SAASC,UAAT,CAAoBC,OAApB,EAAoF;AAAA;;AAAA;;AACjG,QAAMC,gBAAgB,GAAGH,WAAW,CAACE,OAAD,EAAU,GAAV,CAApC;AACA,QAAME,eAAe,GAAGV,OAAO,CAAC,MAAM;AACpC,QAAI,CAACS,gBAAD,IAAqB,CAACP,SAAS,CAACO,gBAAD,CAAnC,EAAuD,OAAO,CAACE,SAAD,CAAP;;AACvD,QAAI;AACF,aAAO,CAACZ,QAAQ,CAAE,GAAEU,gBAAgB,CAACG,WAAjB,GAA+BC,MAA/B,CAAsC,CAAtC,CAAyC,eAA7C,CAAT,CAAP;AACD,KAFD,CAEE,OAAOC,KAAP,EAAc;AACdC,MAAAA,OAAO,CAACD,KAAR,CAAc,sCAAd,EAAsDA,KAAtD;AACA,aAAO,CAACH,SAAD,CAAP;AACD;AACF,GAR8B,EAQ5B,CAACF,gBAAD,CAR4B,CAA/B;AAUA,QAAMO,iBAAiB,GAAGZ,uBAAuB,CAAC,KAAD,CAAjD;AACA,QAAMa,eAAe,GAAGhB,mBAAmB,CAACe,iBAAD,EAAoB,UAApB,EAAgCN,eAAhC,CAA3C;AACA,QAAMQ,qBAAqB,4BAAGD,eAAe,CAACE,MAAnB,0DAAG,sBAAyB,CAAzB,CAA9B;AAEA,QAAMC,gBAAgB,GAAGf,sBAAsB,CAACa,qBAAqB,IAAIP,SAA1B,EAAqC,KAArC,CAA/C;AACA,QAAMU,IAAI,GAAGpB,mBAAmB,CAACmB,gBAAD,EAAmB,MAAnB,EAA2BV,eAA3B,CAAhC;AAEA,QAAMY,sBAAsB,GAAGJ,qBAAqB,IAAI,CAACf,MAAM,CAACe,qBAAD,CAA/D;AAEA,SAAO;AACLK,IAAAA,OAAO,EAAED,sBAAsB,oCAAGD,IAAI,CAACF,MAAR,iDAAG,aAAc,CAAd,CAAH,yDAAuB,IAAvB,GAA8B,IADxD;AAELK,IAAAA,OAAO,EAAEP,eAAe,CAACO,OAAhB,IAA2BH,IAAI,CAACG;AAFpC,GAAP;AAID;;GAzBuBjB,U;UACGD,W,EAWCF,uB,EACFH,mB,EAGCI,sB,EACZJ,mB","sourcesContent":["import { namehash } from 'ethers/lib/utils'\r\nimport { useMemo } from 'react'\r\nimport { useSingleCallResult } from '../../state/multicall/hooks'\r\nimport { isAddress } from '../../utils'\r\nimport isZero from '../../utils/isZero'\r\nimport { useENSRegistrarContract, useENSResolverContract } from '../useContract'\r\nimport useDebounce from '../useDebounce'\r\n\r\n/**\r\n * Does a reverse lookup for an address to find its ENS name.\r\n * Note this is not the same as looking up an ENS name to find an address.\r\n */\r\nexport default function useENSName(address?: string): { ENSName: string | null; loading: boolean } {\r\n  const debouncedAddress = useDebounce(address, 200)\r\n  const ensNodeArgument = useMemo(() => {\r\n    if (!debouncedAddress || !isAddress(debouncedAddress)) return [undefined]\r\n    try {\r\n      return [namehash(`${debouncedAddress.toLowerCase().substr(2)}.addr.reverse`)]\r\n    } catch (error) {\r\n      console.error('Invalid address for ENS name lookup:', error)\r\n      return [undefined]\r\n    }\r\n  }, [debouncedAddress])\r\n\r\n  const registrarContract = useENSRegistrarContract(false)\r\n  const resolverAddress = useSingleCallResult(registrarContract, 'resolver', ensNodeArgument)\r\n  const resolverAddressResult = resolverAddress.result?.[0]\r\n\r\n  const resolverContract = useENSResolverContract(resolverAddressResult || undefined, false)\r\n  const name = useSingleCallResult(resolverContract, 'name', ensNodeArgument)\r\n\r\n  const isResolverAddressValid = resolverAddressResult && !isZero(resolverAddressResult)\r\n\r\n  return {\r\n    ENSName: isResolverAddressValid ? name.result?.[0] ?? null : null,\r\n    loading: resolverAddress.loading || name.loading,\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}