{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints';\nimport { ethers } from 'ethers';\nimport { BetPosition, PredictionStatus } from 'state/types';\nimport { multicallv2 } from 'utils/multicall';\nimport predictionsAbi from 'config/abi/predictions.json';\nimport { getPredictionsAddress } from 'utils/addressHelpers';\nimport { getRoundBaseFields, getBetBaseFields, getUserBaseFields } from './queries';\nexport let Result;\n\n(function (Result) {\n  Result[\"WIN\"] = \"win\";\n  Result[\"LOSE\"] = \"lose\";\n  Result[\"CANCELED\"] = \"canceled\";\n  Result[\"LIVE\"] = \"live\";\n})(Result || (Result = {}));\n\nexport const numberOrNull = value => {\n  if (value === null) {\n    return null;\n  }\n\n  const valueNum = Number(value);\n  return Number.isNaN(valueNum) ? null : valueNum;\n};\nexport const transformBetResponse = betResponse => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    claimedHash: betResponse.claimedHash,\n    user: {\n      id: betResponse.user.id,\n      address: betResponse.user.address,\n      block: numberOrNull(betResponse.user.block),\n      totalBets: numberOrNull(betResponse.user.totalBets),\n      totalBNB: numberOrNull(betResponse.user.totalBNB)\n    }\n  };\n\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round);\n  }\n\n  return bet;\n};\nexport const transformRoundResponse = roundResponse => {\n  const {\n    id,\n    epoch,\n    failed,\n    startBlock,\n    startAt,\n    lockAt,\n    lockBlock,\n    lockPrice,\n    endBlock,\n    closePrice,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bearBets,\n    bearAmount,\n    bullAmount,\n    position,\n    bets = []\n  } = roundResponse;\n\n  const getRoundPosition = positionResponse => {\n    if (positionResponse === 'Bull') {\n      return BetPosition.BULL;\n    }\n\n    if (positionResponse === 'Bear') {\n      return BetPosition.BEAR;\n    }\n\n    return null;\n  };\n\n  return {\n    id,\n    failed,\n    epoch: numberOrNull(epoch),\n    startBlock: numberOrNull(startBlock),\n    startAt: numberOrNull(startAt),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\n    endBlock: numberOrNull(endBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : null,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bearBets: numberOrNull(bearBets),\n    bearAmount: numberOrNull(bearAmount),\n    bullAmount: numberOrNull(bullAmount),\n    position: getRoundPosition(position),\n    bets: bets.map(transformBetResponse)\n  };\n};\nexport const transformTotalWonResponse = (marketResponse, roundResponse) => {\n  const houseRounds = roundResponse.reduce((accum, round) => {\n    return accum + (round.totalAmount ? parseFloat(round.totalAmount) : 0);\n  }, 0);\n  const totalBNB = marketResponse.totalBNB ? parseFloat(marketResponse.totalBNB) : 0;\n  const totalBNBTreasury = marketResponse.totalBNBTreasury ? parseFloat(marketResponse.totalBNBTreasury) : 0;\n  return Math.max(totalBNB - (totalBNBTreasury + houseRounds), 0);\n};\nexport const getRoundResult = (bet, currentEpoch) => {\n  const {\n    round\n  } = bet;\n\n  if (round.failed) {\n    return Result.CANCELED;\n  }\n\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE;\n  }\n\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR;\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE;\n};\n/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */\n\nexport const getCanClaim = bet => {\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true);\n};\n/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */\n\nexport const getUnclaimedWinningBets = bets => {\n  return bets.filter(getCanClaim);\n};\nexport const getTotalWon = async () => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getTotalWonData($position: String) {\n        market(id: 1) {\n          totalBNB\n          totalBNBTreasury\n        }\n        rounds(where: { position: $position }) {\n          totalAmount\n        }\n      }\n    `, {\n    position: BetPosition.HOUSE\n  });\n  return transformTotalWonResponse(response.market, response.rounds);\n};\nexport const getBetHistory = async (where = {}, first = 1000, skip = 0) => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `, {\n    first,\n    skip,\n    where\n  });\n  return response.bets;\n};\nexport const getBet = async betId => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `, {\n    id: betId.toLowerCase()\n  });\n  return response.bet;\n}; // V2 REFACTOR\n\nexport const getLedgerData = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const ledgerCalls = epochs.map(epoch => ({\n    address,\n    name: 'ledger',\n    params: [epoch, account]\n  }));\n  const response = await multicallv2(predictionsAbi, ledgerCalls);\n  return response;\n};\nexport const getClaimStatuses = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const claimableCalls = epochs.map(epoch => ({\n    address,\n    name: 'claimable',\n    params: [epoch, account]\n  }));\n  const claimableResponses = await multicallv2(predictionsAbi, claimableCalls); // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\n  // This can be removed in Predictions V2\n\n  const ledgerResponses = await getLedgerData(account, epochs);\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\n    const {\n      amount,\n      claimed\n    } = ledgerResponses[index];\n    const epoch = epochs[index];\n    const [claimable] = claimableResponse;\n    return { ...accum,\n      [epoch]: claimable && amount.gt(0) && !claimed\n    };\n  }, {});\n};\nexport const getPredictionData = async () => {\n  const address = getPredictionsAddress();\n  const staticCalls = ['currentEpoch', 'intervalBlocks', 'minBetAmount', 'paused', 'bufferBlocks', 'rewardRate'].map(method => ({\n    address,\n    name: method\n  }));\n  const [[currentEpoch], [intervalBlocks], [minBetAmount], [paused], [bufferBlocks], [rewardRate]] = await multicallv2(predictionsAbi, staticCalls);\n  return {\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: currentEpoch.toNumber(),\n    intervalBlocks: intervalBlocks.toNumber(),\n    bufferBlocks: bufferBlocks.toNumber(),\n    minBetAmount: minBetAmount.toString(),\n    rewardRate: rewardRate.toNumber()\n  };\n};\nexport const getRoundsData = async epochs => {\n  const address = getPredictionsAddress();\n  const calls = epochs.map(epoch => ({\n    address,\n    name: 'rounds',\n    params: [epoch]\n  }));\n  const response = await multicallv2(predictionsAbi, calls);\n  return response;\n};\nexport const makeFutureRoundResponse = (epoch, startBlock) => {\n  return {\n    epoch,\n    startBlock,\n    lockBlock: null,\n    endBlock: null,\n    lockPrice: null,\n    closePrice: null,\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\n    oracleCalled: false\n  };\n};\nexport const makeRoundData = rounds => {\n  return rounds.reduce((accum, round) => {\n    return { ...accum,\n      [round.epoch.toString()]: round\n    };\n  }, {});\n};\nexport const serializePredictionsLedgerResponse = ledgerResponse => ({\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\n  amount: ledgerResponse.amount.toJSON(),\n  claimed: ledgerResponse.claimed\n});\nexport const makeLedgerData = (account, ledgers, epochs) => {\n  return ledgers.reduce((accum, ledgerResponse, index) => {\n    if (!ledgerResponse) {\n      return accum;\n    } // If the amount is zero that means the user did not bet\n\n\n    if (ledgerResponse.amount.eq(0)) {\n      return accum;\n    }\n\n    const epoch = epochs[index].toString();\n    return { ...accum,\n      [account]: { ...accum[account],\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse)\n      }\n    };\n  }, {});\n};\n/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */\n\nexport const serializePredictionsRoundsResponse = response => {\n  const {\n    epoch,\n    startBlock,\n    lockBlock,\n    endBlock,\n    lockPrice,\n    closePrice,\n    totalAmount,\n    bullAmount,\n    bearAmount,\n    rewardAmount,\n    rewardBaseCalAmount,\n    oracleCalled\n  } = response;\n  return {\n    epoch: epoch.toNumber(),\n    startBlock: startBlock.toNumber(),\n    lockBlock: lockBlock.toNumber(),\n    endBlock: endBlock.toNumber(),\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\n    totalAmount: totalAmount.toJSON(),\n    bullAmount: bullAmount.toJSON(),\n    bearAmount: bearAmount.toJSON(),\n    rewardAmount: rewardAmount.toJSON(),\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\n    oracleCalled\n  };\n};\n/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */\n\nexport const parseBigNumberObj = data => {\n  return Object.keys(data).reduce((accum, key) => {\n    const value = data[key];\n\n    if (value && (value === null || value === void 0 ? void 0 : value.type) === 'BigNumber') {\n      return { ...accum,\n        [key]: ethers.BigNumber.from(value)\n      };\n    }\n\n    return { ...accum,\n      [key]: value\n    };\n  }, {});\n};","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/predictions/helpers.ts"],"names":["request","gql","GRAPH_API_PREDICTION","ethers","BetPosition","PredictionStatus","multicallv2","predictionsAbi","getPredictionsAddress","getRoundBaseFields","getBetBaseFields","getUserBaseFields","Result","numberOrNull","value","valueNum","Number","isNaN","transformBetResponse","betResponse","bet","id","hash","amount","parseFloat","position","BULL","BEAR","claimed","claimedHash","user","address","block","totalBets","totalBNB","round","transformRoundResponse","roundResponse","epoch","failed","startBlock","startAt","lockAt","lockBlock","lockPrice","endBlock","closePrice","totalAmount","bullBets","bearBets","bearAmount","bullAmount","bets","getRoundPosition","positionResponse","map","transformTotalWonResponse","marketResponse","houseRounds","reduce","accum","totalBNBTreasury","Math","max","getRoundResult","currentEpoch","CANCELED","LIVE","roundResultPosition","WIN","LOSE","getCanClaim","getUnclaimedWinningBets","filter","getTotalWon","response","HOUSE","market","rounds","getBetHistory","where","first","skip","getBet","betId","toLowerCase","getLedgerData","account","epochs","ledgerCalls","name","params","getClaimStatuses","claimableCalls","claimableResponses","ledgerResponses","claimableResponse","index","claimable","gt","getPredictionData","staticCalls","method","intervalBlocks","minBetAmount","paused","bufferBlocks","rewardRate","status","PAUSED","toNumber","toString","getRoundsData","calls","makeFutureRoundResponse","BigNumber","from","toJSON","rewardBaseCalAmount","rewardAmount","oracleCalled","makeRoundData","serializePredictionsLedgerResponse","ledgerResponse","makeLedgerData","ledgers","eq","serializePredictionsRoundsResponse","parseBigNumberObj","data","Object","keys","key","type"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints'\r\nimport { ethers } from 'ethers'\r\nimport {\r\n  Bet,\r\n  LedgerData,\r\n  BetPosition,\r\n  PredictionsState,\r\n  PredictionStatus,\r\n  ReduxNodeLedger,\r\n  ReduxNodeRound,\r\n  Round,\r\n  RoundData,\r\n} from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport predictionsAbi from 'config/abi/predictions.json'\r\nimport { getPredictionsAddress } from 'utils/addressHelpers'\r\nimport { PredictionsClaimableResponse, PredictionsLedgerResponse, PredictionsRoundsResponse } from 'utils/types'\r\nimport {\r\n  BetResponse,\r\n  getRoundBaseFields,\r\n  getBetBaseFields,\r\n  getUserBaseFields,\r\n  RoundResponse,\r\n  TotalWonMarketResponse,\r\n  TotalWonRoundResponse,\r\n} from './queries'\r\n\r\nexport enum Result {\r\n  WIN = 'win',\r\n  LOSE = 'lose',\r\n  CANCELED = 'canceled',\r\n  LIVE = 'live',\r\n}\r\n\r\nexport const numberOrNull = (value: string) => {\r\n  if (value === null) {\r\n    return null\r\n  }\r\n\r\n  const valueNum = Number(value)\r\n  return Number.isNaN(valueNum) ? null : valueNum\r\n}\r\n\r\nexport const transformBetResponse = (betResponse: BetResponse): Bet => {\r\n  const bet = {\r\n    id: betResponse.id,\r\n    hash: betResponse.hash,\r\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\r\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\r\n    claimed: betResponse.claimed,\r\n    claimedHash: betResponse.claimedHash,\r\n    user: {\r\n      id: betResponse.user.id,\r\n      address: betResponse.user.address,\r\n      block: numberOrNull(betResponse.user.block),\r\n      totalBets: numberOrNull(betResponse.user.totalBets),\r\n      totalBNB: numberOrNull(betResponse.user.totalBNB),\r\n    },\r\n  } as Bet\r\n\r\n  if (betResponse.round) {\r\n    bet.round = transformRoundResponse(betResponse.round)\r\n  }\r\n\r\n  return bet\r\n}\r\n\r\nexport const transformRoundResponse = (roundResponse: RoundResponse): Round => {\r\n  const {\r\n    id,\r\n    epoch,\r\n    failed,\r\n    startBlock,\r\n    startAt,\r\n    lockAt,\r\n    lockBlock,\r\n    lockPrice,\r\n    endBlock,\r\n    closePrice,\r\n    totalBets,\r\n    totalAmount,\r\n    bullBets,\r\n    bearBets,\r\n    bearAmount,\r\n    bullAmount,\r\n    position,\r\n    bets = [],\r\n  } = roundResponse\r\n\r\n  const getRoundPosition = (positionResponse: string) => {\r\n    if (positionResponse === 'Bull') {\r\n      return BetPosition.BULL\r\n    }\r\n\r\n    if (positionResponse === 'Bear') {\r\n      return BetPosition.BEAR\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  return {\r\n    id,\r\n    failed,\r\n    epoch: numberOrNull(epoch),\r\n    startBlock: numberOrNull(startBlock),\r\n    startAt: numberOrNull(startAt),\r\n    lockAt: numberOrNull(lockAt),\r\n    lockBlock: numberOrNull(lockBlock),\r\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\r\n    endBlock: numberOrNull(endBlock),\r\n    closePrice: closePrice ? parseFloat(closePrice) : null,\r\n    totalBets: numberOrNull(totalBets),\r\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\r\n    bullBets: numberOrNull(bullBets),\r\n    bearBets: numberOrNull(bearBets),\r\n    bearAmount: numberOrNull(bearAmount),\r\n    bullAmount: numberOrNull(bullAmount),\r\n    position: getRoundPosition(position),\r\n    bets: bets.map(transformBetResponse),\r\n  }\r\n}\r\n\r\nexport const transformTotalWonResponse = (\r\n  marketResponse: TotalWonMarketResponse,\r\n  roundResponse: TotalWonRoundResponse[],\r\n): number => {\r\n  const houseRounds = roundResponse.reduce((accum, round) => {\r\n    return accum + (round.totalAmount ? parseFloat(round.totalAmount) : 0)\r\n  }, 0)\r\n\r\n  const totalBNB = marketResponse.totalBNB ? parseFloat(marketResponse.totalBNB) : 0\r\n  const totalBNBTreasury = marketResponse.totalBNBTreasury ? parseFloat(marketResponse.totalBNBTreasury) : 0\r\n\r\n  return Math.max(totalBNB - (totalBNBTreasury + houseRounds), 0)\r\n}\r\n\r\nexport const getRoundResult = (bet: Bet, currentEpoch: number): Result => {\r\n  const { round } = bet\r\n  if (round.failed) {\r\n    return Result.CANCELED\r\n  }\r\n\r\n  if (round.epoch >= currentEpoch - 1) {\r\n    return Result.LIVE\r\n  }\r\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR\r\n\r\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE\r\n}\r\n\r\n/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */\r\nexport const getCanClaim = (bet: Bet) => {\r\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true)\r\n}\r\n\r\n/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */\r\nexport const getUnclaimedWinningBets = (bets: Bet[]): Bet[] => {\r\n  return bets.filter(getCanClaim)\r\n}\r\n\r\nexport const getTotalWon = async (): Promise<number> => {\r\n  const response = (await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getTotalWonData($position: String) {\r\n        market(id: 1) {\r\n          totalBNB\r\n          totalBNBTreasury\r\n        }\r\n        rounds(where: { position: $position }) {\r\n          totalAmount\r\n        }\r\n      }\r\n    `,\r\n    { position: BetPosition.HOUSE },\r\n  )) as { market: TotalWonMarketResponse; rounds: TotalWonRoundResponse[] }\r\n\r\n  return transformTotalWonResponse(response.market, response.rounds)\r\n}\r\n\r\ntype BetHistoryWhereClause = Record<string, string | number | boolean | string[]>\r\n\r\nexport const getBetHistory = async (\r\n  where: BetHistoryWhereClause = {},\r\n  first = 1000,\r\n  skip = 0,\r\n): Promise<BetResponse[]> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\r\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n    `,\r\n    { first, skip, where },\r\n  )\r\n  return response.bets\r\n}\r\n\r\nexport const getBet = async (betId: string): Promise<BetResponse> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBet($id: ID!) {\r\n        bet(id: $id) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n  `,\r\n    {\r\n      id: betId.toLowerCase(),\r\n    },\r\n  )\r\n  return response.bet\r\n}\r\n\r\n// V2 REFACTOR\r\nexport const getLedgerData = async (account: string, epochs: number[]) => {\r\n  const address = getPredictionsAddress()\r\n  const ledgerCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'ledger',\r\n    params: [epoch, account],\r\n  }))\r\n  const response = await multicallv2<PredictionsLedgerResponse[]>(predictionsAbi, ledgerCalls)\r\n  return response\r\n}\r\n\r\nexport const getClaimStatuses = async (\r\n  account: string,\r\n  epochs: number[],\r\n): Promise<PredictionsState['claimableStatuses']> => {\r\n  const address = getPredictionsAddress()\r\n  const claimableCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'claimable',\r\n    params: [epoch, account],\r\n  }))\r\n  const claimableResponses = await multicallv2<[PredictionsClaimableResponse][]>(predictionsAbi, claimableCalls)\r\n\r\n  // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\r\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\r\n  // This can be removed in Predictions V2\r\n  const ledgerResponses = await getLedgerData(account, epochs)\r\n\r\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\r\n    const { amount, claimed } = ledgerResponses[index]\r\n    const epoch = epochs[index]\r\n    const [claimable] = claimableResponse\r\n\r\n    return {\r\n      ...accum,\r\n      [epoch]: claimable && amount.gt(0) && !claimed,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport type MarketData = Pick<\r\n  PredictionsState,\r\n  'status' | 'currentEpoch' | 'intervalBlocks' | 'bufferBlocks' | 'minBetAmount' | 'rewardRate'\r\n>\r\nexport const getPredictionData = async (): Promise<MarketData> => {\r\n  const address = getPredictionsAddress()\r\n  const staticCalls = ['currentEpoch', 'intervalBlocks', 'minBetAmount', 'paused', 'bufferBlocks', 'rewardRate'].map(\r\n    (method) => ({\r\n      address,\r\n      name: method,\r\n    }),\r\n  )\r\n  const [[currentEpoch], [intervalBlocks], [minBetAmount], [paused], [bufferBlocks], [rewardRate]] = await multicallv2(\r\n    predictionsAbi,\r\n    staticCalls,\r\n  )\r\n\r\n  return {\r\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\r\n    currentEpoch: currentEpoch.toNumber(),\r\n    intervalBlocks: intervalBlocks.toNumber(),\r\n    bufferBlocks: bufferBlocks.toNumber(),\r\n    minBetAmount: minBetAmount.toString(),\r\n    rewardRate: rewardRate.toNumber(),\r\n  }\r\n}\r\n\r\nexport const getRoundsData = async (epochs: number[]): Promise<PredictionsRoundsResponse[]> => {\r\n  const address = getPredictionsAddress()\r\n  const calls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'rounds',\r\n    params: [epoch],\r\n  }))\r\n  const response = await multicallv2<PredictionsRoundsResponse[]>(predictionsAbi, calls)\r\n  return response\r\n}\r\n\r\nexport const makeFutureRoundResponse = (epoch: number, startBlock: number): ReduxNodeRound => {\r\n  return {\r\n    epoch,\r\n    startBlock,\r\n    lockBlock: null,\r\n    endBlock: null,\r\n    lockPrice: null,\r\n    closePrice: null,\r\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\r\n    oracleCalled: false,\r\n  }\r\n}\r\n\r\nexport const makeRoundData = (rounds: ReduxNodeRound[]): RoundData => {\r\n  return rounds.reduce((accum, round) => {\r\n    return {\r\n      ...accum,\r\n      [round.epoch.toString()]: round,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport const serializePredictionsLedgerResponse = (ledgerResponse: PredictionsLedgerResponse): ReduxNodeLedger => ({\r\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\r\n  amount: ledgerResponse.amount.toJSON(),\r\n  claimed: ledgerResponse.claimed,\r\n})\r\n\r\nexport const makeLedgerData = (account: string, ledgers: PredictionsLedgerResponse[], epochs: number[]): LedgerData => {\r\n  return ledgers.reduce((accum, ledgerResponse, index) => {\r\n    if (!ledgerResponse) {\r\n      return accum\r\n    }\r\n\r\n    // If the amount is zero that means the user did not bet\r\n    if (ledgerResponse.amount.eq(0)) {\r\n      return accum\r\n    }\r\n\r\n    const epoch = epochs[index].toString()\r\n\r\n    return {\r\n      ...accum,\r\n      [account]: {\r\n        ...accum[account],\r\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse),\r\n      },\r\n    }\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */\r\nexport const serializePredictionsRoundsResponse = (response: PredictionsRoundsResponse): ReduxNodeRound => {\r\n  const {\r\n    epoch,\r\n    startBlock,\r\n    lockBlock,\r\n    endBlock,\r\n    lockPrice,\r\n    closePrice,\r\n    totalAmount,\r\n    bullAmount,\r\n    bearAmount,\r\n    rewardAmount,\r\n    rewardBaseCalAmount,\r\n    oracleCalled,\r\n  } = response\r\n\r\n  return {\r\n    epoch: epoch.toNumber(),\r\n    startBlock: startBlock.toNumber(),\r\n    lockBlock: lockBlock.toNumber(),\r\n    endBlock: endBlock.toNumber(),\r\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\r\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\r\n    totalAmount: totalAmount.toJSON(),\r\n    bullAmount: bullAmount.toJSON(),\r\n    bearAmount: bearAmount.toJSON(),\r\n    rewardAmount: rewardAmount.toJSON(),\r\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\r\n    oracleCalled,\r\n  }\r\n}\r\n\r\n/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */\r\nexport const parseBigNumberObj = <T = Record<string, any>, K = Record<string, any>>(data: T): K => {\r\n  return Object.keys(data).reduce((accum, key) => {\r\n    const value = data[key]\r\n\r\n    if (value && value?.type === 'BigNumber') {\r\n      return {\r\n        ...accum,\r\n        [key]: ethers.BigNumber.from(value),\r\n      }\r\n    }\r\n\r\n    return {\r\n      ...accum,\r\n      [key]: value,\r\n    }\r\n  }, {}) as K\r\n}\r\n"]},"metadata":{},"sourceType":"module"}