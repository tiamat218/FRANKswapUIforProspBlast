{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\n/* eslint-disable no-param-reassign */\nimport { isTradeBetter } from 'utils/trades';\nimport { Trade } from '@pancakeswap/sdk';\nimport flatMap from 'lodash/flatMap';\nimport { useMemo } from 'react';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { useUserSingleHopOnly } from 'state/user/hooks';\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES, BETTER_TRADE_LESS_HOPS_THRESHOLD, ADDITIONAL_BASES } from '../config/constants';\nimport { PairState, usePairs } from './usePairs';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useUnsupportedTokens } from './Tokens';\nfunction useAllCommonPairs(currencyA, currencyB) {\n  _s();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const [tokenA, tokenB] = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined];\n  const bases = useMemo(() => {\n    var _BASES_TO_CHECK_TRADE, _ADDITIONAL_BASES$cha, _ADDITIONAL_BASES$cha2, _ADDITIONAL_BASES$cha3, _ADDITIONAL_BASES$cha4;\n    if (!chainId) return [];\n    const common = (_BASES_TO_CHECK_TRADE = BASES_TO_CHECK_TRADES_AGAINST[chainId]) !== null && _BASES_TO_CHECK_TRADE !== void 0 ? _BASES_TO_CHECK_TRADE : [];\n    const additionalA = tokenA ? (_ADDITIONAL_BASES$cha = (_ADDITIONAL_BASES$cha2 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha2 === void 0 ? void 0 : _ADDITIONAL_BASES$cha2[tokenA.address]) !== null && _ADDITIONAL_BASES$cha !== void 0 ? _ADDITIONAL_BASES$cha : [] : [];\n    const additionalB = tokenB ? (_ADDITIONAL_BASES$cha3 = (_ADDITIONAL_BASES$cha4 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha4 === void 0 ? void 0 : _ADDITIONAL_BASES$cha4[tokenB.address]) !== null && _ADDITIONAL_BASES$cha3 !== void 0 ? _ADDITIONAL_BASES$cha3 : [] : [];\n    return [...common, ...additionalA, ...additionalB];\n  }, [chainId, tokenA, tokenB]);\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])), [bases]);\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [\n  // the direct pair\n  [tokenA, tokenB],\n  // token A against all bases\n  ...bases.map(base => [tokenA, base]),\n  // token B against all bases\n  ...bases.map(base => [tokenB, base]),\n  // each base against all bases\n  ...basePairs].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(([t0, t1]) => t0.address !== t1.address).filter(([tokenA_, tokenB_]) => {\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    const customBasesA = customBases === null || customBases === void 0 ? void 0 : customBases[tokenA_.address];\n    const customBasesB = customBases === null || customBases === void 0 ? void 0 : customBases[tokenB_.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && !customBasesA.find(base => tokenB_.equals(base))) return false;\n    if (customBasesB && !customBasesB.find(base => tokenA_.equals(base))) return false;\n    return true;\n  }) : [], [tokenA, tokenB, bases, basePairs, chainId]);\n  const allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(() => Object.values(allPairs\n  // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1]))\n  // filter out duplicated pairs\n  .reduce((memo, [, curr]) => {\n    var _memo$curr$liquidityT;\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n_s(useAllCommonPairs, \"yOlOGLSe6CG5zU7a8alITxmtf8s=\", false, function () {\n  return [useActiveWeb3React, usePairs];\n});\nconst MAX_HOPS = 3;\n\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  _s2();\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact;\n        return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact2;\n        const currentTrade = (_Trade$bestTradeExact2 = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null;\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\n_s2(useTradeExactIn, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  _s3();\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact3;\n        return (_Trade$bestTradeExact3 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact3 !== void 0 ? _Trade$bestTradeExact3 : null;\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact4;\n        const currentTrade = (_Trade$bestTradeExact4 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact4 !== void 0 ? _Trade$bestTradeExact4 : null;\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}\n_s3(useTradeExactOut, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});\nexport function useIsTransactionUnsupported(currencyIn, currencyOut) {\n  _s4();\n  const unsupportedTokens = useUnsupportedTokens();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokenIn = wrappedCurrency(currencyIn, chainId);\n  const tokenOut = wrappedCurrency(currencyOut, chainId);\n\n  // if unsupported list loaded & either token on list, mark as unsupported\n  if (unsupportedTokens) {\n    if (tokenIn && Object.keys(unsupportedTokens).includes(tokenIn.address)) {\n      return true;\n    }\n    if (tokenOut && Object.keys(unsupportedTokens).includes(tokenOut.address)) {\n      return true;\n    }\n  }\n  return false;\n}\n_s4(useIsTransactionUnsupported, \"mh+vbeh73y5JIEumpyTy9rh8i2g=\", false, function () {\n  return [useUnsupportedTokens, useActiveWeb3React];\n});","map":{"version":3,"names":["isTradeBetter","Trade","flatMap","useMemo","useActiveWeb3React","useUserSingleHopOnly","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","BETTER_TRADE_LESS_HOPS_THRESHOLD","ADDITIONAL_BASES","PairState","usePairs","wrappedCurrency","useUnsupportedTokens","useAllCommonPairs","currencyA","currencyB","_s","chainId","tokenA","tokenB","undefined","bases","_BASES_TO_CHECK_TRADE","_ADDITIONAL_BASES$cha","_ADDITIONAL_BASES$cha2","_ADDITIONAL_BASES$cha3","_ADDITIONAL_BASES$cha4","common","additionalA","address","additionalB","basePairs","base","map","otherBase","allPairCombinations","filter","tokens","Boolean","t0","t1","tokenA_","tokenB_","customBases","customBasesA","customBasesB","find","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","_memo$curr$liquidityT","liquidityToken","MAX_HOPS","useTradeExactIn","currencyAmountIn","currencyOut","_s2","allowedPairs","currency","singleHopOnly","length","_Trade$bestTradeExact","bestTradeExactIn","maxHops","maxNumResults","bestTradeSoFar","i","_Trade$bestTradeExact2","currentTrade","useTradeExactOut","currencyIn","currencyAmountOut","_s3","_Trade$bestTradeExact3","bestTradeExactOut","_Trade$bestTradeExact4","useIsTransactionUnsupported","_s4","unsupportedTokens","tokenIn","tokenOut","keys","includes"],"sources":["C:/Users/Devrim/Documents/swapUIforProspBlast/src/hooks/Trades.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\r\nimport { isTradeBetter } from 'utils/trades'\r\nimport { Currency, CurrencyAmount, Pair, Token, Trade } from '@pancakeswap/sdk'\r\nimport flatMap from 'lodash/flatMap'\r\nimport { useMemo } from 'react'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\n\r\nimport { useUserSingleHopOnly } from 'state/user/hooks'\r\nimport {\r\n  BASES_TO_CHECK_TRADES_AGAINST,\r\n  CUSTOM_BASES,\r\n  BETTER_TRADE_LESS_HOPS_THRESHOLD,\r\n  ADDITIONAL_BASES,\r\n} from '../config/constants'\r\nimport { PairState, usePairs } from './usePairs'\r\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\r\n\r\nimport { useUnsupportedTokens } from './Tokens'\r\n\r\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\r\n  const { chainId } = useActiveWeb3React()\r\n\r\n  const [tokenA, tokenB] = chainId\r\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\r\n    : [undefined, undefined]\r\n\r\n  const bases: Token[] = useMemo(() => {\r\n    if (!chainId) return []\r\n\r\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\r\n    const additionalA = tokenA ? ADDITIONAL_BASES[chainId]?.[tokenA.address] ?? [] : []\r\n    const additionalB = tokenB ? ADDITIONAL_BASES[chainId]?.[tokenB.address] ?? [] : []\r\n\r\n    return [...common, ...additionalA, ...additionalB]\r\n  }, [chainId, tokenA, tokenB])\r\n\r\n  const basePairs: [Token, Token][] = useMemo(\r\n    () => flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])),\r\n    [bases],\r\n  )\r\n\r\n  const allPairCombinations: [Token, Token][] = useMemo(\r\n    () =>\r\n      tokenA && tokenB\r\n        ? [\r\n            // the direct pair\r\n            [tokenA, tokenB],\r\n            // token A against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\r\n            // token B against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\r\n            // each base against all bases\r\n            ...basePairs,\r\n          ]\r\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\r\n            .filter(([t0, t1]) => t0.address !== t1.address)\r\n            .filter(([tokenA_, tokenB_]) => {\r\n              if (!chainId) return true\r\n              const customBases = CUSTOM_BASES[chainId]\r\n\r\n              const customBasesA: Token[] | undefined = customBases?.[tokenA_.address]\r\n              const customBasesB: Token[] | undefined = customBases?.[tokenB_.address]\r\n\r\n              if (!customBasesA && !customBasesB) return true\r\n\r\n              if (customBasesA && !customBasesA.find((base) => tokenB_.equals(base))) return false\r\n              if (customBasesB && !customBasesB.find((base) => tokenA_.equals(base))) return false\r\n\r\n              return true\r\n            })\r\n        : [],\r\n    [tokenA, tokenB, bases, basePairs, chainId],\r\n  )\r\n\r\n  const allPairs = usePairs(allPairCombinations)\r\n\r\n  // only pass along valid pairs, non-duplicated pairs\r\n  return useMemo(\r\n    () =>\r\n      Object.values(\r\n        allPairs\r\n          // filter out invalid pairs\r\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\r\n          // filter out duplicated pairs\r\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\r\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\r\n            return memo\r\n          }, {}),\r\n      ),\r\n    [allPairs],\r\n  )\r\n}\r\n\r\nconst MAX_HOPS = 3\r\n\r\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\r\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\r\n\r\n  const [singleHopOnly] = useUserSingleHopOnly()\r\n\r\n  return useMemo(() => {\r\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\r\n      if (singleHopOnly) {\r\n        return (\r\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\r\n          null\r\n        )\r\n      }\r\n      // search through trades with varying hops, find best trade out of them\r\n      let bestTradeSoFar: Trade | null = null\r\n      for (let i = 1; i <= MAX_HOPS; i++) {\r\n        const currentTrade: Trade | null =\r\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\r\n          null\r\n        // if current trade is best yet, save it\r\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\r\n          bestTradeSoFar = currentTrade\r\n        }\r\n      }\r\n      return bestTradeSoFar\r\n    }\r\n\r\n    return null\r\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly])\r\n}\r\n\r\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\r\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\r\n\r\n  const [singleHopOnly] = useUserSingleHopOnly()\r\n\r\n  return useMemo(() => {\r\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\r\n      if (singleHopOnly) {\r\n        return (\r\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\r\n          null\r\n        )\r\n      }\r\n      // search through trades with varying hops, find best trade out of them\r\n      let bestTradeSoFar: Trade | null = null\r\n      for (let i = 1; i <= MAX_HOPS; i++) {\r\n        const currentTrade =\r\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\r\n          null\r\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\r\n          bestTradeSoFar = currentTrade\r\n        }\r\n      }\r\n      return bestTradeSoFar\r\n    }\r\n    return null\r\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly])\r\n}\r\n\r\nexport function useIsTransactionUnsupported(currencyIn?: Currency, currencyOut?: Currency): boolean {\r\n  const unsupportedTokens: { [address: string]: Token } = useUnsupportedTokens()\r\n  const { chainId } = useActiveWeb3React()\r\n\r\n  const tokenIn = wrappedCurrency(currencyIn, chainId)\r\n  const tokenOut = wrappedCurrency(currencyOut, chainId)\r\n\r\n  // if unsupported list loaded & either token on list, mark as unsupported\r\n  if (unsupportedTokens) {\r\n    if (tokenIn && Object.keys(unsupportedTokens).includes(tokenIn.address)) {\r\n      return true\r\n    }\r\n    if (tokenOut && Object.keys(unsupportedTokens).includes(tokenOut.address)) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}