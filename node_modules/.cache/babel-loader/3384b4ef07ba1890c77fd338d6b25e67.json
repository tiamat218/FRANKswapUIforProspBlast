{"ast":null,"code":"import{currencyEquals,ETHER,WETH}from'@pancakeswap/sdk';import{useMemo}from'react';import useActiveWeb3React from'hooks/useActiveWeb3React';import{tryParseAmount}from'../state/swap/hooks';import{useTransactionAdder}from'../state/transactions/hooks';import{useCurrencyBalance}from'../state/wallet/hooks';import{useWETHContract}from'./useContract';export let WrapType;(function(WrapType){WrapType[WrapType[\"NOT_APPLICABLE\"]=0]=\"NOT_APPLICABLE\";WrapType[WrapType[\"WRAP\"]=1]=\"WRAP\";WrapType[WrapType[\"UNWRAP\"]=2]=\"UNWRAP\";})(WrapType||(WrapType={}));const NOT_APPLICABLE={wrapType:WrapType.NOT_APPLICABLE};/**\r\n * Given the selected input and output currency, return a wrap callback\r\n * @param inputCurrency the selected input currency\r\n * @param outputCurrency the selected output currency\r\n * @param typedValue the user input value\r\n */export default function useWrapCallback(inputCurrency,outputCurrency,typedValue){const{chainId,account}=useActiveWeb3React();const wethContract=useWETHContract();const balance=useCurrencyBalance(account!==null&&account!==void 0?account:undefined,inputCurrency);// we can always parse the amount typed as the input currency, since wrapping is 1:1\nconst inputAmount=useMemo(()=>tryParseAmount(typedValue,inputCurrency),[inputCurrency,typedValue]);const addTransaction=useTransactionAdder();return useMemo(()=>{if(!wethContract||!chainId||!inputCurrency||!outputCurrency)return NOT_APPLICABLE;const sufficientBalance=inputAmount&&balance&&!balance.lessThan(inputAmount);if(inputCurrency===ETHER&&currencyEquals(WETH[chainId],outputCurrency)){return{wrapType:WrapType.WRAP,execute:sufficientBalance&&inputAmount?async()=>{try{const txReceipt=await wethContract.deposit({value:\"0x\".concat(inputAmount.raw.toString(16))});addTransaction(txReceipt,{summary:\"Wrap \".concat(inputAmount.toSignificant(6),\" BNB to WBNB\")});}catch(error){console.error('Could not deposit',error);}}:undefined,inputError:sufficientBalance?undefined:'Insufficient BNB balance'};}if(currencyEquals(WETH[chainId],inputCurrency)&&outputCurrency===ETHER){return{wrapType:WrapType.UNWRAP,execute:sufficientBalance&&inputAmount?async()=>{try{const txReceipt=await wethContract.withdraw(\"0x\".concat(inputAmount.raw.toString(16)));addTransaction(txReceipt,{summary:\"Unwrap \".concat(inputAmount.toSignificant(6),\" WBNB to BNB\")});}catch(error){console.error('Could not withdraw',error);}}:undefined,inputError:sufficientBalance?undefined:'Insufficient WBNB balance'};}return NOT_APPLICABLE;},[wethContract,chainId,inputCurrency,outputCurrency,inputAmount,balance,addTransaction]);}","map":{"version":3,"names":["currencyEquals","ETHER","WETH","useMemo","useActiveWeb3React","tryParseAmount","useTransactionAdder","useCurrencyBalance","useWETHContract","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","wethContract","balance","undefined","inputAmount","addTransaction","sufficientBalance","lessThan","WRAP","execute","txReceipt","deposit","value","concat","raw","toString","summary","toSignificant","error","console","inputError","UNWRAP","withdraw"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/hooks/useWrapCallback.ts"],"sourcesContent":["import { Currency, currencyEquals, ETHER, WETH } from '@pancakeswap/sdk'\r\nimport { useMemo } from 'react'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport { tryParseAmount } from '../state/swap/hooks'\r\nimport { useTransactionAdder } from '../state/transactions/hooks'\r\nimport { useCurrencyBalance } from '../state/wallet/hooks'\r\nimport { useWETHContract } from './useContract'\r\n\r\nexport enum WrapType {\r\n  NOT_APPLICABLE,\r\n  WRAP,\r\n  UNWRAP,\r\n}\r\n\r\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\r\n/**\r\n * Given the selected input and output currency, return a wrap callback\r\n * @param inputCurrency the selected input currency\r\n * @param outputCurrency the selected output currency\r\n * @param typedValue the user input value\r\n */\r\nexport default function useWrapCallback(\r\n  inputCurrency: Currency | undefined,\r\n  outputCurrency: Currency | undefined,\r\n  typedValue: string | undefined,\r\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: string } {\r\n  const { chainId, account } = useActiveWeb3React()\r\n  const wethContract = useWETHContract()\r\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency)\r\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\r\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue])\r\n  const addTransaction = useTransactionAdder()\r\n\r\n  return useMemo(() => {\r\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\r\n\r\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\r\n\r\n    if (inputCurrency === ETHER && currencyEquals(WETH[chainId], outputCurrency)) {\r\n      return {\r\n        wrapType: WrapType.WRAP,\r\n        execute:\r\n          sufficientBalance && inputAmount\r\n            ? async () => {\r\n                try {\r\n                  const txReceipt = await wethContract.deposit({ value: `0x${inputAmount.raw.toString(16)}` })\r\n                  addTransaction(txReceipt, { summary: `Wrap ${inputAmount.toSignificant(6)} BNB to WBNB` })\r\n                } catch (error) {\r\n                  console.error('Could not deposit', error)\r\n                }\r\n              }\r\n            : undefined,\r\n        inputError: sufficientBalance ? undefined : 'Insufficient BNB balance',\r\n      }\r\n    }\r\n    if (currencyEquals(WETH[chainId], inputCurrency) && outputCurrency === ETHER) {\r\n      return {\r\n        wrapType: WrapType.UNWRAP,\r\n        execute:\r\n          sufficientBalance && inputAmount\r\n            ? async () => {\r\n                try {\r\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`)\r\n                  addTransaction(txReceipt, { summary: `Unwrap ${inputAmount.toSignificant(6)} WBNB to BNB` })\r\n                } catch (error) {\r\n                  console.error('Could not withdraw', error)\r\n                }\r\n              }\r\n            : undefined,\r\n        inputError: sufficientBalance ? undefined : 'Insufficient WBNB balance',\r\n      }\r\n    }\r\n    return NOT_APPLICABLE\r\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction])\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}