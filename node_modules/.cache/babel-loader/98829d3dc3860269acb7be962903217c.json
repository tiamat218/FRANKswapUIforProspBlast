{"ast":null,"code":"'use strict';\n\n/** @typedef {import('./types').CodecFactory} CodecFactory */\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  // Count the padding bytes:\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n\n  // Parse the data:\n  let bits = 0; // Number of bits currently in the buffer\n  let buffer = 0; // Bits waiting to be written out, MSB first\n  let written = 0; // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[i]);\n    }\n\n    // Append the bits to the buffer:\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0; // Number of bits currently in the buffer\n  let buffer = 0; // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\n\n/**\n * RFC4648 Factory\n *\n * @param {number} bitsPerChar\n * @returns {CodecFactory}\n */\nconst rfc4648 = bitsPerChar => alphabet => {\n  return {\n    /**\n     * @param {Uint8Array} input\n     * @returns {string}\n     */\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    /**\n     * @param {string} input\n     * @returns {Uint8Array}\n     */\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar);\n    }\n  };\n};\nmodule.exports = {\n  rfc4648\n};","map":{"version":3,"names":["decode","string","alphabet","bitsPerChar","codes","i","length","end","out","Uint8Array","bits","buffer","written","value","undefined","SyntaxError","encode","data","pad","mask","rfc4648","input","module","exports"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/node_modules/multibase/src/rfc4648.js"],"sourcesContent":["'use strict'\n\n/** @typedef {import('./types').CodecFactory} CodecFactory */\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[i])\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @param {number} bitsPerChar\n * @returns {CodecFactory}\n */\nconst rfc4648 = (bitsPerChar) => (alphabet) => {\n  return {\n    /**\n     * @param {Uint8Array} input\n     * @returns {string}\n     */\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    /**\n     * @param {string} input\n     * @returns {Uint8Array}\n     */\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar)\n    }\n  }\n}\n\nmodule.exports = { rfc4648 }\n"],"mappings":"AAAA,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,MAAM,GAAGA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,WAAW,KAAK;EAChD;EACA;EACA,MAAMC,KAAK,GAAG,CAAC,CAAC;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAACI,MAAM,EAAE,EAAED,CAAC,EAAE;IACxCD,KAAK,CAACF,QAAQ,CAACG,CAAC,CAAC,CAAC,GAAGA,CAAC;EACxB;;EAEA;EACA,IAAIE,GAAG,GAAGN,MAAM,CAACK,MAAM;EACvB,OAAOL,MAAM,CAACM,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;IAC9B,EAAEA,GAAG;EACP;;EAEA;EACA,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAAEF,GAAG,GAAGJ,WAAW,GAAG,CAAC,GAAI,CAAC,CAAC;;EAEvD;EACA,IAAIO,IAAI,GAAG,CAAC,EAAC;EACb,IAAIC,MAAM,GAAG,CAAC,EAAC;EACf,IAAIC,OAAO,GAAG,CAAC,EAAC;EAChB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,GAAG,EAAE,EAAEF,CAAC,EAAE;IAC5B;IACA,MAAMQ,KAAK,GAAGT,KAAK,CAACH,MAAM,CAACI,CAAC,CAAC,CAAC;IAC9B,IAAIQ,KAAK,KAAKC,SAAS,EAAE;MACvB,MAAM,IAAIC,WAAW,CAAC,oBAAoB,GAAGd,MAAM,CAACI,CAAC,CAAC,CAAC;IACzD;;IAEA;IACAM,MAAM,GAAIA,MAAM,IAAIR,WAAW,GAAIU,KAAK;IACxCH,IAAI,IAAIP,WAAW;;IAEnB;IACA,IAAIO,IAAI,IAAI,CAAC,EAAE;MACbA,IAAI,IAAI,CAAC;MACTF,GAAG,CAACI,OAAO,EAAE,CAAC,GAAG,IAAI,GAAID,MAAM,IAAID,IAAK;IAC1C;EACF;;EAEA;EACA,IAAIA,IAAI,IAAIP,WAAW,IAAI,IAAI,GAAIQ,MAAM,IAAK,CAAC,GAAGD,IAAM,EAAE;IACxD,MAAM,IAAIK,WAAW,CAAC,wBAAwB,CAAC;EACjD;EAEA,OAAOP,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMQ,MAAM,GAAGA,CAACC,IAAI,EAAEf,QAAQ,EAAEC,WAAW,KAAK;EAC9C,MAAMe,GAAG,GAAGhB,QAAQ,CAACA,QAAQ,CAACI,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG;EACjD,MAAMa,IAAI,GAAG,CAAC,CAAC,IAAIhB,WAAW,IAAI,CAAC;EACnC,IAAIK,GAAG,GAAG,EAAE;EAEZ,IAAIE,IAAI,GAAG,CAAC,EAAC;EACb,IAAIC,MAAM,GAAG,CAAC,EAAC;EACf,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACX,MAAM,EAAE,EAAED,CAAC,EAAE;IACpC;IACAM,MAAM,GAAIA,MAAM,IAAI,CAAC,GAAIM,IAAI,CAACZ,CAAC,CAAC;IAChCK,IAAI,IAAI,CAAC;;IAET;IACA,OAAOA,IAAI,GAAGP,WAAW,EAAE;MACzBO,IAAI,IAAIP,WAAW;MACnBK,GAAG,IAAIN,QAAQ,CAACiB,IAAI,GAAIR,MAAM,IAAID,IAAK,CAAC;IAC1C;EACF;;EAEA;EACA,IAAIA,IAAI,EAAE;IACRF,GAAG,IAAIN,QAAQ,CAACiB,IAAI,GAAIR,MAAM,IAAKR,WAAW,GAAGO,IAAM,CAAC;EAC1D;;EAEA;EACA,IAAIQ,GAAG,EAAE;IACP,OAAQV,GAAG,CAACF,MAAM,GAAGH,WAAW,GAAI,CAAC,EAAE;MACrCK,GAAG,IAAI,GAAG;IACZ;EACF;EAEA,OAAOA,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMY,OAAO,GAAIjB,WAAW,IAAMD,QAAQ,IAAK;EAC7C,OAAO;IACL;AACJ;AACA;AACA;IACIc,MAAMA,CAAEK,KAAK,EAAE;MACb,OAAOL,MAAM,CAACK,KAAK,EAAEnB,QAAQ,EAAEC,WAAW,CAAC;IAC7C,CAAC;IACD;AACJ;AACA;AACA;IACIH,MAAMA,CAAEqB,KAAK,EAAE;MACb,OAAOrB,MAAM,CAACqB,KAAK,EAAEnB,QAAQ,EAAEC,WAAW,CAAC;IAC7C;EACF,CAAC;AACH,CAAC;AAEDmB,MAAM,CAACC,OAAO,GAAG;EAAEH;AAAQ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}