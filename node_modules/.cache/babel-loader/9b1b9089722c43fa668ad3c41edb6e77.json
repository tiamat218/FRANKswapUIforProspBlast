{"ast":null,"code":"import React,{createContext,useCallback,useEffect,useState}from'react';import{EN,languages}from'config/localization/languages';import translations from'config/localization/translations.json';import{LS_KEY,fetchLocale,getLanguageCodeFromLS}from'./helpers';import{jsx as _jsx}from\"react/jsx-runtime\";const initialState={isFetching:true,currentLanguage:EN};// Export the translations directly\nexport const languageMap=new Map();languageMap.set(EN.locale,translations);export const LanguageContext=/*#__PURE__*/createContext(undefined);export const LanguageProvider=_ref=>{let{children}=_ref;const[state,setState]=useState(()=>{const codeFromStorage=getLanguageCodeFromLS();return{...initialState,currentLanguage:languages[codeFromStorage]};});const{currentLanguage}=state;useEffect(()=>{const fetchInitialLocales=async()=>{const codeFromStorage=getLanguageCodeFromLS();if(codeFromStorage!==EN.locale){const enLocale=languageMap.get(EN.locale);const currentLocale=await fetchLocale(codeFromStorage);languageMap.set(codeFromStorage,{...enLocale,...currentLocale});}setState(prevState=>({...prevState,isFetching:false}));};fetchInitialLocales();},[setState]);const setLanguage=async language=>{if(!languageMap.has(language.locale)){setState(prevState=>({...prevState,isFetching:true}));const locale=await fetchLocale(language.locale);const enLocale=languageMap.get(EN.locale);// Merge the EN locale to ensure that any locale fetched has all the keys\nlanguageMap.set(language.locale,{...enLocale,...locale});localStorage.setItem(LS_KEY,language.locale);setState(prevState=>({...prevState,isFetching:false,currentLanguage:language}));}else{localStorage.setItem(LS_KEY,language.locale);setState(prevState=>({...prevState,isFetching:false,currentLanguage:language}));}};const translate=useCallback((key,data)=>{const translationSet=languageMap.has(currentLanguage.locale)?languageMap.get(currentLanguage.locale):languageMap.get(EN.locale);const translatedText=translationSet[key]||key;// Check the existence of at least one combination of %%, separated by 1 or more non space characters\nconst includesVariable=translatedText.match(/%\\S+?%/gm);if(includesVariable&&data){let interpolatedText=translatedText;Object.keys(data).forEach(dataKey=>{const templateKey=new RegExp(\"%\".concat(dataKey,\"%\"),'g');interpolatedText=interpolatedText.replace(templateKey,data[dataKey].toString());});return interpolatedText;}return translatedText;},[currentLanguage]);return/*#__PURE__*/_jsx(LanguageContext.Provider,{value:{...state,setLanguage,t:translate},children:children});};","map":{"version":3,"names":["React","createContext","useCallback","useEffect","useState","EN","languages","translations","LS_KEY","fetchLocale","getLanguageCodeFromLS","jsx","_jsx","initialState","isFetching","currentLanguage","languageMap","Map","set","locale","LanguageContext","undefined","LanguageProvider","_ref","children","state","setState","codeFromStorage","fetchInitialLocales","enLocale","get","currentLocale","prevState","setLanguage","language","has","localStorage","setItem","translate","key","data","translationSet","translatedText","includesVariable","match","interpolatedText","Object","keys","forEach","dataKey","templateKey","RegExp","concat","replace","toString","Provider","value","t"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/contexts/Localization/Provider.tsx"],"sourcesContent":["import React, { createContext, useCallback, useEffect, useState } from 'react'\r\nimport { Language } from '@pancakeswap/uikit'\r\nimport { EN, languages } from 'config/localization/languages'\r\nimport translations from 'config/localization/translations.json'\r\nimport { ContextApi, ContextData, ProviderState } from './types'\r\nimport { LS_KEY, fetchLocale, getLanguageCodeFromLS } from './helpers'\r\n\r\nconst initialState: ProviderState = {\r\n  isFetching: true,\r\n  currentLanguage: EN,\r\n}\r\n\r\n// Export the translations directly\r\nexport const languageMap = new Map<Language['locale'], Record<string, string>>()\r\nlanguageMap.set(EN.locale, translations)\r\n\r\nexport const LanguageContext = createContext<ContextApi>(undefined)\r\n\r\nexport const LanguageProvider: React.FC = ({ children }) => {\r\n  const [state, setState] = useState<ProviderState>(() => {\r\n    const codeFromStorage = getLanguageCodeFromLS()\r\n\r\n    return {\r\n      ...initialState,\r\n      currentLanguage: languages[codeFromStorage],\r\n    }\r\n  })\r\n  const { currentLanguage } = state\r\n\r\n  useEffect(() => {\r\n    const fetchInitialLocales = async () => {\r\n      const codeFromStorage = getLanguageCodeFromLS()\r\n\r\n      if (codeFromStorage !== EN.locale) {\r\n        const enLocale = languageMap.get(EN.locale)\r\n        const currentLocale = await fetchLocale(codeFromStorage)\r\n        languageMap.set(codeFromStorage, { ...enLocale, ...currentLocale })\r\n      }\r\n\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: false,\r\n      }))\r\n    }\r\n\r\n    fetchInitialLocales()\r\n  }, [setState])\r\n\r\n  const setLanguage = async (language: Language) => {\r\n    if (!languageMap.has(language.locale)) {\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: true,\r\n      }))\r\n\r\n      const locale = await fetchLocale(language.locale)\r\n      const enLocale = languageMap.get(EN.locale)\r\n\r\n      // Merge the EN locale to ensure that any locale fetched has all the keys\r\n      languageMap.set(language.locale, { ...enLocale, ...locale })\r\n      localStorage.setItem(LS_KEY, language.locale)\r\n\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: false,\r\n        currentLanguage: language,\r\n      }))\r\n    } else {\r\n      localStorage.setItem(LS_KEY, language.locale)\r\n      setState((prevState) => ({\r\n        ...prevState,\r\n        isFetching: false,\r\n        currentLanguage: language,\r\n      }))\r\n    }\r\n  }\r\n\r\n  const translate = useCallback(\r\n    (key: string, data?: ContextData) => {\r\n      const translationSet = languageMap.has(currentLanguage.locale)\r\n        ? languageMap.get(currentLanguage.locale)\r\n        : languageMap.get(EN.locale)\r\n      const translatedText = translationSet[key] || key\r\n\r\n      // Check the existence of at least one combination of %%, separated by 1 or more non space characters\r\n      const includesVariable = translatedText.match(/%\\S+?%/gm)\r\n\r\n      if (includesVariable && data) {\r\n        let interpolatedText = translatedText\r\n        Object.keys(data).forEach((dataKey) => {\r\n          const templateKey = new RegExp(`%${dataKey}%`, 'g')\r\n          interpolatedText = interpolatedText.replace(templateKey, data[dataKey].toString())\r\n        })\r\n\r\n        return interpolatedText\r\n      }\r\n\r\n      return translatedText\r\n    },\r\n    [currentLanguage],\r\n  )\r\n\r\n  return <LanguageContext.Provider value={{ ...state, setLanguage, t: translate }}>{children}</LanguageContext.Provider>\r\n}\r\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,aAAa,CAAEC,WAAW,CAAEC,SAAS,CAAEC,QAAQ,KAAQ,OAAO,CAE9E,OAASC,EAAE,CAAEC,SAAS,KAAQ,+BAA+B,CAC7D,MAAO,CAAAC,YAAY,KAAM,uCAAuC,CAEhE,OAASC,MAAM,CAAEC,WAAW,CAAEC,qBAAqB,KAAQ,WAAW,QAAAC,GAAA,IAAAC,IAAA,yBAEtE,KAAM,CAAAC,YAA2B,CAAG,CAClCC,UAAU,CAAE,IAAI,CAChBC,eAAe,CAAEV,EACnB,CAAC,CAED;AACA,MAAO,MAAM,CAAAW,WAAW,CAAG,GAAI,CAAAC,GAAG,CAA6C,CAAC,CAChFD,WAAW,CAACE,GAAG,CAACb,EAAE,CAACc,MAAM,CAAEZ,YAAY,CAAC,CAExC,MAAO,MAAM,CAAAa,eAAe,cAAGnB,aAAa,CAAaoB,SAAS,CAAC,CAEnE,MAAO,MAAM,CAAAC,gBAA0B,CAAGC,IAAA,EAAkB,IAAjB,CAAEC,QAAS,CAAC,CAAAD,IAAA,CACrD,KAAM,CAACE,KAAK,CAAEC,QAAQ,CAAC,CAAGtB,QAAQ,CAAgB,IAAM,CACtD,KAAM,CAAAuB,eAAe,CAAGjB,qBAAqB,CAAC,CAAC,CAE/C,MAAO,CACL,GAAGG,YAAY,CACfE,eAAe,CAAET,SAAS,CAACqB,eAAe,CAC5C,CAAC,CACH,CAAC,CAAC,CACF,KAAM,CAAEZ,eAAgB,CAAC,CAAGU,KAAK,CAEjCtB,SAAS,CAAC,IAAM,CACd,KAAM,CAAAyB,mBAAmB,CAAG,KAAAA,CAAA,GAAY,CACtC,KAAM,CAAAD,eAAe,CAAGjB,qBAAqB,CAAC,CAAC,CAE/C,GAAIiB,eAAe,GAAKtB,EAAE,CAACc,MAAM,CAAE,CACjC,KAAM,CAAAU,QAAQ,CAAGb,WAAW,CAACc,GAAG,CAACzB,EAAE,CAACc,MAAM,CAAC,CAC3C,KAAM,CAAAY,aAAa,CAAG,KAAM,CAAAtB,WAAW,CAACkB,eAAe,CAAC,CACxDX,WAAW,CAACE,GAAG,CAACS,eAAe,CAAE,CAAE,GAAGE,QAAQ,CAAE,GAAGE,aAAc,CAAC,CAAC,CACrE,CAEAL,QAAQ,CAAEM,SAAS,GAAM,CACvB,GAAGA,SAAS,CACZlB,UAAU,CAAE,KACd,CAAC,CAAC,CAAC,CACL,CAAC,CAEDc,mBAAmB,CAAC,CAAC,CACvB,CAAC,CAAE,CAACF,QAAQ,CAAC,CAAC,CAEd,KAAM,CAAAO,WAAW,CAAG,KAAO,CAAAC,QAAkB,EAAK,CAChD,GAAI,CAAClB,WAAW,CAACmB,GAAG,CAACD,QAAQ,CAACf,MAAM,CAAC,CAAE,CACrCO,QAAQ,CAAEM,SAAS,GAAM,CACvB,GAAGA,SAAS,CACZlB,UAAU,CAAE,IACd,CAAC,CAAC,CAAC,CAEH,KAAM,CAAAK,MAAM,CAAG,KAAM,CAAAV,WAAW,CAACyB,QAAQ,CAACf,MAAM,CAAC,CACjD,KAAM,CAAAU,QAAQ,CAAGb,WAAW,CAACc,GAAG,CAACzB,EAAE,CAACc,MAAM,CAAC,CAE3C;AACAH,WAAW,CAACE,GAAG,CAACgB,QAAQ,CAACf,MAAM,CAAE,CAAE,GAAGU,QAAQ,CAAE,GAAGV,MAAO,CAAC,CAAC,CAC5DiB,YAAY,CAACC,OAAO,CAAC7B,MAAM,CAAE0B,QAAQ,CAACf,MAAM,CAAC,CAE7CO,QAAQ,CAAEM,SAAS,GAAM,CACvB,GAAGA,SAAS,CACZlB,UAAU,CAAE,KAAK,CACjBC,eAAe,CAAEmB,QACnB,CAAC,CAAC,CAAC,CACL,CAAC,IAAM,CACLE,YAAY,CAACC,OAAO,CAAC7B,MAAM,CAAE0B,QAAQ,CAACf,MAAM,CAAC,CAC7CO,QAAQ,CAAEM,SAAS,GAAM,CACvB,GAAGA,SAAS,CACZlB,UAAU,CAAE,KAAK,CACjBC,eAAe,CAAEmB,QACnB,CAAC,CAAC,CAAC,CACL,CACF,CAAC,CAED,KAAM,CAAAI,SAAS,CAAGpC,WAAW,CAC3B,CAACqC,GAAW,CAAEC,IAAkB,GAAK,CACnC,KAAM,CAAAC,cAAc,CAAGzB,WAAW,CAACmB,GAAG,CAACpB,eAAe,CAACI,MAAM,CAAC,CAC1DH,WAAW,CAACc,GAAG,CAACf,eAAe,CAACI,MAAM,CAAC,CACvCH,WAAW,CAACc,GAAG,CAACzB,EAAE,CAACc,MAAM,CAAC,CAC9B,KAAM,CAAAuB,cAAc,CAAGD,cAAc,CAACF,GAAG,CAAC,EAAIA,GAAG,CAEjD;AACA,KAAM,CAAAI,gBAAgB,CAAGD,cAAc,CAACE,KAAK,CAAC,UAAU,CAAC,CAEzD,GAAID,gBAAgB,EAAIH,IAAI,CAAE,CAC5B,GAAI,CAAAK,gBAAgB,CAAGH,cAAc,CACrCI,MAAM,CAACC,IAAI,CAACP,IAAI,CAAC,CAACQ,OAAO,CAAEC,OAAO,EAAK,CACrC,KAAM,CAAAC,WAAW,CAAG,GAAI,CAAAC,MAAM,KAAAC,MAAA,CAAKH,OAAO,MAAK,GAAG,CAAC,CACnDJ,gBAAgB,CAAGA,gBAAgB,CAACQ,OAAO,CAACH,WAAW,CAAEV,IAAI,CAACS,OAAO,CAAC,CAACK,QAAQ,CAAC,CAAC,CAAC,CACpF,CAAC,CAAC,CAEF,MAAO,CAAAT,gBAAgB,CACzB,CAEA,MAAO,CAAAH,cAAc,CACvB,CAAC,CACD,CAAC3B,eAAe,CAClB,CAAC,CAED,mBAAOH,IAAA,CAACQ,eAAe,CAACmC,QAAQ,EAACC,KAAK,CAAE,CAAE,GAAG/B,KAAK,CAAEQ,WAAW,CAAEwB,CAAC,CAAEnB,SAAU,CAAE,CAAAd,QAAA,CAAEA,QAAQ,CAA2B,CAAC,CACxH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module"}