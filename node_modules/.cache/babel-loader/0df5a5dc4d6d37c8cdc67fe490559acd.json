{"ast":null,"code":"import{useEffect,useMemo,useRef}from'react';import{useDispatch,useSelector}from'react-redux';import useActiveWeb3React from'hooks/useActiveWeb3React';import{useMulticallContract}from'../../hooks/useContract';import useDebounce from'../../hooks/useDebounce';import{CancelledError,retry,RetryableError}from'./retry';import{useBlockNumber}from'../application/hooks';import{errorFetchingMulticallResults,fetchingMulticallResults,parseCallKey,updateMulticallResults}from'./actions';import chunkArray from'./chunkArray';// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE=500;/**\r\n * Fetches a chunk of calls, enforcing a minimum block number constraint\r\n * @param multicallContract multicall contract to fetch against\r\n * @param chunk chunk of calls to make\r\n * @param minBlockNumber minimum block number of the result set\r\n */async function fetchChunk(multicallContract,chunk,minBlockNumber){console.debug('Fetching chunk',multicallContract,chunk,minBlockNumber);let resultsBlockNumber;let returnData;try{// prettier-ignore\n[resultsBlockNumber,returnData]=await multicallContract.aggregate(chunk.map(obj=>[obj.address,obj.callData]));}catch(error){console.debug('Failed to fetch chunk inside retry',error);throw error;}if(resultsBlockNumber.toNumber()<minBlockNumber){console.debug(\"Fetched results for old block number: \".concat(resultsBlockNumber.toString(),\" vs. \").concat(minBlockNumber));throw new RetryableError('Fetched for old block number');}return{results:returnData,blockNumber:resultsBlockNumber.toNumber()};}/**\r\n * From the current all listeners state, return each call key mapped to the\r\n * minimum number of blocks per fetch. This is how often each key must be fetched.\r\n * @param allListeners the all listeners state\r\n * @param chainId the current chain id\r\n */export function activeListeningKeys(allListeners,chainId){if(!allListeners||!chainId)return{};const listeners=allListeners[chainId];if(!listeners)return{};return Object.keys(listeners).reduce((memo,callKey)=>{const keyListeners=listeners[callKey];memo[callKey]=Object.keys(keyListeners).filter(key=>{const blocksPerFetch=parseInt(key);if(blocksPerFetch<=0)return false;return keyListeners[blocksPerFetch]>0;}).reduce((previousMin,current)=>{return Math.min(previousMin,parseInt(current));},Infinity);return memo;},{});}/**\r\n * Return the keys that need to be refetched\r\n * @param callResults current call result state\r\n * @param listeningKeys each call key mapped to how old the data can be in blocks\r\n * @param chainId the current chain id\r\n * @param latestBlockNumber the latest block number\r\n */export function outdatedListeningKeys(callResults,listeningKeys,chainId,latestBlockNumber){if(!chainId||!latestBlockNumber)return[];const results=callResults[chainId];// no results at all, load everything\nif(!results)return Object.keys(listeningKeys);return Object.keys(listeningKeys).filter(callKey=>{const blocksPerFetch=listeningKeys[callKey];const data=callResults[chainId][callKey];// no data, must fetch\nif(!data)return true;const minDataBlockNumber=latestBlockNumber-(blocksPerFetch-1);// already fetching it for a recent enough block, don't refetch it\nif(data.fetchingBlockNumber&&data.fetchingBlockNumber>=minDataBlockNumber)return false;// if data is older than minDataBlockNumber, fetch it\nreturn!data.blockNumber||data.blockNumber<minDataBlockNumber;});}export default function Updater(){const dispatch=useDispatch();const state=useSelector(s=>s.multicall);// wait for listeners to settle before triggering updates\nconst debouncedListeners=useDebounce(state.callListeners,100);const latestBlockNumber=useBlockNumber();const{chainId}=useActiveWeb3React();const multicallContract=useMulticallContract();const cancellations=useRef();const listeningKeys=useMemo(()=>{return activeListeningKeys(debouncedListeners,chainId);},[debouncedListeners,chainId]);const unserializedOutdatedCallKeys=useMemo(()=>{return outdatedListeningKeys(state.callResults,listeningKeys,chainId,latestBlockNumber);},[chainId,state.callResults,listeningKeys,latestBlockNumber]);const serializedOutdatedCallKeys=useMemo(()=>JSON.stringify(unserializedOutdatedCallKeys.sort()),[unserializedOutdatedCallKeys]);useEffect(()=>{var _cancellations$curren;if(!latestBlockNumber||!chainId||!multicallContract)return;const outdatedCallKeys=JSON.parse(serializedOutdatedCallKeys);if(outdatedCallKeys.length===0)return;const calls=outdatedCallKeys.map(key=>parseCallKey(key));const chunkedCalls=chunkArray(calls,CALL_CHUNK_SIZE);if(((_cancellations$curren=cancellations.current)===null||_cancellations$curren===void 0?void 0:_cancellations$curren.blockNumber)!==latestBlockNumber){var _cancellations$curren2,_cancellations$curren3;(_cancellations$curren2=cancellations.current)===null||_cancellations$curren2===void 0?void 0:(_cancellations$curren3=_cancellations$curren2.cancellations)===null||_cancellations$curren3===void 0?void 0:_cancellations$curren3.forEach(c=>c());}dispatch(fetchingMulticallResults({calls,chainId,fetchingBlockNumber:latestBlockNumber}));cancellations.current={blockNumber:latestBlockNumber,cancellations:chunkedCalls.map((chunk,index)=>{const{cancel,promise}=retry(()=>fetchChunk(multicallContract,chunk,latestBlockNumber),{n:Infinity,minWait:2500,maxWait:3500});promise.then(_ref=>{let{results:returnData,blockNumber:fetchBlockNumber}=_ref;cancellations.current={cancellations:[],blockNumber:latestBlockNumber};// accumulates the length of all previous indices\nconst firstCallKeyIndex=chunkedCalls.slice(0,index).reduce((memo,curr)=>memo+curr.length,0);const lastCallKeyIndex=firstCallKeyIndex+returnData.length;dispatch(updateMulticallResults({chainId,results:outdatedCallKeys.slice(firstCallKeyIndex,lastCallKeyIndex).reduce((memo,callKey,i)=>{var _returnData$i;memo[callKey]=(_returnData$i=returnData[i])!==null&&_returnData$i!==void 0?_returnData$i:null;return memo;},{}),blockNumber:fetchBlockNumber}));}).catch(error=>{if(error instanceof CancelledError){console.debug('Cancelled fetch for blockNumber',latestBlockNumber);return;}console.error('Failed to fetch multicall chunk',chunk,chainId,error);dispatch(errorFetchingMulticallResults({calls:chunk,chainId,fetchingBlockNumber:latestBlockNumber}));});return cancel;})};},[chainId,multicallContract,dispatch,serializedOutdatedCallKeys,latestBlockNumber]);return null;}","map":{"version":3,"names":["useEffect","useMemo","useRef","useDispatch","useSelector","useActiveWeb3React","useMulticallContract","useDebounce","CancelledError","retry","RetryableError","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","chunkArray","CALL_CHUNK_SIZE","fetchChunk","multicallContract","chunk","minBlockNumber","console","debug","resultsBlockNumber","returnData","aggregate","map","obj","address","callData","error","toNumber","concat","toString","results","blockNumber","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","Math","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","data","minDataBlockNumber","fetchingBlockNumber","Updater","dispatch","state","s","multicall","debouncedListeners","callListeners","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","_cancellations$curren","outdatedCallKeys","parse","length","calls","chunkedCalls","_cancellations$curren2","_cancellations$curren3","forEach","c","index","cancel","promise","n","minWait","maxWait","then","_ref","fetchBlockNumber","firstCallKeyIndex","slice","curr","lastCallKeyIndex","i","_returnData$i","catch"],"sources":["C:/Users/frkul/Documents/swapUI_pancake-frontend/src/state/multicall/updater.tsx"],"sourcesContent":["import { Contract } from '@ethersproject/contracts'\r\nimport { useEffect, useMemo, useRef } from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport { useMulticallContract } from '../../hooks/useContract'\r\nimport useDebounce from '../../hooks/useDebounce'\r\nimport { CancelledError, retry, RetryableError } from './retry'\r\nimport { useBlockNumber } from '../application/hooks'\r\nimport { AppDispatch, AppState } from '../index'\r\nimport {\r\n  Call,\r\n  errorFetchingMulticallResults,\r\n  fetchingMulticallResults,\r\n  parseCallKey,\r\n  updateMulticallResults,\r\n} from './actions'\r\nimport chunkArray from './chunkArray'\r\n\r\n// chunk calls so we do not exceed the gas limit\r\nconst CALL_CHUNK_SIZE = 500\r\n\r\n/**\r\n * Fetches a chunk of calls, enforcing a minimum block number constraint\r\n * @param multicallContract multicall contract to fetch against\r\n * @param chunk chunk of calls to make\r\n * @param minBlockNumber minimum block number of the result set\r\n */\r\nasync function fetchChunk(\r\n  multicallContract: Contract,\r\n  chunk: Call[],\r\n  minBlockNumber: number,\r\n): Promise<{ results: string[]; blockNumber: number }> {\r\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\r\n  let resultsBlockNumber\r\n  let returnData\r\n  try {\r\n    // prettier-ignore\r\n    [resultsBlockNumber, returnData] = await multicallContract.aggregate(\r\n      chunk.map((obj) => [obj.address, obj.callData])\r\n    )\r\n  } catch (error) {\r\n    console.debug('Failed to fetch chunk inside retry', error)\r\n    throw error\r\n  }\r\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\r\n    console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\r\n    throw new RetryableError('Fetched for old block number')\r\n  }\r\n  return { results: returnData, blockNumber: resultsBlockNumber.toNumber() }\r\n}\r\n\r\n/**\r\n * From the current all listeners state, return each call key mapped to the\r\n * minimum number of blocks per fetch. This is how often each key must be fetched.\r\n * @param allListeners the all listeners state\r\n * @param chainId the current chain id\r\n */\r\nexport function activeListeningKeys(\r\n  allListeners: AppState['multicall']['callListeners'],\r\n  chainId?: number,\r\n): { [callKey: string]: number } {\r\n  if (!allListeners || !chainId) return {}\r\n  const listeners = allListeners[chainId]\r\n  if (!listeners) return {}\r\n\r\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\r\n    const keyListeners = listeners[callKey]\r\n\r\n    memo[callKey] = Object.keys(keyListeners)\r\n      .filter((key) => {\r\n        const blocksPerFetch = parseInt(key)\r\n        if (blocksPerFetch <= 0) return false\r\n        return keyListeners[blocksPerFetch] > 0\r\n      })\r\n      .reduce((previousMin, current) => {\r\n        return Math.min(previousMin, parseInt(current))\r\n      }, Infinity)\r\n    return memo\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Return the keys that need to be refetched\r\n * @param callResults current call result state\r\n * @param listeningKeys each call key mapped to how old the data can be in blocks\r\n * @param chainId the current chain id\r\n * @param latestBlockNumber the latest block number\r\n */\r\nexport function outdatedListeningKeys(\r\n  callResults: AppState['multicall']['callResults'],\r\n  listeningKeys: { [callKey: string]: number },\r\n  chainId: number | undefined,\r\n  latestBlockNumber: number | undefined,\r\n): string[] {\r\n  if (!chainId || !latestBlockNumber) return []\r\n  const results = callResults[chainId]\r\n  // no results at all, load everything\r\n  if (!results) return Object.keys(listeningKeys)\r\n\r\n  return Object.keys(listeningKeys).filter((callKey) => {\r\n    const blocksPerFetch = listeningKeys[callKey]\r\n\r\n    const data = callResults[chainId][callKey]\r\n    // no data, must fetch\r\n    if (!data) return true\r\n\r\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\r\n\r\n    // already fetching it for a recent enough block, don't refetch it\r\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\r\n\r\n    // if data is older than minDataBlockNumber, fetch it\r\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\r\n  })\r\n}\r\n\r\nexport default function Updater(): null {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  const state = useSelector<AppState, AppState['multicall']>((s) => s.multicall)\r\n  // wait for listeners to settle before triggering updates\r\n  const debouncedListeners = useDebounce(state.callListeners, 100)\r\n  const latestBlockNumber = useBlockNumber()\r\n  const { chainId } = useActiveWeb3React()\r\n  const multicallContract = useMulticallContract()\r\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\r\n\r\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\r\n    return activeListeningKeys(debouncedListeners, chainId)\r\n  }, [debouncedListeners, chainId])\r\n\r\n  const unserializedOutdatedCallKeys = useMemo(() => {\r\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\r\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\r\n\r\n  const serializedOutdatedCallKeys = useMemo(\r\n    () => JSON.stringify(unserializedOutdatedCallKeys.sort()),\r\n    [unserializedOutdatedCallKeys],\r\n  )\r\n\r\n  useEffect(() => {\r\n    if (!latestBlockNumber || !chainId || !multicallContract) return\r\n\r\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\r\n    if (outdatedCallKeys.length === 0) return\r\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key))\r\n\r\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE)\r\n\r\n    if (cancellations.current?.blockNumber !== latestBlockNumber) {\r\n      cancellations.current?.cancellations?.forEach((c) => c())\r\n    }\r\n\r\n    dispatch(\r\n      fetchingMulticallResults({\r\n        calls,\r\n        chainId,\r\n        fetchingBlockNumber: latestBlockNumber,\r\n      }),\r\n    )\r\n\r\n    cancellations.current = {\r\n      blockNumber: latestBlockNumber,\r\n      cancellations: chunkedCalls.map((chunk, index) => {\r\n        const { cancel, promise } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\r\n          n: Infinity,\r\n          minWait: 2500,\r\n          maxWait: 3500,\r\n        })\r\n        promise\r\n          .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {\r\n            cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\r\n\r\n            // accumulates the length of all previous indices\r\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\r\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length\r\n\r\n            dispatch(\r\n              updateMulticallResults({\r\n                chainId,\r\n                results: outdatedCallKeys\r\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\r\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\r\n                    memo[callKey] = returnData[i] ?? null\r\n                    return memo\r\n                  }, {}),\r\n                blockNumber: fetchBlockNumber,\r\n              }),\r\n            )\r\n          })\r\n          .catch((error: any) => {\r\n            if (error instanceof CancelledError) {\r\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber)\r\n              return\r\n            }\r\n            console.error('Failed to fetch multicall chunk', chunk, chainId, error)\r\n            dispatch(\r\n              errorFetchingMulticallResults({\r\n                calls: chunk,\r\n                chainId,\r\n                fetchingBlockNumber: latestBlockNumber,\r\n              }),\r\n            )\r\n          })\r\n        return cancel\r\n      }),\r\n    }\r\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\r\n\r\n  return null\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}