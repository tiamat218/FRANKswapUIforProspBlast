{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { JSBI, Percent, Router, TradeType } from '@pancakeswap/sdk';\nimport { useMemo } from 'react';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { BIPS_BASE, INITIAL_ALLOWED_SLIPPAGE } from '../config/constants';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { calculateGasMargin, getRouterContract, isAddress, shortenAddress } from '../utils';\nimport isZero from '../utils/isZero';\nimport useTransactionDeadline from './useTransactionDeadline';\nimport useENS from './ENS/useENS';\nexport let SwapCallbackState;\n\n(function (SwapCallbackState) {\n  SwapCallbackState[SwapCallbackState[\"INVALID\"] = 0] = \"INVALID\";\n  SwapCallbackState[SwapCallbackState[\"LOADING\"] = 1] = \"LOADING\";\n  SwapCallbackState[SwapCallbackState[\"VALID\"] = 2] = \"VALID\";\n})(SwapCallbackState || (SwapCallbackState = {}));\n\n/**\r\n * Returns the swap calls that can be used to make the trade\r\n * @param trade trade to execute\r\n * @param allowedSlippage user allowed slippage\r\n * @param recipientAddressOrName\r\n */\nfunction useSwapCallArguments(trade, // trade to execute, required\nallowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips\nrecipientAddressOrName) {\n  _s();\n\n  const {\n    account,\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const {\n    address: recipientAddress\n  } = useENS(recipientAddressOrName);\n  const recipient = recipientAddressOrName === null ? account : recipientAddress;\n  const deadline = useTransactionDeadline();\n  return useMemo(() => {\n    if (!trade || !recipient || !library || !account || !chainId || !deadline) return [];\n    const contract = getRouterContract(chainId, library, account);\n\n    if (!contract) {\n      return [];\n    }\n\n    const swapMethods = [];\n    swapMethods.push(Router.swapCallParameters(trade, {\n      feeOnTransfer: false,\n      allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\n      recipient,\n      deadline: deadline.toNumber()\n    }));\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      swapMethods.push(Router.swapCallParameters(trade, {\n        feeOnTransfer: true,\n        allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\n        recipient,\n        deadline: deadline.toNumber()\n      }));\n    }\n\n    return swapMethods.map(parameters => ({\n      parameters,\n      contract\n    }));\n  }, [account, allowedSlippage, chainId, deadline, library, recipient, trade]);\n} // returns a function that will execute a swap, if the parameters are all valid\n// and the user has approved the slippage adjusted input amount for the trade\n\n\n_s(useSwapCallArguments, \"s8HoqurgUOlyu7X09x9CGKHKngs=\", false, function () {\n  return [useActiveWeb3React, useENS, useTransactionDeadline];\n});\n\nexport function useSwapCallback(trade, // trade to execute, required\nallowedSlippage = INITIAL_ALLOWED_SLIPPAGE, // in bips\nrecipientAddressOrName) {\n  _s2();\n\n  const {\n    account,\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const swapCalls = useSwapCallArguments(trade, allowedSlippage, recipientAddressOrName);\n  const addTransaction = useTransactionAdder();\n  const {\n    address: recipientAddress\n  } = useENS(recipientAddressOrName);\n  const recipient = recipientAddressOrName === null ? account : recipientAddress;\n  return useMemo(() => {\n    if (!trade || !library || !account || !chainId) {\n      return {\n        state: SwapCallbackState.INVALID,\n        callback: null,\n        error: 'Missing dependencies'\n      };\n    }\n\n    if (!recipient) {\n      if (recipientAddressOrName !== null) {\n        return {\n          state: SwapCallbackState.INVALID,\n          callback: null,\n          error: 'Invalid recipient'\n        };\n      }\n\n      return {\n        state: SwapCallbackState.LOADING,\n        callback: null,\n        error: null\n      };\n    }\n\n    return {\n      state: SwapCallbackState.VALID,\n      callback: async function onSwap() {\n        const estimatedCalls = await Promise.all(swapCalls.map(call => {\n          const {\n            parameters: {\n              methodName,\n              args,\n              value\n            },\n            contract\n          } = call;\n          const options = !value || isZero(value) ? {} : {\n            value\n          };\n          return contract.estimateGas[methodName](...args, options).then(gasEstimate => {\n            return {\n              call,\n              gasEstimate\n            };\n          }).catch(gasError => {\n            console.error('Gas estimate failed, trying eth_call to extract error', call);\n            return contract.callStatic[methodName](...args, options).then(result => {\n              console.error('Unexpected successful call after failed estimate gas', call, gasError, result);\n              return {\n                call,\n                error: new Error('Unexpected issue with estimating the gas. Please try again.')\n              };\n            }).catch(callError => {\n              var _callError$data;\n\n              console.error('Call threw error', call, callError);\n              const reason = callError.reason || ((_callError$data = callError.data) === null || _callError$data === void 0 ? void 0 : _callError$data.message) || callError.message;\n              const errorMessage = `The transaction cannot succeed due to error: ${reason !== null && reason !== void 0 ? reason : 'Unknown error, check the logs'}.`;\n              return {\n                call,\n                error: new Error(errorMessage)\n              };\n            });\n          });\n        })); // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\n\n        const successfulEstimation = estimatedCalls.find((el, ix, list) => 'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]));\n\n        if (!successfulEstimation) {\n          const errorCalls = estimatedCalls.filter(call => 'error' in call);\n          if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error;\n          throw new Error('Unexpected error. Please contact support: none of the calls threw an error');\n        }\n\n        const {\n          call: {\n            contract,\n            parameters: {\n              methodName,\n              args,\n              value\n            }\n          },\n          gasEstimate\n        } = successfulEstimation;\n        return contract[methodName](...args, {\n          gasLimit: calculateGasMargin(gasEstimate),\n          ...(value && !isZero(value) ? {\n            value,\n            from: account\n          } : {\n            from: account\n          })\n        }).then(response => {\n          const inputSymbol = trade.inputAmount.currency.symbol;\n          const outputSymbol = trade.outputAmount.currency.symbol;\n          const inputAmount = trade.inputAmount.toSignificant(3);\n          const outputAmount = trade.outputAmount.toSignificant(3);\n          const base = `Swap ${inputAmount} ${inputSymbol} for ${outputAmount} ${outputSymbol}`;\n          const withRecipient = recipient === account ? base : `${base} to ${recipientAddressOrName && isAddress(recipientAddressOrName) ? shortenAddress(recipientAddressOrName) : recipientAddressOrName}`;\n          addTransaction(response, {\n            summary: withRecipient\n          });\n          return response.hash;\n        }).catch(error => {\n          // if the user rejected the tx, pass this along\n          if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {\n            throw new Error('Transaction rejected.');\n          } else {\n            // otherwise, the error was unexpected and we need to convey that\n            console.error(`Swap failed`, error, methodName, args, value);\n            throw new Error(`Swap failed: ${error.message}`);\n          }\n        });\n      },\n      error: null\n    };\n  }, [trade, library, account, chainId, recipient, recipientAddressOrName, swapCalls, addTransaction]);\n}\n\n_s2(useSwapCallback, \"G8+T55P1ph4OGYQvDIdQ9DZmL+I=\", false, function () {\n  return [useActiveWeb3React, useSwapCallArguments, useTransactionAdder, useENS];\n});","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/hooks/useSwapCallback.ts"],"names":["JSBI","Percent","Router","TradeType","useMemo","useActiveWeb3React","BIPS_BASE","INITIAL_ALLOWED_SLIPPAGE","useTransactionAdder","calculateGasMargin","getRouterContract","isAddress","shortenAddress","isZero","useTransactionDeadline","useENS","SwapCallbackState","useSwapCallArguments","trade","allowedSlippage","recipientAddressOrName","account","chainId","library","address","recipientAddress","recipient","deadline","contract","swapMethods","push","swapCallParameters","feeOnTransfer","BigInt","toNumber","tradeType","EXACT_INPUT","map","parameters","useSwapCallback","swapCalls","addTransaction","state","INVALID","callback","error","LOADING","VALID","onSwap","estimatedCalls","Promise","all","call","methodName","args","value","options","estimateGas","then","gasEstimate","catch","gasError","console","callStatic","result","Error","callError","reason","data","message","errorMessage","successfulEstimation","find","el","ix","list","length","errorCalls","filter","gasLimit","from","response","inputSymbol","inputAmount","currency","symbol","outputSymbol","outputAmount","toSignificant","base","withRecipient","summary","hash","code"],"mappings":"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","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber'\r\nimport { Contract } from '@ethersproject/contracts'\r\nimport { JSBI, Percent, Router, SwapParameters, Trade, TradeType } from '@pancakeswap/sdk'\r\nimport { useMemo } from 'react'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport { BIPS_BASE, INITIAL_ALLOWED_SLIPPAGE } from '../config/constants'\r\nimport { useTransactionAdder } from '../state/transactions/hooks'\r\nimport { calculateGasMargin, getRouterContract, isAddress, shortenAddress } from '../utils'\r\nimport isZero from '../utils/isZero'\r\nimport useTransactionDeadline from './useTransactionDeadline'\r\nimport useENS from './ENS/useENS'\r\n\r\nexport enum SwapCallbackState {\r\n  INVALID,\r\n  LOADING,\r\n  VALID,\r\n}\r\n\r\ninterface SwapCall {\r\n  contract: Contract\r\n  parameters: SwapParameters\r\n}\r\n\r\ninterface SuccessfulCall {\r\n  call: SwapCall\r\n  gasEstimate: BigNumber\r\n}\r\n\r\ninterface FailedCall {\r\n  call: SwapCall\r\n  error: Error\r\n}\r\n\r\ntype EstimatedSwapCall = SuccessfulCall | FailedCall\r\n\r\n/**\r\n * Returns the swap calls that can be used to make the trade\r\n * @param trade trade to execute\r\n * @param allowedSlippage user allowed slippage\r\n * @param recipientAddressOrName\r\n */\r\nfunction useSwapCallArguments(\r\n  trade: Trade | undefined, // trade to execute, required\r\n  allowedSlippage: number = INITIAL_ALLOWED_SLIPPAGE, // in bips\r\n  recipientAddressOrName: string | null, // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\r\n): SwapCall[] {\r\n  const { account, chainId, library } = useActiveWeb3React()\r\n\r\n  const { address: recipientAddress } = useENS(recipientAddressOrName)\r\n  const recipient = recipientAddressOrName === null ? account : recipientAddress\r\n  const deadline = useTransactionDeadline()\r\n\r\n  return useMemo(() => {\r\n    if (!trade || !recipient || !library || !account || !chainId || !deadline) return []\r\n\r\n    const contract: Contract | null = getRouterContract(chainId, library, account)\r\n    if (!contract) {\r\n      return []\r\n    }\r\n\r\n    const swapMethods = []\r\n\r\n    swapMethods.push(\r\n      Router.swapCallParameters(trade, {\r\n        feeOnTransfer: false,\r\n        allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\r\n        recipient,\r\n        deadline: deadline.toNumber(),\r\n      }),\r\n    )\r\n\r\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\r\n      swapMethods.push(\r\n        Router.swapCallParameters(trade, {\r\n          feeOnTransfer: true,\r\n          allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\r\n          recipient,\r\n          deadline: deadline.toNumber(),\r\n        }),\r\n      )\r\n    }\r\n\r\n    return swapMethods.map((parameters) => ({ parameters, contract }))\r\n  }, [account, allowedSlippage, chainId, deadline, library, recipient, trade])\r\n}\r\n\r\n// returns a function that will execute a swap, if the parameters are all valid\r\n// and the user has approved the slippage adjusted input amount for the trade\r\nexport function useSwapCallback(\r\n  trade: Trade | undefined, // trade to execute, required\r\n  allowedSlippage: number = INITIAL_ALLOWED_SLIPPAGE, // in bips\r\n  recipientAddressOrName: string | null, // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\r\n): { state: SwapCallbackState; callback: null | (() => Promise<string>); error: string | null } {\r\n  const { account, chainId, library } = useActiveWeb3React()\r\n\r\n  const swapCalls = useSwapCallArguments(trade, allowedSlippage, recipientAddressOrName)\r\n\r\n  const addTransaction = useTransactionAdder()\r\n\r\n  const { address: recipientAddress } = useENS(recipientAddressOrName)\r\n  const recipient = recipientAddressOrName === null ? account : recipientAddress\r\n\r\n  return useMemo(() => {\r\n    if (!trade || !library || !account || !chainId) {\r\n      return { state: SwapCallbackState.INVALID, callback: null, error: 'Missing dependencies' }\r\n    }\r\n    if (!recipient) {\r\n      if (recipientAddressOrName !== null) {\r\n        return { state: SwapCallbackState.INVALID, callback: null, error: 'Invalid recipient' }\r\n      }\r\n      return { state: SwapCallbackState.LOADING, callback: null, error: null }\r\n    }\r\n\r\n    return {\r\n      state: SwapCallbackState.VALID,\r\n      callback: async function onSwap(): Promise<string> {\r\n        const estimatedCalls: EstimatedSwapCall[] = await Promise.all(\r\n          swapCalls.map((call) => {\r\n            const {\r\n              parameters: { methodName, args, value },\r\n              contract,\r\n            } = call\r\n            const options = !value || isZero(value) ? {} : { value }\r\n\r\n            return contract.estimateGas[methodName](...args, options)\r\n              .then((gasEstimate) => {\r\n                return {\r\n                  call,\r\n                  gasEstimate,\r\n                }\r\n              })\r\n              .catch((gasError) => {\r\n                console.error('Gas estimate failed, trying eth_call to extract error', call)\r\n\r\n                return contract.callStatic[methodName](...args, options)\r\n                  .then((result) => {\r\n                    console.error('Unexpected successful call after failed estimate gas', call, gasError, result)\r\n                    return { call, error: new Error('Unexpected issue with estimating the gas. Please try again.') }\r\n                  })\r\n                  .catch((callError) => {\r\n                    console.error('Call threw error', call, callError)\r\n                    const reason: string = callError.reason || callError.data?.message || callError.message\r\n                    const errorMessage = `The transaction cannot succeed due to error: ${\r\n                      reason ?? 'Unknown error, check the logs'\r\n                    }.`\r\n\r\n                    return { call, error: new Error(errorMessage) }\r\n                  })\r\n              })\r\n          }),\r\n        )\r\n\r\n        // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\r\n        const successfulEstimation = estimatedCalls.find(\r\n          (el, ix, list): el is SuccessfulCall =>\r\n            'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]),\r\n        )\r\n\r\n        if (!successfulEstimation) {\r\n          const errorCalls = estimatedCalls.filter((call): call is FailedCall => 'error' in call)\r\n          if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error\r\n          throw new Error('Unexpected error. Please contact support: none of the calls threw an error')\r\n        }\r\n\r\n        const {\r\n          call: {\r\n            contract,\r\n            parameters: { methodName, args, value },\r\n          },\r\n          gasEstimate,\r\n        } = successfulEstimation\r\n\r\n        return contract[methodName](...args, {\r\n          gasLimit: calculateGasMargin(gasEstimate),\r\n          ...(value && !isZero(value) ? { value, from: account } : { from: account }),\r\n        })\r\n          .then((response: any) => {\r\n            const inputSymbol = trade.inputAmount.currency.symbol\r\n            const outputSymbol = trade.outputAmount.currency.symbol\r\n            const inputAmount = trade.inputAmount.toSignificant(3)\r\n            const outputAmount = trade.outputAmount.toSignificant(3)\r\n\r\n            const base = `Swap ${inputAmount} ${inputSymbol} for ${outputAmount} ${outputSymbol}`\r\n            const withRecipient =\r\n              recipient === account\r\n                ? base\r\n                : `${base} to ${\r\n                    recipientAddressOrName && isAddress(recipientAddressOrName)\r\n                      ? shortenAddress(recipientAddressOrName)\r\n                      : recipientAddressOrName\r\n                  }`\r\n\r\n            addTransaction(response, {\r\n              summary: withRecipient,\r\n            })\r\n\r\n            return response.hash\r\n          })\r\n          .catch((error: any) => {\r\n            // if the user rejected the tx, pass this along\r\n            if (error?.code === 4001) {\r\n              throw new Error('Transaction rejected.')\r\n            } else {\r\n              // otherwise, the error was unexpected and we need to convey that\r\n              console.error(`Swap failed`, error, methodName, args, value)\r\n              throw new Error(`Swap failed: ${error.message}`)\r\n            }\r\n          })\r\n      },\r\n      error: null,\r\n    }\r\n  }, [trade, library, account, chainId, recipient, recipientAddressOrName, swapCalls, addTransaction])\r\n}\r\n"]},"metadata":{},"sourceType":"module"}