{"ast":null,"code":"import _taggedTemplateLiteral from\"C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";var _templateObject;import{request,gql}from'graphql-request';import{GRAPH_API_LOTTERY}from'config/constants/endpoints';import{getRoundIdsArray,fetchMultipleLotteries,hasRoundBeenClaimed}from'./helpers';import{fetchUserTicketsForMultipleRounds}from'./getUserTicketsData';const applyNodeDataToUserGraphResponse=(userNodeData,userGraphData,lotteryNodeData)=>{//   If no graph rounds response - return node data\nif(userGraphData.length===0){return lotteryNodeData.map(nodeRound=>{const ticketDataForRound=userNodeData.find(roundTickets=>roundTickets.roundId===nodeRound.lotteryId);return{endTime:nodeRound.endTime,status:nodeRound.status,lotteryId:nodeRound.lotteryId.toString(),claimed:hasRoundBeenClaimed(ticketDataForRound.userTickets),totalTickets:\"\".concat(ticketDataForRound.userTickets.length.toString()),tickets:ticketDataForRound.userTickets};});}//   Else if there is a graph response - merge with node data where node data is more accurate\nconst mergedResponse=userGraphData.map((graphRound,index)=>{const nodeRound=lotteryNodeData[index];// if there is node data for this index, overwrite graph data. Otherwise - return graph data.\nif(nodeRound){const ticketDataForRound=userNodeData.find(roundTickets=>roundTickets.roundId===nodeRound.lotteryId);// if isLoading === true, there has been a node error - return graphRound\nif(!nodeRound.isLoading){return{endTime:nodeRound.endTime,status:nodeRound.status,lotteryId:nodeRound.lotteryId.toString(),claimed:hasRoundBeenClaimed(ticketDataForRound.userTickets),totalTickets:graphRound.totalTickets,tickets:ticketDataForRound.userTickets};}return graphRound;}return graphRound;});return mergedResponse;};const getGraphLotteryUser=async account=>{let user;const blankUser={account,totalCake:'',totalTickets:'',rounds:[]};try{const response=await request(GRAPH_API_LOTTERY,gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n        query getUserLotteries($account: ID!) {\\n          user(id: $account) {\\n            id\\n            totalTickets\\n            totalCake\\n            rounds(first: 100, orderDirection: desc, orderBy: block) {\\n              id\\n              lottery {\\n                id\\n                endTime\\n                status\\n              }\\n              claimed\\n              totalTickets\\n            }\\n          }\\n        }\\n      \"]))),{account:account.toLowerCase()});const userRes=response.user;// If no user returned - return blank user\nif(!userRes){user=blankUser;}else{user={account:userRes.id,totalCake:userRes.totalCake,totalTickets:userRes.totalTickets,rounds:userRes.rounds.map(round=>{var _round$lottery,_round$lottery2,_round$lottery3;return{lotteryId:round===null||round===void 0?void 0:(_round$lottery=round.lottery)===null||_round$lottery===void 0?void 0:_round$lottery.id,endTime:round===null||round===void 0?void 0:(_round$lottery2=round.lottery)===null||_round$lottery2===void 0?void 0:_round$lottery2.endTime,claimed:round===null||round===void 0?void 0:round.claimed,totalTickets:round===null||round===void 0?void 0:round.totalTickets,status:round===null||round===void 0?void 0:(_round$lottery3=round.lottery)===null||_round$lottery3===void 0?void 0:_round$lottery3.status};})};}}catch(error){console.error(error);user=blankUser;}return user;};const getUserLotteryData=async(account,currentLotteryId)=>{const idsForTicketsNodeCall=getRoundIdsArray(currentLotteryId);const roundDataAndUserTickets=await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall,account);const userRoundsNodeData=roundDataAndUserTickets.filter(round=>round.userTickets.length>0);const idsForLotteriesNodeCall=userRoundsNodeData.map(round=>round.roundId);const lotteriesNodeData=await fetchMultipleLotteries(idsForLotteriesNodeCall);const graphResponse=await getGraphLotteryUser(account);const mergedRoundData=applyNodeDataToUserGraphResponse(userRoundsNodeData,graphResponse.rounds,lotteriesNodeData);const graphResponseWithNodeRounds={...graphResponse,rounds:mergedRoundData};return graphResponseWithNodeRounds;};export default getUserLotteryData;","map":{"version":3,"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","hasRoundBeenClaimed","fetchUserTicketsForMultipleRounds","applyNodeDataToUserGraphResponse","userNodeData","userGraphData","lotteryNodeData","length","map","nodeRound","ticketDataForRound","find","roundTickets","roundId","lotteryId","endTime","status","toString","claimed","userTickets","totalTickets","concat","tickets","mergedResponse","graphRound","index","isLoading","getGraphLotteryUser","account","user","blankUser","totalCake","rounds","response","_templateObject","_taggedTemplateLiteral","toLowerCase","userRes","id","round","_round$lottery","_round$lottery2","_round$lottery3","lottery","error","console","getUserLotteryData","currentLotteryId","idsForTicketsNodeCall","roundDataAndUserTickets","userRoundsNodeData","filter","idsForLotteriesNodeCall","lotteriesNodeData","graphResponse","mergedRoundData","graphResponseWithNodeRounds"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/lottery/getUserLotteryData.ts"],"sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\r\nimport { LotteryTicket } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryResponse, UserRound } from 'state/types'\r\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed } from './helpers'\r\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\r\n\r\nconst applyNodeDataToUserGraphResponse = (\r\n  userNodeData: { roundId: string; userTickets: LotteryTicket[] }[],\r\n  userGraphData: UserRound[],\r\n  lotteryNodeData: LotteryResponse[],\r\n): UserRound[] => {\r\n  //   If no graph rounds response - return node data\r\n  if (userGraphData.length === 0) {\r\n    return lotteryNodeData.map((nodeRound) => {\r\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      return {\r\n        endTime: nodeRound.endTime,\r\n        status: nodeRound.status,\r\n        lotteryId: nodeRound.lotteryId.toString(),\r\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\r\n        tickets: ticketDataForRound.userTickets,\r\n      }\r\n    })\r\n  }\r\n\r\n  //   Else if there is a graph response - merge with node data where node data is more accurate\r\n  const mergedResponse = userGraphData.map((graphRound, index) => {\r\n    const nodeRound = lotteryNodeData[index]\r\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\r\n    if (nodeRound) {\r\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      // if isLoading === true, there has been a node error - return graphRound\r\n      if (!nodeRound.isLoading) {\r\n        return {\r\n          endTime: nodeRound.endTime,\r\n          status: nodeRound.status,\r\n          lotteryId: nodeRound.lotteryId.toString(),\r\n          claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n          totalTickets: graphRound.totalTickets,\r\n          tickets: ticketDataForRound.userTickets,\r\n        }\r\n      }\r\n      return graphRound\r\n    }\r\n    return graphRound\r\n  })\r\n  return mergedResponse\r\n}\r\n\r\nconst getGraphLotteryUser = async (account: string): Promise<LotteryUserGraphEntity> => {\r\n  let user\r\n  const blankUser = {\r\n    account,\r\n    totalCake: '',\r\n    totalTickets: '',\r\n    rounds: [],\r\n  }\r\n\r\n  try {\r\n    const response = await request(\r\n      GRAPH_API_LOTTERY,\r\n      gql`\r\n        query getUserLotteries($account: ID!) {\r\n          user(id: $account) {\r\n            id\r\n            totalTickets\r\n            totalCake\r\n            rounds(first: 100, orderDirection: desc, orderBy: block) {\r\n              id\r\n              lottery {\r\n                id\r\n                endTime\r\n                status\r\n              }\r\n              claimed\r\n              totalTickets\r\n            }\r\n          }\r\n        }\r\n      `,\r\n      { account: account.toLowerCase() },\r\n    )\r\n    const userRes = response.user\r\n\r\n    // If no user returned - return blank user\r\n    if (!userRes) {\r\n      user = blankUser\r\n    } else {\r\n      user = {\r\n        account: userRes.id,\r\n        totalCake: userRes.totalCake,\r\n        totalTickets: userRes.totalTickets,\r\n        rounds: userRes.rounds.map((round) => {\r\n          return {\r\n            lotteryId: round?.lottery?.id,\r\n            endTime: round?.lottery?.endTime,\r\n            claimed: round?.claimed,\r\n            totalTickets: round?.totalTickets,\r\n            status: round?.lottery?.status,\r\n          }\r\n        }),\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(error)\r\n    user = blankUser\r\n  }\r\n\r\n  return user\r\n}\r\n\r\nconst getUserLotteryData = async (account: string, currentLotteryId: string): Promise<LotteryUserGraphEntity> => {\r\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId)\r\n  const roundDataAndUserTickets = await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall, account)\r\n  const userRoundsNodeData = roundDataAndUserTickets.filter((round) => round.userTickets.length > 0)\r\n  const idsForLotteriesNodeCall = userRoundsNodeData.map((round) => round.roundId)\r\n\r\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall)\r\n  const graphResponse = await getGraphLotteryUser(account)\r\n  const mergedRoundData = applyNodeDataToUserGraphResponse(userRoundsNodeData, graphResponse.rounds, lotteriesNodeData)\r\n  const graphResponseWithNodeRounds = { ...graphResponse, rounds: mergedRoundData }\r\n  return graphResponseWithNodeRounds\r\n}\r\n\r\nexport default getUserLotteryData\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}