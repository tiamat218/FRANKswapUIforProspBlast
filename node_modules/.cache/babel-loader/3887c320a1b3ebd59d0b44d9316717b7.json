{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, removeMulticallListeners, parseCallKey, toCallKey } from './actions';\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(xi => isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg));\n}\nconst INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n};\n\n// use this options object\nexport const NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n};\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls, options) {\n  _s();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const callResults = useSelector(state => state.multicall.callResults);\n  const dispatch = useDispatch();\n  const serializedCallKeys = useMemo(() => {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(c => Boolean(c))) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]);\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const calls = callKeys.map(key => parseCallKey(key));\n    dispatch(addMulticallListeners({\n      chainId,\n      calls,\n      options\n    }));\n    return () => {\n      dispatch(removeMulticallListeners({\n        chainId,\n        calls,\n        options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(() => calls.map(call => {\n    var _callResults$chainId;\n    if (!chainId || !call) return INVALID_RESULT;\n    const result = (_callResults$chainId = callResults[chainId]) === null || _callResults$chainId === void 0 ? void 0 : _callResults$chainId[toCallKey(call)];\n    let data;\n    if ((result === null || result === void 0 ? void 0 : result.data) && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n      // eslint-disable-next-line prefer-destructuring\n      data = result.data;\n    }\n    return {\n      valid: true,\n      data,\n      blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n    };\n  }), [callResults, calls, chainId]);\n}\n_s(useCallsData, \"wfAl8Ey0eVorbPIKvJVE0ZbvRK4=\", false, function () {\n  return [useActiveWeb3React, useSelector, useDispatch];\n});\nconst INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nconst LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  const {\n    valid,\n    data,\n    blockNumber\n  } = callResult;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  const success = data && data.length > 2;\n  const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  let result;\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      };\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result,\n    error: !success\n  };\n}\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options) {\n  _s2();\n  const fragment = useMemo(() => {\n    var _contract$interface;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(inputs => {\n    return {\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    };\n  }) : [], [callInputs, contract, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));\n  }, [fragment, contract, results, latestBlockNumber]);\n}\n_s2(useSingleContractMultipleData, \"wqKdm+GSVZDiHjC/KX/lpl3BZbE=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {\n  _s3();\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\n  const callData = useMemo(() => fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined, [callInputs, contractInterface, fragment]);\n  const calls = useMemo(() => fragment && addresses && addresses.length > 0 && callData ? addresses.map(address => {\n    return address && callData ? {\n      address,\n      callData\n    } : undefined;\n  }) : [], [addresses, callData, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber));\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\n_s3(useMultipleContractSingleData, \"L2gBuYFIsXQlVxDNfOpFFd7DoVg=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});\nexport function useSingleCallResult(contract, methodName, inputs, options) {\n  _s4();\n  const fragment = useMemo(() => {\n    var _contract$interface2;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    }] : [];\n  }, [contract, fragment, inputs]);\n  const result = useCallsData(calls, options)[0];\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}\n_s4(useSingleCallResult, \"w3FP0tU2v530x+kbmRIp+PuTg70=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});","map":{"version":3,"names":["useEffect","useMemo","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","addMulticallListeners","removeMulticallListeners","parseCallKey","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","_s","chainId","callResults","state","multicall","dispatch","serializedCallKeys","_calls$filter$map$sor","_calls$filter","_calls$filter$map","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","_callResults$chainId","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","_s2","_contract$interface","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","_s3","useSingleCallResult","_s4","_contract$interface2"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/multicall/hooks.ts"],"sourcesContent":["import { Interface, FunctionFragment } from '@ethersproject/abi'\r\nimport { BigNumber } from '@ethersproject/bignumber'\r\nimport { Contract } from '@ethersproject/contracts'\r\nimport { useEffect, useMemo } from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport { useBlockNumber } from '../application/hooks'\r\nimport { AppDispatch, AppState } from '../index'\r\nimport {\r\n  addMulticallListeners,\r\n  Call,\r\n  removeMulticallListeners,\r\n  parseCallKey,\r\n  toCallKey,\r\n  ListenerOptions,\r\n} from './actions'\r\n\r\nexport interface Result extends ReadonlyArray<any> {\r\n  readonly [key: string]: any\r\n}\r\n\r\ntype MethodArg = string | number | BigNumber\r\ntype MethodArgs = Array<MethodArg | MethodArg[]>\r\n\r\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\r\n\r\nfunction isMethodArg(x: unknown): x is MethodArg {\r\n  return ['string', 'number'].indexOf(typeof x) !== -1\r\n}\r\n\r\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\r\n  return (\r\n    x === undefined ||\r\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\r\n  )\r\n}\r\n\r\ninterface CallResult {\r\n  readonly valid: boolean\r\n  readonly data: string | undefined\r\n  readonly blockNumber: number | undefined\r\n}\r\n\r\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\r\n\r\n// use this options object\r\nexport const NEVER_RELOAD: ListenerOptions = {\r\n  blocksPerFetch: Infinity,\r\n}\r\n\r\n// the lowest level call for subscribing to contract data\r\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\r\n  const { chainId } = useActiveWeb3React()\r\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(\r\n    (state) => state.multicall.callResults,\r\n  )\r\n  const dispatch = useDispatch<AppDispatch>()\r\n\r\n  const serializedCallKeys: string = useMemo(\r\n    () =>\r\n      JSON.stringify(\r\n        calls\r\n          ?.filter((c): c is Call => Boolean(c))\r\n          ?.map(toCallKey)\r\n          ?.sort() ?? [],\r\n      ),\r\n    [calls],\r\n  )\r\n\r\n  // update listeners when there is an actual change that persists for at least 100ms\r\n  useEffect(() => {\r\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\r\n    if (!chainId || callKeys.length === 0) return undefined\r\n    // eslint-disable-next-line @typescript-eslint/no-shadow\r\n    const calls = callKeys.map((key) => parseCallKey(key))\r\n    dispatch(\r\n      addMulticallListeners({\r\n        chainId,\r\n        calls,\r\n        options,\r\n      }),\r\n    )\r\n\r\n    return () => {\r\n      dispatch(\r\n        removeMulticallListeners({\r\n          chainId,\r\n          calls,\r\n          options,\r\n        }),\r\n      )\r\n    }\r\n  }, [chainId, dispatch, options, serializedCallKeys])\r\n\r\n  return useMemo(\r\n    () =>\r\n      calls.map<CallResult>((call) => {\r\n        if (!chainId || !call) return INVALID_RESULT\r\n\r\n        const result = callResults[chainId]?.[toCallKey(call)]\r\n        let data\r\n        if (result?.data && result?.data !== '0x') {\r\n          // eslint-disable-next-line prefer-destructuring\r\n          data = result.data\r\n        }\r\n\r\n        return { valid: true, data, blockNumber: result?.blockNumber }\r\n      }),\r\n    [callResults, calls, chainId],\r\n  )\r\n}\r\n\r\ninterface CallState {\r\n  readonly valid: boolean\r\n  // the result, or undefined if loading or errored/no data\r\n  readonly result: Result | undefined\r\n  // true if the result has never been fetched\r\n  readonly loading: boolean\r\n  // true if the result is not for the latest block\r\n  readonly syncing: boolean\r\n  // true if the call was made and is synced, but the return data is invalid\r\n  readonly error: boolean\r\n}\r\n\r\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\r\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\r\n\r\nfunction toCallState(\r\n  callResult: CallResult | undefined,\r\n  contractInterface: Interface | undefined,\r\n  fragment: FunctionFragment | undefined,\r\n  latestBlockNumber: number | undefined,\r\n): CallState {\r\n  if (!callResult) return INVALID_CALL_STATE\r\n  const { valid, data, blockNumber } = callResult\r\n  if (!valid) return INVALID_CALL_STATE\r\n  if (valid && !blockNumber) return LOADING_CALL_STATE\r\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\r\n  const success = data && data.length > 2\r\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\r\n  let result: Result | undefined\r\n  if (success && data) {\r\n    try {\r\n      result = contractInterface.decodeFunctionResult(fragment, data)\r\n    } catch (error) {\r\n      console.debug('Result data parsing failed', fragment, data)\r\n      return {\r\n        valid: true,\r\n        loading: false,\r\n        error: true,\r\n        syncing,\r\n        result,\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    valid: true,\r\n    loading: false,\r\n    syncing,\r\n    result,\r\n    error: !success,\r\n  }\r\n}\r\n\r\nexport function useSingleContractMultipleData(\r\n  contract: Contract | null | undefined,\r\n  methodName: string,\r\n  callInputs: OptionalMethodInputs[],\r\n  options?: ListenerOptions,\r\n): CallState[] {\r\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\r\n\r\n  const calls = useMemo(\r\n    () =>\r\n      contract && fragment && callInputs && callInputs.length > 0\r\n        ? callInputs.map<Call>((inputs) => {\r\n            return {\r\n              address: contract.address,\r\n              callData: contract.interface.encodeFunctionData(fragment, inputs),\r\n            }\r\n          })\r\n        : [],\r\n    [callInputs, contract, fragment],\r\n  )\r\n\r\n  const results = useCallsData(calls, options)\r\n\r\n  const latestBlockNumber = useBlockNumber()\r\n\r\n  return useMemo(() => {\r\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber))\r\n  }, [fragment, contract, results, latestBlockNumber])\r\n}\r\n\r\nexport function useMultipleContractSingleData(\r\n  addresses: (string | undefined)[],\r\n  contractInterface: Interface,\r\n  methodName: string,\r\n  callInputs?: OptionalMethodInputs,\r\n  options?: ListenerOptions,\r\n): CallState[] {\r\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\r\n  const callData: string | undefined = useMemo(\r\n    () =>\r\n      fragment && isValidMethodArgs(callInputs)\r\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\r\n        : undefined,\r\n    [callInputs, contractInterface, fragment],\r\n  )\r\n\r\n  const calls = useMemo(\r\n    () =>\r\n      fragment && addresses && addresses.length > 0 && callData\r\n        ? addresses.map<Call | undefined>((address) => {\r\n            return address && callData\r\n              ? {\r\n                  address,\r\n                  callData,\r\n                }\r\n              : undefined\r\n          })\r\n        : [],\r\n    [addresses, callData, fragment],\r\n  )\r\n\r\n  const results = useCallsData(calls, options)\r\n\r\n  const latestBlockNumber = useBlockNumber()\r\n\r\n  return useMemo(() => {\r\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber))\r\n  }, [fragment, results, contractInterface, latestBlockNumber])\r\n}\r\n\r\nexport function useSingleCallResult(\r\n  contract: Contract | null | undefined,\r\n  methodName: string,\r\n  inputs?: OptionalMethodInputs,\r\n  options?: ListenerOptions,\r\n): CallState {\r\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\r\n\r\n  const calls = useMemo<Call[]>(() => {\r\n    return contract && fragment && isValidMethodArgs(inputs)\r\n      ? [\r\n          {\r\n            address: contract.address,\r\n            callData: contract.interface.encodeFunctionData(fragment, inputs),\r\n          },\r\n        ]\r\n      : []\r\n  }, [contract, fragment, inputs])\r\n\r\n  const result = useCallsData(calls, options)[0]\r\n  const latestBlockNumber = useBlockNumber()\r\n\r\n  return useMemo(() => {\r\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber)\r\n  }, [result, contract, fragment, latestBlockNumber])\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}