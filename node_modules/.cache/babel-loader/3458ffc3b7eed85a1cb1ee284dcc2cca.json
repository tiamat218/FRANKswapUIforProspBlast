{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { addTransaction } from './actions';\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder() {\n  _s();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const dispatch = useDispatch();\n  return useCallback((response, {\n    summary,\n    approval,\n    claim\n  } = {}) => {\n    if (!account) return;\n    if (!chainId) return;\n    const {\n      hash\n    } = response;\n\n    if (!hash) {\n      throw Error('No transaction hash found.');\n    }\n\n    dispatch(addTransaction({\n      hash,\n      from: account,\n      chainId,\n      approval,\n      summary,\n      claim\n    }));\n  }, [dispatch, chainId, account]);\n} // returns all the transactions for the current chain\n\n_s(useTransactionAdder, \"MEh+TAztv1BWq5c2lTL2SEy/Uq8=\", false, function () {\n  return [useActiveWeb3React, useDispatch];\n});\n\nexport function useAllTransactions() {\n  _s2();\n\n  var _state$chainId;\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const state = useSelector(s => s.transactions);\n  return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n}\n\n_s2(useAllTransactions, \"3FhVoM2yUUuTIyL07ycVqdy9Zqs=\", false, function () {\n  return [useActiveWeb3React, useSelector];\n});\n\nexport function useIsTransactionPending(transactionHash) {\n  _s3();\n\n  const transactions = useAllTransactions();\n  if (!transactionHash || !transactions[transactionHash]) return false;\n  return !transactions[transactionHash].receipt;\n}\n/**\r\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\r\n * @param tx to check for recency\r\n */\n\n_s3(useIsTransactionPending, \"hqz1TRfIl9I1+vK9TqtScGR9Kdg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function isTransactionRecent(tx) {\n  return new Date().getTime() - tx.addedTime < 86400000;\n} // returns whether a token has a pending approval transaction\n\nexport function useHasPendingApproval(tokenAddress, spender) {\n  _s4();\n\n  const allTransactions = useAllTransactions();\n  return useMemo(() => typeof tokenAddress === 'string' && typeof spender === 'string' && Object.keys(allTransactions).some(hash => {\n    const tx = allTransactions[hash];\n    if (!tx) return false;\n\n    if (tx.receipt) {\n      return false;\n    }\n\n    const {\n      approval\n    } = tx;\n    if (!approval) return false;\n    return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);\n  }), [allTransactions, spender, tokenAddress]);\n}\n\n_s4(useHasPendingApproval, \"VezVe/KwFqNDaRAkqywKb3KU5lg=\", false, function () {\n  return [useAllTransactions];\n});","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/transactions/hooks.tsx"],"names":["useCallback","useMemo","useDispatch","useSelector","useActiveWeb3React","addTransaction","useTransactionAdder","chainId","account","dispatch","response","summary","approval","claim","hash","Error","from","useAllTransactions","state","s","transactions","useIsTransactionPending","transactionHash","receipt","isTransactionRecent","tx","Date","getTime","addedTime","useHasPendingApproval","tokenAddress","spender","allTransactions","Object","keys","some"],"mappings":"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","sourcesContent":["import { TransactionResponse } from '@ethersproject/providers'\r\nimport { useCallback, useMemo } from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport { AppDispatch, AppState } from '../index'\r\nimport { addTransaction } from './actions'\r\nimport { TransactionDetails } from './reducer'\r\n\r\n// helper that can take a ethers library transaction response and add it to the list of transactions\r\nexport function useTransactionAdder(): (\r\n  response: TransactionResponse,\r\n  customData?: {\r\n    summary?: string\r\n    approval?: { tokenAddress: string; spender: string }\r\n    claim?: { recipient: string }\r\n  },\r\n) => void {\r\n  const { chainId, account } = useActiveWeb3React()\r\n  const dispatch = useDispatch<AppDispatch>()\r\n\r\n  return useCallback(\r\n    (\r\n      response: TransactionResponse,\r\n      {\r\n        summary,\r\n        approval,\r\n        claim,\r\n      }: { summary?: string; claim?: { recipient: string }; approval?: { tokenAddress: string; spender: string } } = {},\r\n    ) => {\r\n      if (!account) return\r\n      if (!chainId) return\r\n\r\n      const { hash } = response\r\n      if (!hash) {\r\n        throw Error('No transaction hash found.')\r\n      }\r\n      dispatch(addTransaction({ hash, from: account, chainId, approval, summary, claim }))\r\n    },\r\n    [dispatch, chainId, account],\r\n  )\r\n}\r\n\r\n// returns all the transactions for the current chain\r\nexport function useAllTransactions(): { [txHash: string]: TransactionDetails } {\r\n  const { chainId } = useActiveWeb3React()\r\n\r\n  const state = useSelector<AppState, AppState['transactions']>((s) => s.transactions)\r\n\r\n  return chainId ? state[chainId] ?? {} : {}\r\n}\r\n\r\nexport function useIsTransactionPending(transactionHash?: string): boolean {\r\n  const transactions = useAllTransactions()\r\n\r\n  if (!transactionHash || !transactions[transactionHash]) return false\r\n\r\n  return !transactions[transactionHash].receipt\r\n}\r\n\r\n/**\r\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\r\n * @param tx to check for recency\r\n */\r\nexport function isTransactionRecent(tx: TransactionDetails): boolean {\r\n  return new Date().getTime() - tx.addedTime < 86_400_000\r\n}\r\n\r\n// returns whether a token has a pending approval transaction\r\nexport function useHasPendingApproval(tokenAddress: string | undefined, spender: string | undefined): boolean {\r\n  const allTransactions = useAllTransactions()\r\n  return useMemo(\r\n    () =>\r\n      typeof tokenAddress === 'string' &&\r\n      typeof spender === 'string' &&\r\n      Object.keys(allTransactions).some((hash) => {\r\n        const tx = allTransactions[hash]\r\n        if (!tx) return false\r\n        if (tx.receipt) {\r\n          return false\r\n        }\r\n        const { approval } = tx\r\n        if (!approval) return false\r\n        return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx)\r\n      }),\r\n    [allTransactions, spender, tokenAddress],\r\n  )\r\n}\r\n"]},"metadata":{},"sourceType":"module"}