{"ast":null,"code":"import { createReducer } from '@reduxjs/toolkit';\nimport { getVersionUpgrade, VersionUpgrade } from '@uniswap/token-lists'; // eslint-disable-next-line import/no-unresolved\n\nimport { DEFAULT_ACTIVE_LIST_URLS, UNSUPPORTED_LIST_URLS, DEFAULT_LIST_OF_LISTS } from '../../config/constants/lists';\nimport { updateVersion } from '../global/actions';\nimport { acceptListUpdate, addList, fetchTokenList, removeList, enableList, disableList } from './actions';\nconst NEW_LIST_STATE = {\n  error: null,\n  current: null,\n  loadingRequestId: null,\n  pendingUpdate: null\n};\nconst initialState = {\n  lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\n  byUrl: { ...DEFAULT_LIST_OF_LISTS.concat(...UNSUPPORTED_LIST_URLS).reduce((memo, listUrl) => {\n      memo[listUrl] = NEW_LIST_STATE;\n      return memo;\n    }, {})\n  },\n  activeListUrls: DEFAULT_ACTIVE_LIST_URLS\n};\nexport default createReducer(initialState, builder => builder.addCase(fetchTokenList.pending, (state, {\n  payload: {\n    requestId,\n    url\n  }\n}) => {\n  state.byUrl[url] = {\n    current: null,\n    pendingUpdate: null,\n    ...state.byUrl[url],\n    loadingRequestId: requestId,\n    error: null\n  };\n}).addCase(fetchTokenList.fulfilled, (state, {\n  payload: {\n    requestId,\n    tokenList,\n    url\n  }\n}) => {\n  var _state$byUrl$url, _state$byUrl$url2;\n\n  const current = (_state$byUrl$url = state.byUrl[url]) === null || _state$byUrl$url === void 0 ? void 0 : _state$byUrl$url.current;\n  const loadingRequestId = (_state$byUrl$url2 = state.byUrl[url]) === null || _state$byUrl$url2 === void 0 ? void 0 : _state$byUrl$url2.loadingRequestId; // no-op if update does nothing\n\n  if (current) {\n    const upgradeType = getVersionUpgrade(current.version, tokenList.version);\n    if (upgradeType === VersionUpgrade.NONE) return;\n\n    if (loadingRequestId === null || loadingRequestId === requestId) {\n      state.byUrl[url] = { ...state.byUrl[url],\n        loadingRequestId: null,\n        error: null,\n        current,\n        pendingUpdate: tokenList\n      };\n    }\n  } else {\n    // activate if on default active\n    if (DEFAULT_ACTIVE_LIST_URLS.includes(url)) {\n      var _state$activeListUrls;\n\n      (_state$activeListUrls = state.activeListUrls) === null || _state$activeListUrls === void 0 ? void 0 : _state$activeListUrls.push(url);\n    }\n\n    state.byUrl[url] = { ...state.byUrl[url],\n      loadingRequestId: null,\n      error: null,\n      current: tokenList,\n      pendingUpdate: null\n    };\n  }\n}).addCase(fetchTokenList.rejected, (state, {\n  payload: {\n    url,\n    requestId,\n    errorMessage\n  }\n}) => {\n  var _state$byUrl$url3;\n\n  if (((_state$byUrl$url3 = state.byUrl[url]) === null || _state$byUrl$url3 === void 0 ? void 0 : _state$byUrl$url3.loadingRequestId) !== requestId) {\n    // no-op since it's not the latest request\n    return;\n  }\n\n  state.byUrl[url] = { ...state.byUrl[url],\n    loadingRequestId: null,\n    error: errorMessage,\n    current: null,\n    pendingUpdate: null\n  };\n}).addCase(addList, (state, {\n  payload: url\n}) => {\n  if (!state.byUrl[url]) {\n    state.byUrl[url] = NEW_LIST_STATE;\n  }\n}).addCase(removeList, (state, {\n  payload: url\n}) => {\n  if (state.byUrl[url]) {\n    delete state.byUrl[url];\n  } // remove list from active urls if needed\n\n\n  if (state.activeListUrls && state.activeListUrls.includes(url)) {\n    state.activeListUrls = state.activeListUrls.filter(u => u !== url);\n  }\n}).addCase(enableList, (state, {\n  payload: url\n}) => {\n  if (!state.byUrl[url]) {\n    state.byUrl[url] = NEW_LIST_STATE;\n  }\n\n  if (state.activeListUrls && !state.activeListUrls.includes(url)) {\n    state.activeListUrls.push(url);\n  }\n\n  if (!state.activeListUrls) {\n    state.activeListUrls = [url];\n  }\n}).addCase(disableList, (state, {\n  payload: url\n}) => {\n  if (state.activeListUrls && state.activeListUrls.includes(url)) {\n    state.activeListUrls = state.activeListUrls.filter(u => u !== url);\n  }\n}).addCase(acceptListUpdate, (state, {\n  payload: url\n}) => {\n  var _state$byUrl$url4;\n\n  if (!((_state$byUrl$url4 = state.byUrl[url]) === null || _state$byUrl$url4 === void 0 ? void 0 : _state$byUrl$url4.pendingUpdate)) {\n    throw new Error('accept list update called without pending update');\n  }\n\n  state.byUrl[url] = { ...state.byUrl[url],\n    pendingUpdate: null,\n    current: state.byUrl[url].pendingUpdate\n  };\n}).addCase(updateVersion, state => {\n  // state loaded from localStorage, but new lists have never been initialized\n  if (!state.lastInitializedDefaultListOfLists) {\n    state.byUrl = initialState.byUrl;\n    state.activeListUrls = initialState.activeListUrls;\n  } else if (state.lastInitializedDefaultListOfLists) {\n    const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce((s, l) => s.add(l), new Set());\n    const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce((s, l) => s.add(l), new Set());\n    DEFAULT_LIST_OF_LISTS.forEach(listUrl => {\n      if (!lastInitializedSet.has(listUrl)) {\n        state.byUrl[listUrl] = NEW_LIST_STATE;\n      }\n    });\n    state.lastInitializedDefaultListOfLists.forEach(listUrl => {\n      if (!newListOfListsSet.has(listUrl)) {\n        delete state.byUrl[listUrl];\n      }\n    });\n  }\n\n  state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS; // if no active lists, activate defaults\n\n  if (!state.activeListUrls) {\n    state.activeListUrls = DEFAULT_ACTIVE_LIST_URLS; // for each list on default list, initialize if needed\n\n    DEFAULT_ACTIVE_LIST_URLS.map(listUrl => {\n      if (!state.byUrl[listUrl]) {\n        state.byUrl[listUrl] = NEW_LIST_STATE;\n      }\n\n      return true;\n    });\n  }\n}));","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/lists/reducer.ts"],"names":["createReducer","getVersionUpgrade","VersionUpgrade","DEFAULT_ACTIVE_LIST_URLS","UNSUPPORTED_LIST_URLS","DEFAULT_LIST_OF_LISTS","updateVersion","acceptListUpdate","addList","fetchTokenList","removeList","enableList","disableList","NEW_LIST_STATE","error","current","loadingRequestId","pendingUpdate","initialState","lastInitializedDefaultListOfLists","byUrl","concat","reduce","memo","listUrl","activeListUrls","builder","addCase","pending","state","payload","requestId","url","fulfilled","tokenList","upgradeType","version","NONE","includes","push","rejected","errorMessage","filter","u","Error","lastInitializedSet","s","l","add","Set","newListOfListsSet","forEach","has","map"],"mappings":"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","sourcesContent":["import { createReducer } from '@reduxjs/toolkit'\r\nimport { getVersionUpgrade, VersionUpgrade } from '@uniswap/token-lists'\r\n// eslint-disable-next-line import/no-unresolved\r\nimport { TokenList } from '@uniswap/token-lists/dist/types'\r\nimport { DEFAULT_ACTIVE_LIST_URLS, UNSUPPORTED_LIST_URLS, DEFAULT_LIST_OF_LISTS } from '../../config/constants/lists'\r\n\r\nimport { updateVersion } from '../global/actions'\r\nimport { acceptListUpdate, addList, fetchTokenList, removeList, enableList, disableList } from './actions'\r\n\r\nexport interface ListsState {\r\n  readonly byUrl: {\r\n    readonly [url: string]: {\r\n      readonly current: TokenList | null\r\n      readonly pendingUpdate: TokenList | null\r\n      readonly loadingRequestId: string | null\r\n      readonly error: string | null\r\n    }\r\n  }\r\n  // this contains the default list of lists from the last time the updateVersion was called, i.e. the app was reloaded\r\n  readonly lastInitializedDefaultListOfLists?: string[]\r\n\r\n  // currently active lists\r\n  readonly activeListUrls: string[] | undefined\r\n}\r\n\r\ntype ListState = ListsState['byUrl'][string]\r\n\r\nconst NEW_LIST_STATE: ListState = {\r\n  error: null,\r\n  current: null,\r\n  loadingRequestId: null,\r\n  pendingUpdate: null,\r\n}\r\n\r\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] extends ReadonlyArray<infer U> ? U[] : T[P] }\r\n\r\nconst initialState: ListsState = {\r\n  lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\r\n  byUrl: {\r\n    ...DEFAULT_LIST_OF_LISTS.concat(...UNSUPPORTED_LIST_URLS).reduce<Mutable<ListsState['byUrl']>>((memo, listUrl) => {\r\n      memo[listUrl] = NEW_LIST_STATE\r\n      return memo\r\n    }, {}),\r\n  },\r\n  activeListUrls: DEFAULT_ACTIVE_LIST_URLS,\r\n}\r\n\r\nexport default createReducer(initialState, (builder) =>\r\n  builder\r\n    .addCase(fetchTokenList.pending, (state, { payload: { requestId, url } }) => {\r\n      state.byUrl[url] = {\r\n        current: null,\r\n        pendingUpdate: null,\r\n        ...state.byUrl[url],\r\n        loadingRequestId: requestId,\r\n        error: null,\r\n      }\r\n    })\r\n    .addCase(fetchTokenList.fulfilled, (state, { payload: { requestId, tokenList, url } }) => {\r\n      const current = state.byUrl[url]?.current\r\n      const loadingRequestId = state.byUrl[url]?.loadingRequestId\r\n\r\n      // no-op if update does nothing\r\n      if (current) {\r\n        const upgradeType = getVersionUpgrade(current.version, tokenList.version)\r\n\r\n        if (upgradeType === VersionUpgrade.NONE) return\r\n        if (loadingRequestId === null || loadingRequestId === requestId) {\r\n          state.byUrl[url] = {\r\n            ...state.byUrl[url],\r\n            loadingRequestId: null,\r\n            error: null,\r\n            current,\r\n            pendingUpdate: tokenList,\r\n          }\r\n        }\r\n      } else {\r\n        // activate if on default active\r\n        if (DEFAULT_ACTIVE_LIST_URLS.includes(url)) {\r\n          state.activeListUrls?.push(url)\r\n        }\r\n\r\n        state.byUrl[url] = {\r\n          ...state.byUrl[url],\r\n          loadingRequestId: null,\r\n          error: null,\r\n          current: tokenList,\r\n          pendingUpdate: null,\r\n        }\r\n      }\r\n    })\r\n    .addCase(fetchTokenList.rejected, (state, { payload: { url, requestId, errorMessage } }) => {\r\n      if (state.byUrl[url]?.loadingRequestId !== requestId) {\r\n        // no-op since it's not the latest request\r\n        return\r\n      }\r\n\r\n      state.byUrl[url] = {\r\n        ...state.byUrl[url],\r\n        loadingRequestId: null,\r\n        error: errorMessage,\r\n        current: null,\r\n        pendingUpdate: null,\r\n      }\r\n    })\r\n    .addCase(addList, (state, { payload: url }) => {\r\n      if (!state.byUrl[url]) {\r\n        state.byUrl[url] = NEW_LIST_STATE\r\n      }\r\n    })\r\n    .addCase(removeList, (state, { payload: url }) => {\r\n      if (state.byUrl[url]) {\r\n        delete state.byUrl[url]\r\n      }\r\n      // remove list from active urls if needed\r\n      if (state.activeListUrls && state.activeListUrls.includes(url)) {\r\n        state.activeListUrls = state.activeListUrls.filter((u) => u !== url)\r\n      }\r\n    })\r\n    .addCase(enableList, (state, { payload: url }) => {\r\n      if (!state.byUrl[url]) {\r\n        state.byUrl[url] = NEW_LIST_STATE\r\n      }\r\n\r\n      if (state.activeListUrls && !state.activeListUrls.includes(url)) {\r\n        state.activeListUrls.push(url)\r\n      }\r\n\r\n      if (!state.activeListUrls) {\r\n        state.activeListUrls = [url]\r\n      }\r\n    })\r\n    .addCase(disableList, (state, { payload: url }) => {\r\n      if (state.activeListUrls && state.activeListUrls.includes(url)) {\r\n        state.activeListUrls = state.activeListUrls.filter((u) => u !== url)\r\n      }\r\n    })\r\n    .addCase(acceptListUpdate, (state, { payload: url }) => {\r\n      if (!state.byUrl[url]?.pendingUpdate) {\r\n        throw new Error('accept list update called without pending update')\r\n      }\r\n      state.byUrl[url] = {\r\n        ...state.byUrl[url],\r\n        pendingUpdate: null,\r\n        current: state.byUrl[url].pendingUpdate,\r\n      }\r\n    })\r\n    .addCase(updateVersion, (state) => {\r\n      // state loaded from localStorage, but new lists have never been initialized\r\n      if (!state.lastInitializedDefaultListOfLists) {\r\n        state.byUrl = initialState.byUrl\r\n        state.activeListUrls = initialState.activeListUrls\r\n      } else if (state.lastInitializedDefaultListOfLists) {\r\n        const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce<Set<string>>(\r\n          (s, l) => s.add(l),\r\n          new Set(),\r\n        )\r\n        const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce<Set<string>>((s, l) => s.add(l), new Set())\r\n\r\n        DEFAULT_LIST_OF_LISTS.forEach((listUrl) => {\r\n          if (!lastInitializedSet.has(listUrl)) {\r\n            state.byUrl[listUrl] = NEW_LIST_STATE\r\n          }\r\n        })\r\n\r\n        state.lastInitializedDefaultListOfLists.forEach((listUrl) => {\r\n          if (!newListOfListsSet.has(listUrl)) {\r\n            delete state.byUrl[listUrl]\r\n          }\r\n        })\r\n      }\r\n\r\n      state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS\r\n\r\n      // if no active lists, activate defaults\r\n      if (!state.activeListUrls) {\r\n        state.activeListUrls = DEFAULT_ACTIVE_LIST_URLS\r\n\r\n        // for each list on default list, initialize if needed\r\n        DEFAULT_ACTIVE_LIST_URLS.map((listUrl: string) => {\r\n          if (!state.byUrl[listUrl]) {\r\n            state.byUrl[listUrl] = NEW_LIST_STATE\r\n          }\r\n          return true\r\n        })\r\n      }\r\n    }),\r\n)\r\n"]},"metadata":{},"sourceType":"module"}