{"ast":null,"code":"import{ethers}from'ethers';import{getMulticallContract}from'utils/contractHelpers';const multicall=async(abi,calls)=>{try{const multi=getMulticallContract();const itf=new ethers.utils.Interface(abi);const calldata=calls.map(call=>[call.address.toLowerCase(),itf.encodeFunctionData(call.name,call.params)]);const{returnData}=await multi.aggregate(calldata);const res=returnData.map((call,i)=>itf.decodeFunctionResult(calls[i].name,call));return res;}catch(error){throw new Error(error);}};/**\r\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\r\n *\r\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\r\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\r\n */export const multicallv2=async function(abi,calls){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{requireSuccess:true};const{requireSuccess}=options;const multi=getMulticallContract();const itf=new ethers.utils.Interface(abi);const calldata=calls.map(call=>[call.address.toLowerCase(),itf.encodeFunctionData(call.name,call.params)]);const returnData=await multi.tryAggregate(requireSuccess,calldata);const res=returnData.map((call,i)=>{const[result,data]=call;return result?itf.decodeFunctionResult(calls[i].name,data):null;});return res;};export default multicall;","map":{"version":3,"names":["ethers","getMulticallContract","multicall","abi","calls","multi","itf","utils","Interface","calldata","map","call","address","toLowerCase","encodeFunctionData","name","params","returnData","aggregate","res","i","decodeFunctionResult","error","Error","multicallv2","options","arguments","length","undefined","requireSuccess","tryAggregate","result","data"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/utils/multicall.ts"],"sourcesContent":["import { ethers } from 'ethers'\r\nimport { getMulticallContract } from 'utils/contractHelpers'\r\nimport { MultiCallResponse } from './types'\r\n\r\nexport interface Call {\r\n  address: string // Address of the contract\r\n  name: string // Function name on the contract (example: balanceOf)\r\n  params?: any[] // Function params\r\n}\r\n\r\ninterface MulticallOptions {\r\n  requireSuccess?: boolean\r\n}\r\n\r\nconst multicall = async <T = any>(abi: any[], calls: Call[]): Promise<T> => {\r\n  try {\r\n    const multi = getMulticallContract()\r\n    const itf = new ethers.utils.Interface(abi)\r\n\r\n    const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\r\n    const { returnData } = await multi.aggregate(calldata)\r\n\r\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call))\r\n\r\n    return res\r\n  } catch (error) {\r\n    throw new Error(error)\r\n  }\r\n}\r\n\r\n/**\r\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\r\n *\r\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\r\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\r\n */\r\nexport const multicallv2 = async <T = any>(\r\n  abi: any[],\r\n  calls: Call[],\r\n  options: MulticallOptions = { requireSuccess: true },\r\n): Promise<MultiCallResponse<T>> => {\r\n  const { requireSuccess } = options\r\n  const multi = getMulticallContract()\r\n  const itf = new ethers.utils.Interface(abi)\r\n\r\n  const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\r\n  const returnData = await multi.tryAggregate(requireSuccess, calldata)\r\n  const res = returnData.map((call, i) => {\r\n    const [result, data] = call\r\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null\r\n  })\r\n\r\n  return res\r\n}\r\n\r\nexport default multicall\r\n"],"mappings":"AAAA,OAASA,MAAM,KAAQ,QAAQ,CAC/B,OAASC,oBAAoB,KAAQ,uBAAuB,CAa5D,KAAM,CAAAC,SAAS,CAAG,KAAAA,CAAgBC,GAAU,CAAEC,KAAa,GAAiB,CAC1E,GAAI,CACF,KAAM,CAAAC,KAAK,CAAGJ,oBAAoB,CAAC,CAAC,CACpC,KAAM,CAAAK,GAAG,CAAG,GAAI,CAAAN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC,CAE3C,KAAM,CAAAM,QAAQ,CAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,EAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,CAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,CAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC,CAClH,KAAM,CAAEC,UAAW,CAAC,CAAG,KAAM,CAAAZ,KAAK,CAACa,SAAS,CAACT,QAAQ,CAAC,CAEtD,KAAM,CAAAU,GAAG,CAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,CAAES,CAAC,GAAKd,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,CAAEJ,IAAI,CAAC,CAAC,CAEtF,MAAO,CAAAQ,GAAG,CACZ,CAAE,MAAOG,KAAK,CAAE,CACd,KAAM,IAAI,CAAAC,KAAK,CAACD,KAAK,CAAC,CACxB,CACF,CAAC,CAED;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAE,WAAW,CAAG,cAAAA,CACzBrB,GAAU,CACVC,KAAa,CAEqB,IADlC,CAAAqB,OAAyB,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAEG,cAAc,CAAE,IAAK,CAAC,CAEpD,KAAM,CAAEA,cAAe,CAAC,CAAGJ,OAAO,CAClC,KAAM,CAAApB,KAAK,CAAGJ,oBAAoB,CAAC,CAAC,CACpC,KAAM,CAAAK,GAAG,CAAG,GAAI,CAAAN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC,CAE3C,KAAM,CAAAM,QAAQ,CAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,EAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,CAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,CAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC,CAClH,KAAM,CAAAC,UAAU,CAAG,KAAM,CAAAZ,KAAK,CAACyB,YAAY,CAACD,cAAc,CAAEpB,QAAQ,CAAC,CACrE,KAAM,CAAAU,GAAG,CAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,CAAES,CAAC,GAAK,CACtC,KAAM,CAACW,MAAM,CAAEC,IAAI,CAAC,CAAGrB,IAAI,CAC3B,MAAO,CAAAoB,MAAM,CAAGzB,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,CAAEiB,IAAI,CAAC,CAAG,IAAI,CACtE,CAAC,CAAC,CAEF,MAAO,CAAAb,GAAG,CACZ,CAAC,CAED,cAAe,CAAAjB,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module"}