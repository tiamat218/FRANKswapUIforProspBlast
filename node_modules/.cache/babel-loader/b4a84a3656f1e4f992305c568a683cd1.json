{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { useMulticallContract } from '../../hooks/useContract';\nimport useDebounce from '../../hooks/useDebounce';\nimport { CancelledError, retry, RetryableError } from './retry';\nimport { useBlockNumber } from '../application/hooks';\nimport { errorFetchingMulticallResults, fetchingMulticallResults, parseCallKey, updateMulticallResults } from './actions';\nimport chunkArray from './chunkArray';\n\n// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE = 500;\n\n/**\r\n * Fetches a chunk of calls, enforcing a minimum block number constraint\r\n * @param multicallContract multicall contract to fetch against\r\n * @param chunk chunk of calls to make\r\n * @param minBlockNumber minimum block number of the result set\r\n */\nasync function fetchChunk(multicallContract, chunk, minBlockNumber) {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber);\n  let resultsBlockNumber;\n  let returnData;\n  try {\n    // prettier-ignore\n    [resultsBlockNumber, returnData] = await multicallContract.aggregate(chunk.map(obj => [obj.address, obj.callData]));\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error);\n    throw error;\n  }\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`);\n    throw new RetryableError('Fetched for old block number');\n  }\n  return {\n    results: returnData,\n    blockNumber: resultsBlockNumber.toNumber()\n  };\n}\n\n/**\r\n * From the current all listeners state, return each call key mapped to the\r\n * minimum number of blocks per fetch. This is how often each key must be fetched.\r\n * @param allListeners the all listeners state\r\n * @param chainId the current chain id\r\n */\nexport function activeListeningKeys(allListeners, chainId) {\n  if (!allListeners || !chainId) return {};\n  const listeners = allListeners[chainId];\n  if (!listeners) return {};\n  return Object.keys(listeners).reduce((memo, callKey) => {\n    const keyListeners = listeners[callKey];\n    memo[callKey] = Object.keys(keyListeners).filter(key => {\n      const blocksPerFetch = parseInt(key);\n      if (blocksPerFetch <= 0) return false;\n      return keyListeners[blocksPerFetch] > 0;\n    }).reduce((previousMin, current) => {\n      return Math.min(previousMin, parseInt(current));\n    }, Infinity);\n    return memo;\n  }, {});\n}\n\n/**\r\n * Return the keys that need to be refetched\r\n * @param callResults current call result state\r\n * @param listeningKeys each call key mapped to how old the data can be in blocks\r\n * @param chainId the current chain id\r\n * @param latestBlockNumber the latest block number\r\n */\nexport function outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {\n  if (!chainId || !latestBlockNumber) return [];\n  const results = callResults[chainId];\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys);\n  return Object.keys(listeningKeys).filter(callKey => {\n    const blocksPerFetch = listeningKeys[callKey];\n    const data = callResults[chainId][callKey];\n    // no data, must fetch\n    if (!data) return true;\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1);\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false;\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\nexport default function Updater() {\n  _s();\n  const dispatch = useDispatch();\n  const state = useSelector(s => s.multicall);\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100);\n  const latestBlockNumber = useBlockNumber();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const multicallContract = useMulticallContract();\n  const cancellations = useRef();\n  const listeningKeys = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId);\n  }, [debouncedListeners, chainId]);\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);\n  const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [unserializedOutdatedCallKeys]);\n  useEffect(() => {\n    var _cancellations$curren;\n    if (!latestBlockNumber || !chainId || !multicallContract) return;\n    const outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);\n    if (outdatedCallKeys.length === 0) return;\n    const calls = outdatedCallKeys.map(key => parseCallKey(key));\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE);\n    if (((_cancellations$curren = cancellations.current) === null || _cancellations$curren === void 0 ? void 0 : _cancellations$curren.blockNumber) !== latestBlockNumber) {\n      var _cancellations$curren2, _cancellations$curren3;\n      (_cancellations$curren2 = cancellations.current) === null || _cancellations$curren2 === void 0 ? void 0 : (_cancellations$curren3 = _cancellations$curren2.cancellations) === null || _cancellations$curren3 === void 0 ? void 0 : _cancellations$curren3.forEach(c => c());\n    }\n    dispatch(fetchingMulticallResults({\n      calls,\n      chainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const {\n          cancel,\n          promise\n        } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500\n        });\n        promise.then(({\n          results: returnData,\n          blockNumber: fetchBlockNumber\n        }) => {\n          cancellations.current = {\n            cancellations: [],\n            blockNumber: latestBlockNumber\n          };\n\n          // accumulates the length of all previous indices\n          const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce((memo, curr) => memo + curr.length, 0);\n          const lastCallKeyIndex = firstCallKeyIndex + returnData.length;\n          dispatch(updateMulticallResults({\n            chainId,\n            results: outdatedCallKeys.slice(firstCallKeyIndex, lastCallKeyIndex).reduce((memo, callKey, i) => {\n              var _returnData$i;\n              memo[callKey] = (_returnData$i = returnData[i]) !== null && _returnData$i !== void 0 ? _returnData$i : null;\n              return memo;\n            }, {}),\n            blockNumber: fetchBlockNumber\n          }));\n        }).catch(error => {\n          if (error instanceof CancelledError) {\n            console.debug('Cancelled fetch for blockNumber', latestBlockNumber);\n            return;\n          }\n          console.error('Failed to fetch multicall chunk', chunk, chainId, error);\n          dispatch(errorFetchingMulticallResults({\n            calls: chunk,\n            chainId,\n            fetchingBlockNumber: latestBlockNumber\n          }));\n        });\n        return cancel;\n      })\n    };\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);\n  return null;\n}\n_s(Updater, \"xpRD+AhDwmTdNwtyGSlpafZt7S0=\", false, function () {\n  return [useDispatch, useSelector, useDebounce, useBlockNumber, useActiveWeb3React, useMulticallContract];\n});\n_c = Updater;\nvar _c;\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"names":["useEffect","useMemo","useRef","useDispatch","useSelector","useActiveWeb3React","useMulticallContract","useDebounce","CancelledError","retry","RetryableError","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","chunkArray","CALL_CHUNK_SIZE","fetchChunk","multicallContract","chunk","minBlockNumber","console","debug","resultsBlockNumber","returnData","aggregate","map","obj","address","callData","error","toNumber","toString","results","blockNumber","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","Math","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","data","minDataBlockNumber","fetchingBlockNumber","Updater","_s","dispatch","state","s","multicall","debouncedListeners","callListeners","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","_cancellations$curren","outdatedCallKeys","parse","length","calls","chunkedCalls","_cancellations$curren2","_cancellations$curren3","forEach","c","index","cancel","promise","n","minWait","maxWait","then","fetchBlockNumber","firstCallKeyIndex","slice","curr","lastCallKeyIndex","i","_returnData$i","catch","_c","$RefreshReg$"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/multicall/updater.tsx"],"sourcesContent":["import { Contract } from '@ethersproject/contracts'\r\nimport { useEffect, useMemo, useRef } from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport { useMulticallContract } from '../../hooks/useContract'\r\nimport useDebounce from '../../hooks/useDebounce'\r\nimport { CancelledError, retry, RetryableError } from './retry'\r\nimport { useBlockNumber } from '../application/hooks'\r\nimport { AppDispatch, AppState } from '../index'\r\nimport {\r\n  Call,\r\n  errorFetchingMulticallResults,\r\n  fetchingMulticallResults,\r\n  parseCallKey,\r\n  updateMulticallResults,\r\n} from './actions'\r\nimport chunkArray from './chunkArray'\r\n\r\n// chunk calls so we do not exceed the gas limit\r\nconst CALL_CHUNK_SIZE = 500\r\n\r\n/**\r\n * Fetches a chunk of calls, enforcing a minimum block number constraint\r\n * @param multicallContract multicall contract to fetch against\r\n * @param chunk chunk of calls to make\r\n * @param minBlockNumber minimum block number of the result set\r\n */\r\nasync function fetchChunk(\r\n  multicallContract: Contract,\r\n  chunk: Call[],\r\n  minBlockNumber: number,\r\n): Promise<{ results: string[]; blockNumber: number }> {\r\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\r\n  let resultsBlockNumber\r\n  let returnData\r\n  try {\r\n    // prettier-ignore\r\n    [resultsBlockNumber, returnData] = await multicallContract.aggregate(\r\n      chunk.map((obj) => [obj.address, obj.callData])\r\n    )\r\n  } catch (error) {\r\n    console.debug('Failed to fetch chunk inside retry', error)\r\n    throw error\r\n  }\r\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\r\n    console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\r\n    throw new RetryableError('Fetched for old block number')\r\n  }\r\n  return { results: returnData, blockNumber: resultsBlockNumber.toNumber() }\r\n}\r\n\r\n/**\r\n * From the current all listeners state, return each call key mapped to the\r\n * minimum number of blocks per fetch. This is how often each key must be fetched.\r\n * @param allListeners the all listeners state\r\n * @param chainId the current chain id\r\n */\r\nexport function activeListeningKeys(\r\n  allListeners: AppState['multicall']['callListeners'],\r\n  chainId?: number,\r\n): { [callKey: string]: number } {\r\n  if (!allListeners || !chainId) return {}\r\n  const listeners = allListeners[chainId]\r\n  if (!listeners) return {}\r\n\r\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\r\n    const keyListeners = listeners[callKey]\r\n\r\n    memo[callKey] = Object.keys(keyListeners)\r\n      .filter((key) => {\r\n        const blocksPerFetch = parseInt(key)\r\n        if (blocksPerFetch <= 0) return false\r\n        return keyListeners[blocksPerFetch] > 0\r\n      })\r\n      .reduce((previousMin, current) => {\r\n        return Math.min(previousMin, parseInt(current))\r\n      }, Infinity)\r\n    return memo\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Return the keys that need to be refetched\r\n * @param callResults current call result state\r\n * @param listeningKeys each call key mapped to how old the data can be in blocks\r\n * @param chainId the current chain id\r\n * @param latestBlockNumber the latest block number\r\n */\r\nexport function outdatedListeningKeys(\r\n  callResults: AppState['multicall']['callResults'],\r\n  listeningKeys: { [callKey: string]: number },\r\n  chainId: number | undefined,\r\n  latestBlockNumber: number | undefined,\r\n): string[] {\r\n  if (!chainId || !latestBlockNumber) return []\r\n  const results = callResults[chainId]\r\n  // no results at all, load everything\r\n  if (!results) return Object.keys(listeningKeys)\r\n\r\n  return Object.keys(listeningKeys).filter((callKey) => {\r\n    const blocksPerFetch = listeningKeys[callKey]\r\n\r\n    const data = callResults[chainId][callKey]\r\n    // no data, must fetch\r\n    if (!data) return true\r\n\r\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\r\n\r\n    // already fetching it for a recent enough block, don't refetch it\r\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\r\n\r\n    // if data is older than minDataBlockNumber, fetch it\r\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\r\n  })\r\n}\r\n\r\nexport default function Updater(): null {\r\n  const dispatch = useDispatch<AppDispatch>()\r\n  const state = useSelector<AppState, AppState['multicall']>((s) => s.multicall)\r\n  // wait for listeners to settle before triggering updates\r\n  const debouncedListeners = useDebounce(state.callListeners, 100)\r\n  const latestBlockNumber = useBlockNumber()\r\n  const { chainId } = useActiveWeb3React()\r\n  const multicallContract = useMulticallContract()\r\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\r\n\r\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\r\n    return activeListeningKeys(debouncedListeners, chainId)\r\n  }, [debouncedListeners, chainId])\r\n\r\n  const unserializedOutdatedCallKeys = useMemo(() => {\r\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\r\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\r\n\r\n  const serializedOutdatedCallKeys = useMemo(\r\n    () => JSON.stringify(unserializedOutdatedCallKeys.sort()),\r\n    [unserializedOutdatedCallKeys],\r\n  )\r\n\r\n  useEffect(() => {\r\n    if (!latestBlockNumber || !chainId || !multicallContract) return\r\n\r\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\r\n    if (outdatedCallKeys.length === 0) return\r\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key))\r\n\r\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE)\r\n\r\n    if (cancellations.current?.blockNumber !== latestBlockNumber) {\r\n      cancellations.current?.cancellations?.forEach((c) => c())\r\n    }\r\n\r\n    dispatch(\r\n      fetchingMulticallResults({\r\n        calls,\r\n        chainId,\r\n        fetchingBlockNumber: latestBlockNumber,\r\n      }),\r\n    )\r\n\r\n    cancellations.current = {\r\n      blockNumber: latestBlockNumber,\r\n      cancellations: chunkedCalls.map((chunk, index) => {\r\n        const { cancel, promise } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\r\n          n: Infinity,\r\n          minWait: 2500,\r\n          maxWait: 3500,\r\n        })\r\n        promise\r\n          .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {\r\n            cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\r\n\r\n            // accumulates the length of all previous indices\r\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\r\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length\r\n\r\n            dispatch(\r\n              updateMulticallResults({\r\n                chainId,\r\n                results: outdatedCallKeys\r\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\r\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\r\n                    memo[callKey] = returnData[i] ?? null\r\n                    return memo\r\n                  }, {}),\r\n                blockNumber: fetchBlockNumber,\r\n              }),\r\n            )\r\n          })\r\n          .catch((error: any) => {\r\n            if (error instanceof CancelledError) {\r\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber)\r\n              return\r\n            }\r\n            console.error('Failed to fetch multicall chunk', chunk, chainId, error)\r\n            dispatch(\r\n              errorFetchingMulticallResults({\r\n                calls: chunk,\r\n                chainId,\r\n                fetchingBlockNumber: latestBlockNumber,\r\n              }),\r\n            )\r\n          })\r\n        return cancel\r\n      }),\r\n    }\r\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\r\n\r\n  return null\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}