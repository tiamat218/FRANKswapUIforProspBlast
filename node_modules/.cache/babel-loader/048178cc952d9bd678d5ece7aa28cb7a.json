{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useMemo } from 'react';\nimport { isAddress } from '../../utils';\nexport function filterTokens(tokens, search) {\n  if (search.length === 0) return tokens;\n  const searchingAddress = isAddress(search);\n\n  if (searchingAddress) {\n    return tokens.filter(token => token.address === searchingAddress);\n  }\n\n  const lowerSearchParts = search.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n\n  if (lowerSearchParts.length === 0) {\n    return tokens;\n  }\n\n  const matchesSearch = s => {\n    const sParts = s.toLowerCase().split(/\\s+/).filter(s_ => s_.length > 0);\n    return lowerSearchParts.every(p => p.length === 0 || sParts.some(sp => sp.startsWith(p) || sp.endsWith(p)));\n  };\n\n  return tokens.filter(token => {\n    const {\n      symbol,\n      name\n    } = token;\n    return symbol && matchesSearch(symbol) || name && matchesSearch(name);\n  });\n}\nexport function useSortedTokensByQuery(tokens, searchQuery) {\n  _s();\n\n  return useMemo(() => {\n    if (!tokens) {\n      return [];\n    }\n\n    const symbolMatch = searchQuery.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n\n    if (symbolMatch.length > 1) {\n      return tokens;\n    }\n\n    const exactMatches = [];\n    const symbolSubtrings = [];\n    const rest = []; // sort tokens by exact match -> subtring on symbol match -> rest\n\n    tokens.map(token => {\n      var _token$symbol, _token$symbol2;\n\n      if (((_token$symbol = token.symbol) === null || _token$symbol === void 0 ? void 0 : _token$symbol.toLowerCase()) === symbolMatch[0]) {\n        return exactMatches.push(token);\n      }\n\n      if ((_token$symbol2 = token.symbol) === null || _token$symbol2 === void 0 ? void 0 : _token$symbol2.toLowerCase().startsWith(searchQuery.toLowerCase().trim())) {\n        return symbolSubtrings.push(token);\n      }\n\n      return rest.push(token);\n    });\n    return [...exactMatches, ...symbolSubtrings, ...rest];\n  }, [tokens, searchQuery]);\n}\n\n_s(useSortedTokensByQuery, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/components/SearchModal/filtering.ts"],"names":["useMemo","isAddress","filterTokens","tokens","search","length","searchingAddress","filter","token","address","lowerSearchParts","toLowerCase","split","s","matchesSearch","sParts","s_","every","p","some","sp","startsWith","endsWith","symbol","name","useSortedTokensByQuery","searchQuery","symbolMatch","exactMatches","symbolSubtrings","rest","map","push","trim"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\r\nimport { Token } from '@pancakeswap/sdk'\r\nimport { isAddress } from '../../utils'\r\n\r\nexport function filterTokens(tokens: Token[], search: string): Token[] {\r\n  if (search.length === 0) return tokens\r\n\r\n  const searchingAddress = isAddress(search)\r\n\r\n  if (searchingAddress) {\r\n    return tokens.filter((token) => token.address === searchingAddress)\r\n  }\r\n\r\n  const lowerSearchParts = search\r\n    .toLowerCase()\r\n    .split(/\\s+/)\r\n    .filter((s) => s.length > 0)\r\n\r\n  if (lowerSearchParts.length === 0) {\r\n    return tokens\r\n  }\r\n\r\n  const matchesSearch = (s: string): boolean => {\r\n    const sParts = s\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter((s_) => s_.length > 0)\r\n\r\n    return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)))\r\n  }\r\n\r\n  return tokens.filter((token) => {\r\n    const { symbol, name } = token\r\n    return (symbol && matchesSearch(symbol)) || (name && matchesSearch(name))\r\n  })\r\n}\r\n\r\nexport function useSortedTokensByQuery(tokens: Token[] | undefined, searchQuery: string): Token[] {\r\n  return useMemo(() => {\r\n    if (!tokens) {\r\n      return []\r\n    }\r\n\r\n    const symbolMatch = searchQuery\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter((s) => s.length > 0)\r\n\r\n    if (symbolMatch.length > 1) {\r\n      return tokens\r\n    }\r\n\r\n    const exactMatches: Token[] = []\r\n    const symbolSubtrings: Token[] = []\r\n    const rest: Token[] = []\r\n\r\n    // sort tokens by exact match -> subtring on symbol match -> rest\r\n    tokens.map((token) => {\r\n      if (token.symbol?.toLowerCase() === symbolMatch[0]) {\r\n        return exactMatches.push(token)\r\n      }\r\n      if (token.symbol?.toLowerCase().startsWith(searchQuery.toLowerCase().trim())) {\r\n        return symbolSubtrings.push(token)\r\n      }\r\n      return rest.push(token)\r\n    })\r\n\r\n    return [...exactMatches, ...symbolSubtrings, ...rest]\r\n  }, [tokens, searchQuery])\r\n}\r\n"]},"metadata":{},"sourceType":"module"}