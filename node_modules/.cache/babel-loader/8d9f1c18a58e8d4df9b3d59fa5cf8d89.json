{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$();\n\nimport { ChainId, Token } from '@pancakeswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { DEFAULT_LIST_OF_LISTS } from 'config/constants/lists';\nimport DEFAULT_TOKEN_LIST from '../../config/constants/tokenLists/pancake-default.tokenlist.json';\nimport { UNSUPPORTED_LIST_URLS } from '../../config/constants/lists';\nimport UNSUPPORTED_TOKEN_LIST from '../../config/constants/tokenLists/pancake-unsupported.tokenlist.json';\n\n// use ordering of default list of lists to assign priority\nfunction sortByListPriority(urlA, urlB) {\n  const first = DEFAULT_LIST_OF_LISTS.includes(urlA) ? DEFAULT_LIST_OF_LISTS.indexOf(urlA) : Number.MAX_SAFE_INTEGER;\n  const second = DEFAULT_LIST_OF_LISTS.includes(urlB) ? DEFAULT_LIST_OF_LISTS.indexOf(urlB) : Number.MAX_SAFE_INTEGER; // need reverse order to make sure mapping includes top priority last\n\n  if (first < second) return 1;\n  if (first > second) return -1;\n  return 0;\n}\n/**\r\n * Token instances created from token info.\r\n */\n\n\nexport class WrappedTokenInfo extends Token {\n  constructor(tokenInfo, tags) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);\n    this.tokenInfo = void 0;\n    this.tags = void 0;\n    this.tokenInfo = tokenInfo;\n    this.tags = tags;\n  }\n\n  get logoURI() {\n    return this.tokenInfo.logoURI;\n  }\n\n}\n\n/**\r\n * An empty result, useful as a default.\r\n */\nconst EMPTY_LIST = {\n  [ChainId.MAINNET]: {},\n  [ChainId.TESTNET]: {}\n};\nconst listCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\nexport function listToTokenMap(list) {\n  const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);\n  if (result) return result;\n  const map = list.tokens.reduce((tokenMap, tokenInfo) => {\n    var _tokenInfo$tags$map$f, _tokenInfo$tags, _tokenInfo$tags$map;\n\n    const tags = (_tokenInfo$tags$map$f = (_tokenInfo$tags = tokenInfo.tags) === null || _tokenInfo$tags === void 0 ? void 0 : (_tokenInfo$tags$map = _tokenInfo$tags.map(tagId => {\n      var _list$tags;\n\n      if (!((_list$tags = list.tags) === null || _list$tags === void 0 ? void 0 : _list$tags[tagId])) return undefined;\n      return { ...list.tags[tagId],\n        id: tagId\n      };\n    })) === null || _tokenInfo$tags$map === void 0 ? void 0 : _tokenInfo$tags$map.filter(x => Boolean(x))) !== null && _tokenInfo$tags$map$f !== void 0 ? _tokenInfo$tags$map$f : [];\n    const token = new WrappedTokenInfo(tokenInfo, tags); // if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.')\n\n    return { ...tokenMap,\n      [token.chainId]: { ...tokenMap[token.chainId],\n        [token.address]: {\n          token,\n          list\n        }\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);\n  return map;\n}\nexport function useAllLists() {\n  _s();\n\n  return useSelector(state => state.lists.byUrl);\n}\n\n_s(useAllLists, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nfunction combineMaps(map1, map2) {\n  return {\n    [ChainId.MAINNET]: { ...map1[ChainId.MAINNET],\n      ...map2[ChainId.MAINNET]\n    },\n    [ChainId.TESTNET]: { ...map1[ChainId.TESTNET],\n      ...map2[ChainId.TESTNET]\n    }\n  };\n} // merge tokens contained within lists from urls\n\n\nfunction useCombinedTokenMapFromUrls(urls) {\n  _s2();\n\n  const lists = useAllLists();\n  return useMemo(() => {\n    if (!urls) return EMPTY_LIST;\n    return urls.slice() // sort by priority so top priority goes last\n    .sort(sortByListPriority).reduce((allTokens, currentUrl) => {\n      var _lists$currentUrl;\n\n      const current = (_lists$currentUrl = lists[currentUrl]) === null || _lists$currentUrl === void 0 ? void 0 : _lists$currentUrl.current;\n      if (!current) return allTokens;\n\n      try {\n        const newTokens = Object.assign(listToTokenMap(current));\n        return combineMaps(allTokens, newTokens);\n      } catch (error) {\n        console.error('Could not show token list due to error', error);\n        return allTokens;\n      }\n    }, EMPTY_LIST);\n  }, [lists, urls]);\n} // filter out unsupported lists\n\n\n_s2(useCombinedTokenMapFromUrls, \"dehXRrnFU9pff84Mq4UWf/sQUEg=\", false, function () {\n  return [useAllLists];\n});\n\nexport function useActiveListUrls() {\n  _s3();\n\n  var _useSelector;\n\n  return (_useSelector = useSelector(state => state.lists.activeListUrls)) === null || _useSelector === void 0 ? void 0 : _useSelector.filter(url => !UNSUPPORTED_LIST_URLS.includes(url));\n}\n\n_s3(useActiveListUrls, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport function useInactiveListUrls() {\n  _s4();\n\n  const lists = useAllLists();\n  const allActiveListUrls = useActiveListUrls();\n  return Object.keys(lists).filter(url => !(allActiveListUrls === null || allActiveListUrls === void 0 ? void 0 : allActiveListUrls.includes(url)) && !UNSUPPORTED_LIST_URLS.includes(url));\n} // get all the tokens from active lists, combine with local default tokens\n\n_s4(useInactiveListUrls, \"Aaa3RmQiPVrq8Yq5CzTAgDsk1NQ=\", false, function () {\n  return [useAllLists, useActiveListUrls];\n});\n\nexport function useCombinedActiveList() {\n  _s5();\n\n  const activeListUrls = useActiveListUrls();\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls);\n  const defaultTokenMap = listToTokenMap(DEFAULT_TOKEN_LIST);\n  return combineMaps(activeTokens, defaultTokenMap);\n} // all tokens from inactive lists\n\n_s5(useCombinedActiveList, \"QZotrOQv4eqlrVbyAJUYHF4JEV4=\", false, function () {\n  return [useActiveListUrls, useCombinedTokenMapFromUrls];\n});\n\nexport function useCombinedInactiveList() {\n  _s6();\n\n  const allInactiveListUrls = useInactiveListUrls();\n  return useCombinedTokenMapFromUrls(allInactiveListUrls);\n} // used to hide warnings on import for default tokens\n\n_s6(useCombinedInactiveList, \"KkTaFdmygCZo4aYLCj+AgUEN+q4=\", false, function () {\n  return [useInactiveListUrls, useCombinedTokenMapFromUrls];\n});\n\nexport function useDefaultTokenList() {\n  return listToTokenMap(DEFAULT_TOKEN_LIST);\n} // list of tokens not supported on interface, used to show warnings and prevent swaps and adds\n\nexport function useUnsupportedTokenList() {\n  _s7();\n\n  // get hard coded unsupported tokens\n  const localUnsupportedListMap = listToTokenMap(UNSUPPORTED_TOKEN_LIST); // get any loaded unsupported tokens\n\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS); // format into one token address map\n\n  return combineMaps(localUnsupportedListMap, loadedUnsupportedListMap);\n}\n\n_s7(useUnsupportedTokenList, \"IDLqbTCADDxqzN3Mo99zPBv+VI4=\", false, function () {\n  return [useCombinedTokenMapFromUrls];\n});\n\nexport function useIsListActive(url) {\n  _s8();\n\n  const activeListUrls = useActiveListUrls();\n  return Boolean(activeListUrls === null || activeListUrls === void 0 ? void 0 : activeListUrls.includes(url));\n}\n\n_s8(useIsListActive, \"OzLukTCRH8SDpmsIh1vZXvu7OrM=\", false, function () {\n  return [useActiveListUrls];\n});","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/lists/hooks.ts"],"names":["ChainId","Token","useMemo","useSelector","DEFAULT_LIST_OF_LISTS","DEFAULT_TOKEN_LIST","UNSUPPORTED_LIST_URLS","UNSUPPORTED_TOKEN_LIST","sortByListPriority","urlA","urlB","first","includes","indexOf","Number","MAX_SAFE_INTEGER","second","WrappedTokenInfo","constructor","tokenInfo","tags","chainId","address","decimals","symbol","name","logoURI","EMPTY_LIST","MAINNET","TESTNET","listCache","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","tagId","undefined","id","filter","x","Boolean","token","set","useAllLists","state","lists","byUrl","combineMaps","map1","map2","useCombinedTokenMapFromUrls","urls","slice","sort","allTokens","currentUrl","current","newTokens","Object","assign","error","console","useActiveListUrls","activeListUrls","url","useInactiveListUrls","allActiveListUrls","keys","useCombinedActiveList","activeTokens","defaultTokenMap","useCombinedInactiveList","allInactiveListUrls","useDefaultTokenList","useUnsupportedTokenList","localUnsupportedListMap","loadedUnsupportedListMap","useIsListActive"],"mappings":"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","sourcesContent":["import { ChainId, Token } from '@pancakeswap/sdk'\r\nimport { Tags, TokenInfo, TokenList } from '@uniswap/token-lists'\r\nimport { useMemo } from 'react'\r\nimport { useSelector } from 'react-redux'\r\nimport { DEFAULT_LIST_OF_LISTS } from 'config/constants/lists'\r\nimport { AppState } from '../index'\r\nimport DEFAULT_TOKEN_LIST from '../../config/constants/tokenLists/pancake-default.tokenlist.json'\r\nimport { UNSUPPORTED_LIST_URLS } from '../../config/constants/lists'\r\nimport UNSUPPORTED_TOKEN_LIST from '../../config/constants/tokenLists/pancake-unsupported.tokenlist.json'\r\n\r\ntype TagDetails = Tags[keyof Tags]\r\nexport interface TagInfo extends TagDetails {\r\n  id: string\r\n}\r\n\r\n// use ordering of default list of lists to assign priority\r\nfunction sortByListPriority(urlA: string, urlB: string) {\r\n  const first = DEFAULT_LIST_OF_LISTS.includes(urlA) ? DEFAULT_LIST_OF_LISTS.indexOf(urlA) : Number.MAX_SAFE_INTEGER\r\n  const second = DEFAULT_LIST_OF_LISTS.includes(urlB) ? DEFAULT_LIST_OF_LISTS.indexOf(urlB) : Number.MAX_SAFE_INTEGER\r\n\r\n  // need reverse order to make sure mapping includes top priority last\r\n  if (first < second) return 1\r\n  if (first > second) return -1\r\n  return 0\r\n}\r\n\r\n/**\r\n * Token instances created from token info.\r\n */\r\nexport class WrappedTokenInfo extends Token {\r\n  public readonly tokenInfo: TokenInfo\r\n\r\n  public readonly tags: TagInfo[]\r\n\r\n  constructor(tokenInfo: TokenInfo, tags: TagInfo[]) {\r\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name)\r\n    this.tokenInfo = tokenInfo\r\n    this.tags = tags\r\n  }\r\n\r\n  public get logoURI(): string | undefined {\r\n    return this.tokenInfo.logoURI\r\n  }\r\n}\r\n\r\nexport type TokenAddressMap = Readonly<\r\n  { [chainId in ChainId]: Readonly<{ [tokenAddress: string]: { token: WrappedTokenInfo; list: TokenList } }> }\r\n>\r\n\r\n/**\r\n * An empty result, useful as a default.\r\n */\r\nconst EMPTY_LIST: TokenAddressMap = {\r\n  [ChainId.MAINNET]: {},\r\n  [ChainId.TESTNET]: {},\r\n}\r\n\r\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\r\n  typeof WeakMap !== 'undefined' ? new WeakMap<TokenList, TokenAddressMap>() : null\r\n\r\nexport function listToTokenMap(list: TokenList): TokenAddressMap {\r\n  const result = listCache?.get(list)\r\n  if (result) return result\r\n\r\n  const map = list.tokens.reduce<TokenAddressMap>(\r\n    (tokenMap, tokenInfo) => {\r\n      const tags: TagInfo[] =\r\n        tokenInfo.tags\r\n          ?.map((tagId) => {\r\n            if (!list.tags?.[tagId]) return undefined\r\n            return { ...list.tags[tagId], id: tagId }\r\n          })\r\n          ?.filter((x): x is TagInfo => Boolean(x)) ?? []\r\n      const token = new WrappedTokenInfo(tokenInfo, tags)\r\n     // if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.')\r\n      return {\r\n        ...tokenMap,\r\n        [token.chainId]: {\r\n          ...tokenMap[token.chainId],\r\n          [token.address]: {\r\n            token,\r\n            list,\r\n          },\r\n        },\r\n      }\r\n    },\r\n    { ...EMPTY_LIST },\r\n  )\r\n  listCache?.set(list, map)\r\n  return map\r\n}\r\n\r\nexport function useAllLists(): {\r\n  readonly [url: string]: {\r\n    readonly current: TokenList | null\r\n    readonly pendingUpdate: TokenList | null\r\n    readonly loadingRequestId: string | null\r\n    readonly error: string | null\r\n  }\r\n} {\r\n  return useSelector<AppState, AppState['lists']['byUrl']>((state) => state.lists.byUrl)\r\n}\r\n\r\nfunction combineMaps(map1: TokenAddressMap, map2: TokenAddressMap): TokenAddressMap {\r\n  return {\r\n    [ChainId.MAINNET]: { ...map1[ChainId.MAINNET], ...map2[ChainId.MAINNET] },\r\n    [ChainId.TESTNET]: { ...map1[ChainId.TESTNET], ...map2[ChainId.TESTNET] },\r\n  }\r\n}\r\n\r\n// merge tokens contained within lists from urls\r\nfunction useCombinedTokenMapFromUrls(urls: string[] | undefined): TokenAddressMap {\r\n  const lists = useAllLists()\r\n\r\n  return useMemo(() => {\r\n    if (!urls) return EMPTY_LIST\r\n\r\n    return (\r\n      urls\r\n        .slice()\r\n        // sort by priority so top priority goes last\r\n        .sort(sortByListPriority)\r\n        .reduce((allTokens, currentUrl) => {\r\n          const current = lists[currentUrl]?.current\r\n          if (!current) return allTokens\r\n          try {\r\n            const newTokens = Object.assign(listToTokenMap(current))\r\n            return combineMaps(allTokens, newTokens)\r\n          } catch (error) {\r\n            console.error('Could not show token list due to error', error)\r\n            return allTokens\r\n          }\r\n        }, EMPTY_LIST)\r\n    )\r\n  }, [lists, urls])\r\n}\r\n\r\n// filter out unsupported lists\r\nexport function useActiveListUrls(): string[] | undefined {\r\n  return useSelector<AppState, AppState['lists']['activeListUrls']>((state) => state.lists.activeListUrls)?.filter(\r\n    (url) => !UNSUPPORTED_LIST_URLS.includes(url),\r\n  )\r\n}\r\n\r\nexport function useInactiveListUrls(): string[] {\r\n  const lists = useAllLists()\r\n  const allActiveListUrls = useActiveListUrls()\r\n  return Object.keys(lists).filter((url) => !allActiveListUrls?.includes(url) && !UNSUPPORTED_LIST_URLS.includes(url))\r\n}\r\n\r\n// get all the tokens from active lists, combine with local default tokens\r\nexport function useCombinedActiveList(): TokenAddressMap {\r\n  const activeListUrls = useActiveListUrls()\r\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls)\r\n  const defaultTokenMap = listToTokenMap(DEFAULT_TOKEN_LIST)\r\n  return combineMaps(activeTokens, defaultTokenMap)\r\n}\r\n\r\n// all tokens from inactive lists\r\nexport function useCombinedInactiveList(): TokenAddressMap {\r\n  const allInactiveListUrls: string[] = useInactiveListUrls()\r\n  return useCombinedTokenMapFromUrls(allInactiveListUrls)\r\n}\r\n\r\n// used to hide warnings on import for default tokens\r\nexport function useDefaultTokenList(): TokenAddressMap {\r\n  return listToTokenMap(DEFAULT_TOKEN_LIST)\r\n}\r\n\r\n// list of tokens not supported on interface, used to show warnings and prevent swaps and adds\r\nexport function useUnsupportedTokenList(): TokenAddressMap {\r\n  // get hard coded unsupported tokens\r\n  const localUnsupportedListMap = listToTokenMap(UNSUPPORTED_TOKEN_LIST)\r\n\r\n  // get any loaded unsupported tokens\r\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS)\r\n\r\n  // format into one token address map\r\n  return combineMaps(localUnsupportedListMap, loadedUnsupportedListMap)\r\n}\r\n\r\nexport function useIsListActive(url: string): boolean {\r\n  const activeListUrls = useActiveListUrls()\r\n  return Boolean(activeListUrls?.includes(url))\r\n}\r\n"]},"metadata":{},"sourceType":"module"}