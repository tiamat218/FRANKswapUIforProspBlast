{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { LotteryStatus } from 'config/constants/types';\nimport { multicallv2 } from 'utils/multicall';\nimport lotteryV2Abi from 'config/abi/lotteryV2.json';\nimport { NUM_ROUNDS_TO_CHECK_FOR_REWARDS } from 'config/constants/lottery';\nimport { getLotteryV2Address } from 'utils/addressHelpers';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData';\nconst lotteryAddress = getLotteryV2Address();\n\nconst fetchCakeRewardsForTickets = async winningTickets => {\n  const calls = winningTickets.map(winningTicket => {\n    const {\n      roundId,\n      id,\n      rewardBracket\n    } = winningTicket;\n    return {\n      name: 'viewRewardsForTicketId',\n      address: lotteryAddress,\n      params: [roundId, id, rewardBracket]\n    };\n  });\n\n  try {\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls);\n    const cakeTotal = cakeRewards.reduce((accum, cakeReward) => {\n      return accum.plus(new BigNumber(cakeReward[0].toString()));\n    }, BIG_ZERO);\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\n      return { ...winningTicket,\n        cakeReward: cakeRewards[index]\n      };\n    });\n    return {\n      ticketsWithUnclaimedRewards,\n      cakeTotal\n    };\n  } catch (error) {\n    console.error(error);\n    return {\n      ticketsWithUnclaimedRewards: null,\n      cakeTotal: null\n    };\n  }\n};\n\nconst getRewardBracketByNumber = (ticketNumber, finalNumber) => {\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n  // i.e. '1123456' should be evaluated as '6543211'\n  const ticketNumAsArray = ticketNumber.split('').reverse();\n  const winningNumsAsArray = finalNumber.split('').reverse();\n  const matchingNumbers = []; // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\n\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\n      break;\n    }\n\n    matchingNumbers.push(ticketNumAsArray[index]);\n  } // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\n\n\n  const rewardBracket = matchingNumbers.length - 1;\n  return rewardBracket;\n};\n\nexport const getWinningTickets = async roundDataAndUserTickets => {\n  const {\n    roundId,\n    userTickets,\n    finalNumber\n  } = roundDataAndUserTickets;\n  const ticketsWithRewardBrackets = userTickets.map(ticket => {\n    return {\n      roundId,\n      id: ticket.id,\n      number: ticket.number,\n      status: ticket.status,\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber)\n    };\n  }); // A rewardBracket of -1 means no matches. 0 and above means there has been a match\n\n  const allWinningTickets = ticketsWithRewardBrackets.filter(ticket => {\n    return ticket.rewardBracket >= 0;\n  }); // If ticket.status is true, the ticket has already been claimed\n\n  const unclaimedWinningTickets = allWinningTickets.filter(ticket => {\n    return !ticket.status;\n  });\n\n  if (unclaimedWinningTickets.length > 0) {\n    const {\n      ticketsWithUnclaimedRewards,\n      cakeTotal\n    } = await fetchCakeRewardsForTickets(unclaimedWinningTickets);\n    return {\n      ticketsWithUnclaimedRewards,\n      allWinningTickets,\n      cakeTotal,\n      roundId\n    };\n  }\n\n  if (allWinningTickets.length > 0) {\n    return {\n      ticketsWithUnclaimedRewards: null,\n      allWinningTickets,\n      cakeTotal: null,\n      roundId\n    };\n  }\n\n  return null;\n};\n\nconst getWinningNumbersForRound = (targetRoundId, lotteriesData) => {\n  const targetRound = lotteriesData.find(pastLottery => pastLottery.id === targetRoundId);\n  return targetRound === null || targetRound === void 0 ? void 0 : targetRound.finalNumber;\n};\n\nconst fetchUnclaimedUserRewards = async (account, userLotteryData, lotteriesData) => {\n  const {\n    rounds\n  } = userLotteryData; // If there is no user round history - return an empty array\n\n  if (rounds.length === 0) {\n    return [];\n  } // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\n\n\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\n    return [];\n  } // Filter out non-claimable rounds\n\n\n  const claimableRounds = rounds.filter(round => {\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE;\n  }); // Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\n\n  const roundsWithPossibleWinnings = claimableRounds.filter(round => {\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100;\n  }); // Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\n\n  const roundsToCheck = roundsWithPossibleWinnings.slice(0, NUM_ROUNDS_TO_CHECK_FOR_REWARDS);\n\n  if (roundsToCheck.length > 0) {\n    const idsToCheck = roundsToCheck.map(round => round.lotteryId);\n    const userTicketData = await fetchUserTicketsForMultipleRounds(idsToCheck, account);\n    const roundsWithTickets = userTicketData.filter(roundData => {\n      var _roundData$userTicket;\n\n      return (roundData === null || roundData === void 0 ? void 0 : (_roundData$userTicket = roundData.userTickets) === null || _roundData$userTicket === void 0 ? void 0 : _roundData$userTicket.length) > 0;\n    });\n    const roundDataAndWinningTickets = roundsWithTickets.map(roundData => {\n      return { ...roundData,\n        finalNumber: getWinningNumbersForRound(roundData.roundId, lotteriesData)\n      };\n    });\n    const winningTicketsForPastRounds = await Promise.all(roundDataAndWinningTickets.map(roundData => getWinningTickets(roundData))); // Filter out null values (returned when no winning tickets found for past round)\n\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(winningTicketData => winningTicketData !== null); // Filter to only rounds with unclaimed tickets\n\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(winningTicketData => winningTicketData.ticketsWithUnclaimedRewards);\n    return roundsWithUnclaimedWinningTickets;\n  } // All rounds claimed, return empty array\n\n\n  return [];\n};\n\nexport default fetchUnclaimedUserRewards;","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/lottery/fetchUnclaimedUserRewards.ts"],"names":["BigNumber","LotteryStatus","multicallv2","lotteryV2Abi","NUM_ROUNDS_TO_CHECK_FOR_REWARDS","getLotteryV2Address","BIG_ZERO","fetchUserTicketsForMultipleRounds","lotteryAddress","fetchCakeRewardsForTickets","winningTickets","calls","map","winningTicket","roundId","id","rewardBracket","name","address","params","cakeRewards","cakeTotal","reduce","accum","cakeReward","plus","toString","ticketsWithUnclaimedRewards","index","error","console","getRewardBracketByNumber","ticketNumber","finalNumber","ticketNumAsArray","split","reverse","winningNumsAsArray","matchingNumbers","length","push","getWinningTickets","roundDataAndUserTickets","userTickets","ticketsWithRewardBrackets","ticket","number","status","allWinningTickets","filter","unclaimedWinningTickets","getWinningNumbersForRound","targetRoundId","lotteriesData","targetRound","find","pastLottery","fetchUnclaimedUserRewards","account","userLotteryData","rounds","toLowerCase","claimableRounds","round","CLAIMABLE","roundsWithPossibleWinnings","claimed","parseInt","totalTickets","roundsToCheck","slice","idsToCheck","lotteryId","userTicketData","roundsWithTickets","roundData","roundDataAndWinningTickets","winningTicketsForPastRounds","Promise","all","roundsWithWinningTickets","winningTicketData","roundsWithUnclaimedWinningTickets"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\r\nimport { ethers } from 'ethers'\r\nimport { LotteryStatus, LotteryTicket, LotteryTicketClaimData } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryRoundGraphEntity } from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\r\nimport { NUM_ROUNDS_TO_CHECK_FOR_REWARDS } from 'config/constants/lottery'\r\nimport { getLotteryV2Address } from 'utils/addressHelpers'\r\nimport { BIG_ZERO } from 'utils/bigNumber'\r\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\r\n\r\ninterface RoundDataAndUserTickets {\r\n  roundId: string\r\n  userTickets: LotteryTicket[]\r\n  finalNumber: string\r\n}\r\n\r\nconst lotteryAddress = getLotteryV2Address()\r\n\r\nconst fetchCakeRewardsForTickets = async (\r\n  winningTickets: LotteryTicket[],\r\n): Promise<{ ticketsWithUnclaimedRewards: LotteryTicket[]; cakeTotal: BigNumber }> => {\r\n  const calls = winningTickets.map((winningTicket) => {\r\n    const { roundId, id, rewardBracket } = winningTicket\r\n    return {\r\n      name: 'viewRewardsForTicketId',\r\n      address: lotteryAddress,\r\n      params: [roundId, id, rewardBracket],\r\n    }\r\n  })\r\n\r\n  try {\r\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls)\r\n\r\n    const cakeTotal = cakeRewards.reduce((accum: BigNumber, cakeReward: ethers.BigNumber[]) => {\r\n      return accum.plus(new BigNumber(cakeReward[0].toString()))\r\n    }, BIG_ZERO)\r\n\r\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\r\n      return { ...winningTicket, cakeReward: cakeRewards[index] }\r\n    })\r\n    return { ticketsWithUnclaimedRewards, cakeTotal }\r\n  } catch (error) {\r\n    console.error(error)\r\n    return { ticketsWithUnclaimedRewards: null, cakeTotal: null }\r\n  }\r\n}\r\n\r\nconst getRewardBracketByNumber = (ticketNumber: string, finalNumber: string): number => {\r\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\r\n  // i.e. '1123456' should be evaluated as '6543211'\r\n  const ticketNumAsArray = ticketNumber.split('').reverse()\r\n  const winningNumsAsArray = finalNumber.split('').reverse()\r\n  const matchingNumbers = []\r\n\r\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\r\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\r\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\r\n      break\r\n    }\r\n    matchingNumbers.push(ticketNumAsArray[index])\r\n  }\r\n\r\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\r\n  const rewardBracket = matchingNumbers.length - 1\r\n  return rewardBracket\r\n}\r\n\r\nexport const getWinningTickets = async (\r\n  roundDataAndUserTickets: RoundDataAndUserTickets,\r\n): Promise<LotteryTicketClaimData> => {\r\n  const { roundId, userTickets, finalNumber } = roundDataAndUserTickets\r\n\r\n  const ticketsWithRewardBrackets = userTickets.map((ticket) => {\r\n    return {\r\n      roundId,\r\n      id: ticket.id,\r\n      number: ticket.number,\r\n      status: ticket.status,\r\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber),\r\n    }\r\n  })\r\n\r\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\r\n  const allWinningTickets = ticketsWithRewardBrackets.filter((ticket) => {\r\n    return ticket.rewardBracket >= 0\r\n  })\r\n\r\n  // If ticket.status is true, the ticket has already been claimed\r\n  const unclaimedWinningTickets = allWinningTickets.filter((ticket) => {\r\n    return !ticket.status\r\n  })\r\n\r\n  if (unclaimedWinningTickets.length > 0) {\r\n    const { ticketsWithUnclaimedRewards, cakeTotal } = await fetchCakeRewardsForTickets(unclaimedWinningTickets)\r\n    return { ticketsWithUnclaimedRewards, allWinningTickets, cakeTotal, roundId }\r\n  }\r\n\r\n  if (allWinningTickets.length > 0) {\r\n    return { ticketsWithUnclaimedRewards: null, allWinningTickets, cakeTotal: null, roundId }\r\n  }\r\n\r\n  return null\r\n}\r\n\r\nconst getWinningNumbersForRound = (targetRoundId: string, lotteriesData: LotteryRoundGraphEntity[]) => {\r\n  const targetRound = lotteriesData.find((pastLottery) => pastLottery.id === targetRoundId)\r\n  return targetRound?.finalNumber\r\n}\r\n\r\nconst fetchUnclaimedUserRewards = async (\r\n  account: string,\r\n  userLotteryData: LotteryUserGraphEntity,\r\n  lotteriesData: LotteryRoundGraphEntity[],\r\n): Promise<LotteryTicketClaimData[]> => {\r\n  const { rounds } = userLotteryData\r\n\r\n  // If there is no user round history - return an empty array\r\n  if (rounds.length === 0) {\r\n    return []\r\n  }\r\n\r\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\r\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\r\n    return []\r\n  }\r\n\r\n  // Filter out non-claimable rounds\r\n  const claimableRounds = rounds.filter((round) => {\r\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE\r\n  })\r\n\r\n  // Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\r\n  const roundsWithPossibleWinnings = claimableRounds.filter((round) => {\r\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100\r\n  })\r\n\r\n  // Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\r\n  const roundsToCheck = roundsWithPossibleWinnings.slice(0, NUM_ROUNDS_TO_CHECK_FOR_REWARDS)\r\n\r\n  if (roundsToCheck.length > 0) {\r\n    const idsToCheck = roundsToCheck.map((round) => round.lotteryId)\r\n    const userTicketData = await fetchUserTicketsForMultipleRounds(idsToCheck, account)\r\n    const roundsWithTickets = userTicketData.filter((roundData) => roundData?.userTickets?.length > 0)\r\n\r\n    const roundDataAndWinningTickets = roundsWithTickets.map((roundData) => {\r\n      return { ...roundData, finalNumber: getWinningNumbersForRound(roundData.roundId, lotteriesData) }\r\n    })\r\n\r\n    const winningTicketsForPastRounds = await Promise.all(\r\n      roundDataAndWinningTickets.map((roundData) => getWinningTickets(roundData)),\r\n    )\r\n\r\n    // Filter out null values (returned when no winning tickets found for past round)\r\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(\r\n      (winningTicketData) => winningTicketData !== null,\r\n    )\r\n\r\n    // Filter to only rounds with unclaimed tickets\r\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(\r\n      (winningTicketData) => winningTicketData.ticketsWithUnclaimedRewards,\r\n    )\r\n\r\n    return roundsWithUnclaimedWinningTickets\r\n  }\r\n  // All rounds claimed, return empty array\r\n  return []\r\n}\r\n\r\nexport default fetchUnclaimedUserRewards\r\n"]},"metadata":{},"sourceType":"module"}