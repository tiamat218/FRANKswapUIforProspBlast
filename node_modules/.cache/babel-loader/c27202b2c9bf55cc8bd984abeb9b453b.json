{"ast":null,"code":"import { ethers } from 'ethers';\nimport { getMulticallContract } from 'utils/contractHelpers';\nconst multicall = async (abi, calls) => {\n  try {\n    const multi = getMulticallContract();\n    const itf = new ethers.utils.Interface(abi);\n    const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n    const {\n      returnData\n    } = await multi.aggregate(calldata);\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call));\n    return res;\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n\n/**\r\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\r\n *\r\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\r\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\r\n */\nexport const multicallv2 = async (abi, calls, options = {\n  requireSuccess: true\n}) => {\n  const {\n    requireSuccess\n  } = options;\n  const multi = getMulticallContract();\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n  const returnData = await multi.tryAggregate(requireSuccess, calldata);\n  const res = returnData.map((call, i) => {\n    const [result, data] = call;\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null;\n  });\n  return res;\n};\nexport default multicall;","map":{"version":3,"names":["ethers","getMulticallContract","multicall","abi","calls","multi","itf","utils","Interface","calldata","map","call","address","toLowerCase","encodeFunctionData","name","params","returnData","aggregate","res","i","decodeFunctionResult","error","Error","multicallv2","options","requireSuccess","tryAggregate","result","data"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/utils/multicall.ts"],"sourcesContent":["import { ethers } from 'ethers'\r\nimport { getMulticallContract } from 'utils/contractHelpers'\r\nimport { MultiCallResponse } from './types'\r\n\r\nexport interface Call {\r\n  address: string // Address of the contract\r\n  name: string // Function name on the contract (example: balanceOf)\r\n  params?: any[] // Function params\r\n}\r\n\r\ninterface MulticallOptions {\r\n  requireSuccess?: boolean\r\n}\r\n\r\nconst multicall = async <T = any>(abi: any[], calls: Call[]): Promise<T> => {\r\n  try {\r\n    const multi = getMulticallContract()\r\n    const itf = new ethers.utils.Interface(abi)\r\n\r\n    const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\r\n    const { returnData } = await multi.aggregate(calldata)\r\n\r\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call))\r\n\r\n    return res\r\n  } catch (error) {\r\n    throw new Error(error)\r\n  }\r\n}\r\n\r\n/**\r\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\r\n *\r\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\r\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\r\n */\r\nexport const multicallv2 = async <T = any>(\r\n  abi: any[],\r\n  calls: Call[],\r\n  options: MulticallOptions = { requireSuccess: true },\r\n): Promise<MultiCallResponse<T>> => {\r\n  const { requireSuccess } = options\r\n  const multi = getMulticallContract()\r\n  const itf = new ethers.utils.Interface(abi)\r\n\r\n  const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\r\n  const returnData = await multi.tryAggregate(requireSuccess, calldata)\r\n  const res = returnData.map((call, i) => {\r\n    const [result, data] = call\r\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null\r\n  })\r\n\r\n  return res\r\n}\r\n\r\nexport default multicall\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B,SAASC,oBAAoB,QAAQ,uBAAuB;AAa5D,MAAMC,SAAS,GAAG,MAAAA,CAAgBC,GAAU,EAAEC,KAAa,KAAiB;EAC1E,IAAI;IACF,MAAMC,KAAK,GAAGJ,oBAAoB,CAAC,CAAC;IACpC,MAAMK,GAAG,GAAG,IAAIN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC;IAE3C,MAAMM,QAAQ,GAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,IAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,EAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,EAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC;IAClH,MAAM;MAAEC;IAAW,CAAC,GAAG,MAAMZ,KAAK,CAACa,SAAS,CAACT,QAAQ,CAAC;IAEtD,MAAMU,GAAG,GAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,EAAES,CAAC,KAAKd,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,EAAEJ,IAAI,CAAC,CAAC;IAEtF,OAAOQ,GAAG;EACZ,CAAC,CAAC,OAAOG,KAAK,EAAE;IACd,MAAM,IAAIC,KAAK,CAACD,KAAK,CAAC;EACxB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,WAAW,GAAG,MAAAA,CACzBrB,GAAU,EACVC,KAAa,EACbqB,OAAyB,GAAG;EAAEC,cAAc,EAAE;AAAK,CAAC,KAClB;EAClC,MAAM;IAAEA;EAAe,CAAC,GAAGD,OAAO;EAClC,MAAMpB,KAAK,GAAGJ,oBAAoB,CAAC,CAAC;EACpC,MAAMK,GAAG,GAAG,IAAIN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC;EAE3C,MAAMM,QAAQ,GAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,IAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,EAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,EAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC;EAClH,MAAMC,UAAU,GAAG,MAAMZ,KAAK,CAACsB,YAAY,CAACD,cAAc,EAAEjB,QAAQ,CAAC;EACrE,MAAMU,GAAG,GAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,EAAES,CAAC,KAAK;IACtC,MAAM,CAACQ,MAAM,EAAEC,IAAI,CAAC,GAAGlB,IAAI;IAC3B,OAAOiB,MAAM,GAAGtB,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,EAAEc,IAAI,CAAC,GAAG,IAAI;EACtE,CAAC,CAAC;EAEF,OAAOV,GAAG;AACZ,CAAC;AAED,eAAejB,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module"}