{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport maxBy from 'lodash/maxBy';\nimport merge from 'lodash/merge';\nimport range from 'lodash/range';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { HistoryFilter, PredictionStatus } from 'state/types';\nimport { getPredictionsContract } from 'utils/contractHelpers';\nimport { getBetHistory, transformBetResponse, makeFutureRoundResponse, makeRoundData, getRoundsData, getPredictionData, getLedgerData, makeLedgerData, serializePredictionsRoundsResponse, getClaimStatuses } from './helpers';\nconst PAST_ROUND_COUNT = 5;\nconst FUTURE_ROUND_COUNT = 2;\n\n// The estimated time it takes to broadcast\nexport const BLOCK_PADDING = 3;\nconst initialState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  currentRoundStartBlockNumber: 0,\n  intervalBlocks: 100,\n  bufferBlocks: 20,\n  minBetAmount: '1000000000000000',\n  rewardRate: 97,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  ledgers: {},\n  claimableStatuses: {}\n};\n\n// Thunks\n// V2 REFACTOR\n\nexport const initializePredictions = createAsyncThunk('predictions/intialize', async (account = null) => {\n  // Static values\n  const marketData = await getPredictionData();\n  const epochs = range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT);\n\n  // Round data\n  const roundsResponse = await getRoundsData(epochs);\n  const initialRoundData = roundsResponse.reduce((accum, roundResponse) => {\n    const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse);\n    return {\n      ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n  const initializedData = {\n    ...marketData,\n    rounds: initialRoundData,\n    ledgers: {},\n    claimableStatuses: {}\n  };\n  if (!account) {\n    return initializedData;\n  }\n\n  // Bet data\n  const ledgerResponses = await getLedgerData(account, epochs);\n\n  // Claim statuses\n  const claimableStatuses = await getClaimStatuses(account, epochs);\n  return merge({}, initializedData, {\n    ledgers: makeLedgerData(account, ledgerResponses, epochs),\n    claimableStatuses\n  });\n});\nexport const fetchRound = createAsyncThunk('predictions/fetchRound', async epoch => {\n  const predictionContract = getPredictionsContract();\n  const response = await predictionContract.rounds(epoch);\n  return serializePredictionsRoundsResponse(response);\n});\nexport const fetchRounds = createAsyncThunk('predictions/fetchRounds', async epochs => {\n  const rounds = await getRoundsData(epochs);\n  return rounds.reduce((accum, round) => {\n    if (!round) {\n      return accum;\n    }\n    const reduxNodeRound = serializePredictionsRoundsResponse(round);\n    return {\n      ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n});\nexport const fetchMarketData = createAsyncThunk('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData();\n  return marketData;\n});\nexport const fetchLedgerData = createAsyncThunk('predictions/fetchLedgerData', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getLedgerData(account, epochs);\n  return makeLedgerData(account, ledgers, epochs);\n});\nexport const fetchClaimableStatuses = createAsyncThunk('predictions/fetchClaimableStatuses', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getClaimStatuses(account, epochs);\n  return ledgers;\n});\n// END V2 REFACTOR\n\nexport const fetchHistory = createAsyncThunk('predictions/fetchHistory', async ({\n  account,\n  claimed\n}) => {\n  const response = await getBetHistory({\n    user: account.toLowerCase(),\n    claimed\n  });\n  const bets = response.map(transformBetResponse);\n  return {\n    account,\n    bets\n  };\n});\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action) => {\n      state.status = action.payload;\n    },\n    setHistoryPaneState: (state, action) => {\n      state.isHistoryPaneOpen = action.payload;\n      state.historyFilter = HistoryFilter.ALL;\n    },\n    setChartPaneState: (state, action) => {\n      state.isChartPaneOpen = action.payload;\n    },\n    setHistoryFilter: (state, action) => {\n      state.historyFilter = action.payload;\n    },\n    setCurrentEpoch: (state, action) => {\n      state.currentEpoch = action.payload;\n    },\n    setLastOraclePrice: (state, action) => {\n      state.lastOraclePrice = action.payload;\n    },\n    markBetHistoryAsCollected: (state, action) => {\n      const {\n        account,\n        betId\n      } = action.payload;\n      if (state.history[account]) {\n        const betIndex = state.history[account].findIndex(bet => bet.id === betId);\n        if (betIndex >= 0) {\n          state.history[account][betIndex].claimed = true;\n        }\n      }\n    }\n  },\n  extraReducers: builder => {\n    // Claimable statuses\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload);\n    });\n\n    // Ledger (bet) records\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload);\n    });\n\n    // Get static market data\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        intervalBlocks,\n        bufferBlocks,\n        minBetAmount,\n        rewardRate\n      } = action.payload;\n\n      // If the round has change add a new future round\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch');\n        const futureRound = makeFutureRoundResponse(newestRound.epoch + 1, newestRound.startBlock + (state.intervalBlocks + BLOCK_PADDING));\n        state.rounds[futureRound.epoch] = futureRound;\n        state.currentRoundStartBlockNumber = state.currentRoundStartBlockNumber + state.intervalBlocks + BLOCK_PADDING;\n      }\n      state.status = status;\n      state.currentEpoch = currentEpoch;\n      state.intervalBlocks = intervalBlocks;\n      state.bufferBlocks = bufferBlocks;\n      state.minBetAmount = minBetAmount;\n      state.rewardRate = rewardRate;\n    });\n\n    // Initialize predictions\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        bufferBlocks,\n        intervalBlocks,\n        rounds,\n        claimableStatuses,\n        rewardRate,\n        ledgers\n      } = action.payload;\n      const currentRoundStartBlockNumber = action.payload.rounds[currentEpoch].startBlock;\n      const futureRounds = [];\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(makeFutureRoundResponse(currentEpoch + i, currentRoundStartBlockNumber + (intervalBlocks + BLOCK_PADDING) * i));\n      }\n      return {\n        ...state,\n        status,\n        currentEpoch,\n        bufferBlocks,\n        intervalBlocks,\n        rewardRate,\n        currentRoundStartBlockNumber,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds))\n      };\n    });\n\n    // Get single round\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload\n      });\n    });\n\n    // Get multiple rounds\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload);\n    });\n\n    // Show History\n    builder.addCase(fetchHistory.pending, state => {\n      state.isFetchingHistory = true;\n    });\n    builder.addCase(fetchHistory.rejected, state => {\n      state.isFetchingHistory = false;\n    });\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const {\n        account,\n        bets\n      } = action.payload;\n      state.isFetchingHistory = false;\n      state.history[account] = bets;\n    });\n  }\n});\n\n// Actions\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markBetHistoryAsCollected\n} = predictionsSlice.actions;\nexport default predictionsSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","maxBy","merge","range","BIG_ZERO","HistoryFilter","PredictionStatus","getPredictionsContract","getBetHistory","transformBetResponse","makeFutureRoundResponse","makeRoundData","getRoundsData","getPredictionData","getLedgerData","makeLedgerData","serializePredictionsRoundsResponse","getClaimStatuses","PAST_ROUND_COUNT","FUTURE_ROUND_COUNT","BLOCK_PADDING","initialState","status","INITIAL","isLoading","isHistoryPaneOpen","isChartPaneOpen","isFetchingHistory","historyFilter","ALL","currentEpoch","currentRoundStartBlockNumber","intervalBlocks","bufferBlocks","minBetAmount","rewardRate","lastOraclePrice","toJSON","rounds","history","ledgers","claimableStatuses","initializePredictions","account","marketData","epochs","roundsResponse","initialRoundData","reduce","accum","roundResponse","reduxNodeRound","epoch","toString","initializedData","ledgerResponses","fetchRound","predictionContract","response","fetchRounds","round","fetchMarketData","fetchLedgerData","fetchClaimableStatuses","fetchHistory","claimed","user","toLowerCase","bets","map","predictionsSlice","name","reducers","setPredictionStatus","state","action","payload","setHistoryPaneState","setChartPaneState","setHistoryFilter","setCurrentEpoch","setLastOraclePrice","markBetHistoryAsCollected","betId","betIndex","findIndex","bet","id","extraReducers","builder","addCase","fulfilled","newestRound","Object","values","futureRound","startBlock","futureRounds","i","push","pending","rejected","actions","reducer"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/predictions/index.ts"],"sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\r\nimport maxBy from 'lodash/maxBy'\r\nimport merge from 'lodash/merge'\r\nimport range from 'lodash/range'\r\nimport { BIG_ZERO } from 'utils/bigNumber'\r\nimport { Bet, LedgerData, HistoryFilter, PredictionsState, PredictionStatus, ReduxNodeRound } from 'state/types'\r\nimport { getPredictionsContract } from 'utils/contractHelpers'\r\nimport {\r\n  getBetHistory,\r\n  transformBetResponse,\r\n  makeFutureRoundResponse,\r\n  makeRoundData,\r\n  getRoundsData,\r\n  getPredictionData,\r\n  MarketData,\r\n  getLedgerData,\r\n  makeLedgerData,\r\n  serializePredictionsRoundsResponse,\r\n  getClaimStatuses,\r\n} from './helpers'\r\n\r\nconst PAST_ROUND_COUNT = 5\r\nconst FUTURE_ROUND_COUNT = 2\r\n\r\n// The estimated time it takes to broadcast\r\nexport const BLOCK_PADDING = 3\r\n\r\nconst initialState: PredictionsState = {\r\n  status: PredictionStatus.INITIAL,\r\n  isLoading: false,\r\n  isHistoryPaneOpen: false,\r\n  isChartPaneOpen: false,\r\n  isFetchingHistory: false,\r\n  historyFilter: HistoryFilter.ALL,\r\n  currentEpoch: 0,\r\n  currentRoundStartBlockNumber: 0,\r\n  intervalBlocks: 100,\r\n  bufferBlocks: 20,\r\n  minBetAmount: '1000000000000000',\r\n  rewardRate: 97,\r\n  lastOraclePrice: BIG_ZERO.toJSON(),\r\n  rounds: {},\r\n  history: {},\r\n  ledgers: {},\r\n  claimableStatuses: {},\r\n}\r\n\r\n// Thunks\r\n// V2 REFACTOR\r\ntype PredictionInitialization = Pick<\r\n  PredictionsState,\r\n  | 'status'\r\n  | 'currentEpoch'\r\n  | 'intervalBlocks'\r\n  | 'bufferBlocks'\r\n  | 'minBetAmount'\r\n  | 'rewardRate'\r\n  | 'rounds'\r\n  | 'ledgers'\r\n  | 'claimableStatuses'\r\n>\r\nexport const initializePredictions = createAsyncThunk<PredictionInitialization, string>(\r\n  'predictions/intialize',\r\n  async (account = null) => {\r\n    // Static values\r\n    const marketData = await getPredictionData()\r\n    const epochs = range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT)\r\n\r\n    // Round data\r\n    const roundsResponse = await getRoundsData(epochs)\r\n    const initialRoundData: { [key: string]: ReduxNodeRound } = roundsResponse.reduce((accum, roundResponse) => {\r\n      const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse)\r\n\r\n      return {\r\n        ...accum,\r\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\r\n      }\r\n    }, {})\r\n\r\n    const initializedData = {\r\n      ...marketData,\r\n      rounds: initialRoundData,\r\n      ledgers: {},\r\n      claimableStatuses: {},\r\n    }\r\n\r\n    if (!account) {\r\n      return initializedData\r\n    }\r\n\r\n    // Bet data\r\n    const ledgerResponses = await getLedgerData(account, epochs)\r\n\r\n    // Claim statuses\r\n    const claimableStatuses = await getClaimStatuses(account, epochs)\r\n\r\n    return merge({}, initializedData, {\r\n      ledgers: makeLedgerData(account, ledgerResponses, epochs),\r\n      claimableStatuses,\r\n    })\r\n  },\r\n)\r\n\r\nexport const fetchRound = createAsyncThunk<ReduxNodeRound, number>('predictions/fetchRound', async (epoch) => {\r\n  const predictionContract = getPredictionsContract()\r\n  const response = await predictionContract.rounds(epoch)\r\n  return serializePredictionsRoundsResponse(response)\r\n})\r\n\r\nexport const fetchRounds = createAsyncThunk<{ [key: string]: ReduxNodeRound }, number[]>(\r\n  'predictions/fetchRounds',\r\n  async (epochs) => {\r\n    const rounds = await getRoundsData(epochs)\r\n    return rounds.reduce((accum, round) => {\r\n      if (!round) {\r\n        return accum\r\n      }\r\n\r\n      const reduxNodeRound = serializePredictionsRoundsResponse(round)\r\n\r\n      return {\r\n        ...accum,\r\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\r\n      }\r\n    }, {})\r\n  },\r\n)\r\n\r\nexport const fetchMarketData = createAsyncThunk<MarketData>('predictions/fetchMarketData', async () => {\r\n  const marketData = await getPredictionData()\r\n  return marketData\r\n})\r\n\r\nexport const fetchLedgerData = createAsyncThunk<LedgerData, { account: string; epochs: number[] }>(\r\n  'predictions/fetchLedgerData',\r\n  async ({ account, epochs }) => {\r\n    const ledgers = await getLedgerData(account, epochs)\r\n    return makeLedgerData(account, ledgers, epochs)\r\n  },\r\n)\r\n\r\nexport const fetchClaimableStatuses = createAsyncThunk<\r\n  PredictionsState['claimableStatuses'],\r\n  { account: string; epochs: number[] }\r\n>('predictions/fetchClaimableStatuses', async ({ account, epochs }) => {\r\n  const ledgers = await getClaimStatuses(account, epochs)\r\n  return ledgers\r\n})\r\n// END V2 REFACTOR\r\n\r\nexport const fetchHistory = createAsyncThunk<{ account: string; bets: Bet[] }, { account: string; claimed?: boolean }>(\r\n  'predictions/fetchHistory',\r\n  async ({ account, claimed }) => {\r\n    const response = await getBetHistory({\r\n      user: account.toLowerCase(),\r\n      claimed,\r\n    })\r\n    const bets = response.map(transformBetResponse)\r\n\r\n    return { account, bets }\r\n  },\r\n)\r\n\r\nexport const predictionsSlice = createSlice({\r\n  name: 'predictions',\r\n  initialState,\r\n  reducers: {\r\n    setPredictionStatus: (state, action: PayloadAction<PredictionStatus>) => {\r\n      state.status = action.payload\r\n    },\r\n    setHistoryPaneState: (state, action: PayloadAction<boolean>) => {\r\n      state.isHistoryPaneOpen = action.payload\r\n      state.historyFilter = HistoryFilter.ALL\r\n    },\r\n    setChartPaneState: (state, action: PayloadAction<boolean>) => {\r\n      state.isChartPaneOpen = action.payload\r\n    },\r\n    setHistoryFilter: (state, action: PayloadAction<HistoryFilter>) => {\r\n      state.historyFilter = action.payload\r\n    },\r\n    setCurrentEpoch: (state, action: PayloadAction<number>) => {\r\n      state.currentEpoch = action.payload\r\n    },\r\n    setLastOraclePrice: (state, action: PayloadAction<string>) => {\r\n      state.lastOraclePrice = action.payload\r\n    },\r\n    markBetHistoryAsCollected: (state, action: PayloadAction<{ account: string; betId: string }>) => {\r\n      const { account, betId } = action.payload\r\n\r\n      if (state.history[account]) {\r\n        const betIndex = state.history[account].findIndex((bet) => bet.id === betId)\r\n\r\n        if (betIndex >= 0) {\r\n          state.history[account][betIndex].claimed = true\r\n        }\r\n      }\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    // Claimable statuses\r\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\r\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload)\r\n    })\r\n\r\n    // Ledger (bet) records\r\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\r\n      state.ledgers = merge({}, state.ledgers, action.payload)\r\n    })\r\n\r\n    // Get static market data\r\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\r\n      const { status, currentEpoch, intervalBlocks, bufferBlocks, minBetAmount, rewardRate } = action.payload\r\n\r\n      // If the round has change add a new future round\r\n      if (state.currentEpoch !== currentEpoch) {\r\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch')\r\n        const futureRound = makeFutureRoundResponse(\r\n          newestRound.epoch + 1,\r\n          newestRound.startBlock + (state.intervalBlocks + BLOCK_PADDING),\r\n        )\r\n\r\n        state.rounds[futureRound.epoch] = futureRound\r\n        state.currentRoundStartBlockNumber = state.currentRoundStartBlockNumber + state.intervalBlocks + BLOCK_PADDING\r\n      }\r\n\r\n      state.status = status\r\n      state.currentEpoch = currentEpoch\r\n      state.intervalBlocks = intervalBlocks\r\n      state.bufferBlocks = bufferBlocks\r\n      state.minBetAmount = minBetAmount\r\n      state.rewardRate = rewardRate\r\n    })\r\n\r\n    // Initialize predictions\r\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\r\n      const { status, currentEpoch, bufferBlocks, intervalBlocks, rounds, claimableStatuses, rewardRate, ledgers } =\r\n        action.payload\r\n      const currentRoundStartBlockNumber = action.payload.rounds[currentEpoch].startBlock\r\n      const futureRounds: ReduxNodeRound[] = []\r\n\r\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\r\n        futureRounds.push(\r\n          makeFutureRoundResponse(\r\n            currentEpoch + i,\r\n            currentRoundStartBlockNumber + (intervalBlocks + BLOCK_PADDING) * i,\r\n          ),\r\n        )\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        status,\r\n        currentEpoch,\r\n        bufferBlocks,\r\n        intervalBlocks,\r\n        rewardRate,\r\n        currentRoundStartBlockNumber,\r\n        claimableStatuses,\r\n        ledgers,\r\n        rounds: merge({}, rounds, makeRoundData(futureRounds)),\r\n      }\r\n    })\r\n\r\n    // Get single round\r\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\r\n      state.rounds = merge({}, state.rounds, {\r\n        [action.payload.epoch.toString()]: action.payload,\r\n      })\r\n    })\r\n\r\n    // Get multiple rounds\r\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\r\n      state.rounds = merge({}, state.rounds, action.payload)\r\n    })\r\n\r\n    // Show History\r\n    builder.addCase(fetchHistory.pending, (state) => {\r\n      state.isFetchingHistory = true\r\n    })\r\n    builder.addCase(fetchHistory.rejected, (state) => {\r\n      state.isFetchingHistory = false\r\n    })\r\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\r\n      const { account, bets } = action.payload\r\n\r\n      state.isFetchingHistory = false\r\n      state.history[account] = bets\r\n    })\r\n  },\r\n})\r\n\r\n// Actions\r\nexport const {\r\n  setChartPaneState,\r\n  setCurrentEpoch,\r\n  setHistoryFilter,\r\n  setHistoryPaneState,\r\n  setPredictionStatus,\r\n  setLastOraclePrice,\r\n  markBetHistoryAsCollected,\r\n} = predictionsSlice.actions\r\n\r\nexport default predictionsSlice.reducer\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}