{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { LotteryStatus } from 'config/constants/types';\nimport { multicallv2 } from 'utils/multicall';\nimport lotteryV2Abi from 'config/abi/lotteryV2.json';\nimport { NUM_ROUNDS_TO_CHECK_FOR_REWARDS } from 'config/constants/lottery';\nimport { getLotteryV2Address } from 'utils/addressHelpers';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData';\nconst lotteryAddress = getLotteryV2Address();\nconst fetchCakeRewardsForTickets = async winningTickets => {\n  const calls = winningTickets.map(winningTicket => {\n    const {\n      roundId,\n      id,\n      rewardBracket\n    } = winningTicket;\n    return {\n      name: 'viewRewardsForTicketId',\n      address: lotteryAddress,\n      params: [roundId, id, rewardBracket]\n    };\n  });\n  try {\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls);\n    const cakeTotal = cakeRewards.reduce((accum, cakeReward) => {\n      return accum.plus(new BigNumber(cakeReward[0].toString()));\n    }, BIG_ZERO);\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\n      return {\n        ...winningTicket,\n        cakeReward: cakeRewards[index]\n      };\n    });\n    return {\n      ticketsWithUnclaimedRewards,\n      cakeTotal\n    };\n  } catch (error) {\n    console.error(error);\n    return {\n      ticketsWithUnclaimedRewards: null,\n      cakeTotal: null\n    };\n  }\n};\nconst getRewardBracketByNumber = (ticketNumber, finalNumber) => {\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n  // i.e. '1123456' should be evaluated as '6543211'\n  const ticketNumAsArray = ticketNumber.split('').reverse();\n  const winningNumsAsArray = finalNumber.split('').reverse();\n  const matchingNumbers = [];\n\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\n      break;\n    }\n    matchingNumbers.push(ticketNumAsArray[index]);\n  }\n\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\n  const rewardBracket = matchingNumbers.length - 1;\n  return rewardBracket;\n};\nexport const getWinningTickets = async roundDataAndUserTickets => {\n  const {\n    roundId,\n    userTickets,\n    finalNumber\n  } = roundDataAndUserTickets;\n  const ticketsWithRewardBrackets = userTickets.map(ticket => {\n    return {\n      roundId,\n      id: ticket.id,\n      number: ticket.number,\n      status: ticket.status,\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber)\n    };\n  });\n\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\n  const allWinningTickets = ticketsWithRewardBrackets.filter(ticket => {\n    return ticket.rewardBracket >= 0;\n  });\n\n  // If ticket.status is true, the ticket has already been claimed\n  const unclaimedWinningTickets = allWinningTickets.filter(ticket => {\n    return !ticket.status;\n  });\n  if (unclaimedWinningTickets.length > 0) {\n    const {\n      ticketsWithUnclaimedRewards,\n      cakeTotal\n    } = await fetchCakeRewardsForTickets(unclaimedWinningTickets);\n    return {\n      ticketsWithUnclaimedRewards,\n      allWinningTickets,\n      cakeTotal,\n      roundId\n    };\n  }\n  if (allWinningTickets.length > 0) {\n    return {\n      ticketsWithUnclaimedRewards: null,\n      allWinningTickets,\n      cakeTotal: null,\n      roundId\n    };\n  }\n  return null;\n};\nconst getWinningNumbersForRound = (targetRoundId, lotteriesData) => {\n  const targetRound = lotteriesData.find(pastLottery => pastLottery.id === targetRoundId);\n  return targetRound === null || targetRound === void 0 ? void 0 : targetRound.finalNumber;\n};\nconst fetchUnclaimedUserRewards = async (account, userLotteryData, lotteriesData) => {\n  const {\n    rounds\n  } = userLotteryData;\n\n  // If there is no user round history - return an empty array\n  if (rounds.length === 0) {\n    return [];\n  }\n\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\n    return [];\n  }\n\n  // Filter out non-claimable rounds\n  const claimableRounds = rounds.filter(round => {\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE;\n  });\n\n  // Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\n  const roundsWithPossibleWinnings = claimableRounds.filter(round => {\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100;\n  });\n\n  // Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\n  const roundsToCheck = roundsWithPossibleWinnings.slice(0, NUM_ROUNDS_TO_CHECK_FOR_REWARDS);\n  if (roundsToCheck.length > 0) {\n    const idsToCheck = roundsToCheck.map(round => round.lotteryId);\n    const userTicketData = await fetchUserTicketsForMultipleRounds(idsToCheck, account);\n    const roundsWithTickets = userTicketData.filter(roundData => {\n      var _roundData$userTicket;\n      return (roundData === null || roundData === void 0 ? void 0 : (_roundData$userTicket = roundData.userTickets) === null || _roundData$userTicket === void 0 ? void 0 : _roundData$userTicket.length) > 0;\n    });\n    const roundDataAndWinningTickets = roundsWithTickets.map(roundData => {\n      return {\n        ...roundData,\n        finalNumber: getWinningNumbersForRound(roundData.roundId, lotteriesData)\n      };\n    });\n    const winningTicketsForPastRounds = await Promise.all(roundDataAndWinningTickets.map(roundData => getWinningTickets(roundData)));\n\n    // Filter out null values (returned when no winning tickets found for past round)\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(winningTicketData => winningTicketData !== null);\n\n    // Filter to only rounds with unclaimed tickets\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(winningTicketData => winningTicketData.ticketsWithUnclaimedRewards);\n    return roundsWithUnclaimedWinningTickets;\n  }\n  // All rounds claimed, return empty array\n  return [];\n};\nexport default fetchUnclaimedUserRewards;","map":{"version":3,"names":["BigNumber","LotteryStatus","multicallv2","lotteryV2Abi","NUM_ROUNDS_TO_CHECK_FOR_REWARDS","getLotteryV2Address","BIG_ZERO","fetchUserTicketsForMultipleRounds","lotteryAddress","fetchCakeRewardsForTickets","winningTickets","calls","map","winningTicket","roundId","id","rewardBracket","name","address","params","cakeRewards","cakeTotal","reduce","accum","cakeReward","plus","toString","ticketsWithUnclaimedRewards","index","error","console","getRewardBracketByNumber","ticketNumber","finalNumber","ticketNumAsArray","split","reverse","winningNumsAsArray","matchingNumbers","length","push","getWinningTickets","roundDataAndUserTickets","userTickets","ticketsWithRewardBrackets","ticket","number","status","allWinningTickets","filter","unclaimedWinningTickets","getWinningNumbersForRound","targetRoundId","lotteriesData","targetRound","find","pastLottery","fetchUnclaimedUserRewards","account","userLotteryData","rounds","toLowerCase","claimableRounds","round","CLAIMABLE","roundsWithPossibleWinnings","claimed","parseInt","totalTickets","roundsToCheck","slice","idsToCheck","lotteryId","userTicketData","roundsWithTickets","roundData","_roundData$userTicket","roundDataAndWinningTickets","winningTicketsForPastRounds","Promise","all","roundsWithWinningTickets","winningTicketData","roundsWithUnclaimedWinningTickets"],"sources":["C:/Users/Devrim/Documents/swapUIforProspBlast/src/state/lottery/fetchUnclaimedUserRewards.ts"],"sourcesContent":["import BigNumber from 'bignumber.js'\r\nimport { ethers } from 'ethers'\r\nimport { LotteryStatus, LotteryTicket, LotteryTicketClaimData } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryRoundGraphEntity } from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\r\nimport { NUM_ROUNDS_TO_CHECK_FOR_REWARDS } from 'config/constants/lottery'\r\nimport { getLotteryV2Address } from 'utils/addressHelpers'\r\nimport { BIG_ZERO } from 'utils/bigNumber'\r\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\r\n\r\ninterface RoundDataAndUserTickets {\r\n  roundId: string\r\n  userTickets: LotteryTicket[]\r\n  finalNumber: string\r\n}\r\n\r\nconst lotteryAddress = getLotteryV2Address()\r\n\r\nconst fetchCakeRewardsForTickets = async (\r\n  winningTickets: LotteryTicket[],\r\n): Promise<{ ticketsWithUnclaimedRewards: LotteryTicket[]; cakeTotal: BigNumber }> => {\r\n  const calls = winningTickets.map((winningTicket) => {\r\n    const { roundId, id, rewardBracket } = winningTicket\r\n    return {\r\n      name: 'viewRewardsForTicketId',\r\n      address: lotteryAddress,\r\n      params: [roundId, id, rewardBracket],\r\n    }\r\n  })\r\n\r\n  try {\r\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls)\r\n\r\n    const cakeTotal = cakeRewards.reduce((accum: BigNumber, cakeReward: ethers.BigNumber[]) => {\r\n      return accum.plus(new BigNumber(cakeReward[0].toString()))\r\n    }, BIG_ZERO)\r\n\r\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\r\n      return { ...winningTicket, cakeReward: cakeRewards[index] }\r\n    })\r\n    return { ticketsWithUnclaimedRewards, cakeTotal }\r\n  } catch (error) {\r\n    console.error(error)\r\n    return { ticketsWithUnclaimedRewards: null, cakeTotal: null }\r\n  }\r\n}\r\n\r\nconst getRewardBracketByNumber = (ticketNumber: string, finalNumber: string): number => {\r\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\r\n  // i.e. '1123456' should be evaluated as '6543211'\r\n  const ticketNumAsArray = ticketNumber.split('').reverse()\r\n  const winningNumsAsArray = finalNumber.split('').reverse()\r\n  const matchingNumbers = []\r\n\r\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\r\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\r\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\r\n      break\r\n    }\r\n    matchingNumbers.push(ticketNumAsArray[index])\r\n  }\r\n\r\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\r\n  const rewardBracket = matchingNumbers.length - 1\r\n  return rewardBracket\r\n}\r\n\r\nexport const getWinningTickets = async (\r\n  roundDataAndUserTickets: RoundDataAndUserTickets,\r\n): Promise<LotteryTicketClaimData> => {\r\n  const { roundId, userTickets, finalNumber } = roundDataAndUserTickets\r\n\r\n  const ticketsWithRewardBrackets = userTickets.map((ticket) => {\r\n    return {\r\n      roundId,\r\n      id: ticket.id,\r\n      number: ticket.number,\r\n      status: ticket.status,\r\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber),\r\n    }\r\n  })\r\n\r\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\r\n  const allWinningTickets = ticketsWithRewardBrackets.filter((ticket) => {\r\n    return ticket.rewardBracket >= 0\r\n  })\r\n\r\n  // If ticket.status is true, the ticket has already been claimed\r\n  const unclaimedWinningTickets = allWinningTickets.filter((ticket) => {\r\n    return !ticket.status\r\n  })\r\n\r\n  if (unclaimedWinningTickets.length > 0) {\r\n    const { ticketsWithUnclaimedRewards, cakeTotal } = await fetchCakeRewardsForTickets(unclaimedWinningTickets)\r\n    return { ticketsWithUnclaimedRewards, allWinningTickets, cakeTotal, roundId }\r\n  }\r\n\r\n  if (allWinningTickets.length > 0) {\r\n    return { ticketsWithUnclaimedRewards: null, allWinningTickets, cakeTotal: null, roundId }\r\n  }\r\n\r\n  return null\r\n}\r\n\r\nconst getWinningNumbersForRound = (targetRoundId: string, lotteriesData: LotteryRoundGraphEntity[]) => {\r\n  const targetRound = lotteriesData.find((pastLottery) => pastLottery.id === targetRoundId)\r\n  return targetRound?.finalNumber\r\n}\r\n\r\nconst fetchUnclaimedUserRewards = async (\r\n  account: string,\r\n  userLotteryData: LotteryUserGraphEntity,\r\n  lotteriesData: LotteryRoundGraphEntity[],\r\n): Promise<LotteryTicketClaimData[]> => {\r\n  const { rounds } = userLotteryData\r\n\r\n  // If there is no user round history - return an empty array\r\n  if (rounds.length === 0) {\r\n    return []\r\n  }\r\n\r\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\r\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\r\n    return []\r\n  }\r\n\r\n  // Filter out non-claimable rounds\r\n  const claimableRounds = rounds.filter((round) => {\r\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE\r\n  })\r\n\r\n  // Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\r\n  const roundsWithPossibleWinnings = claimableRounds.filter((round) => {\r\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100\r\n  })\r\n\r\n  // Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\r\n  const roundsToCheck = roundsWithPossibleWinnings.slice(0, NUM_ROUNDS_TO_CHECK_FOR_REWARDS)\r\n\r\n  if (roundsToCheck.length > 0) {\r\n    const idsToCheck = roundsToCheck.map((round) => round.lotteryId)\r\n    const userTicketData = await fetchUserTicketsForMultipleRounds(idsToCheck, account)\r\n    const roundsWithTickets = userTicketData.filter((roundData) => roundData?.userTickets?.length > 0)\r\n\r\n    const roundDataAndWinningTickets = roundsWithTickets.map((roundData) => {\r\n      return { ...roundData, finalNumber: getWinningNumbersForRound(roundData.roundId, lotteriesData) }\r\n    })\r\n\r\n    const winningTicketsForPastRounds = await Promise.all(\r\n      roundDataAndWinningTickets.map((roundData) => getWinningTickets(roundData)),\r\n    )\r\n\r\n    // Filter out null values (returned when no winning tickets found for past round)\r\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(\r\n      (winningTicketData) => winningTicketData !== null,\r\n    )\r\n\r\n    // Filter to only rounds with unclaimed tickets\r\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(\r\n      (winningTicketData) => winningTicketData.ticketsWithUnclaimedRewards,\r\n    )\r\n\r\n    return roundsWithUnclaimedWinningTickets\r\n  }\r\n  // All rounds claimed, return empty array\r\n  return []\r\n}\r\n\r\nexport default fetchUnclaimedUserRewards\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}