{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints';\nimport { ethers } from 'ethers';\nimport { BetPosition, PredictionStatus } from 'state/types';\nimport { multicallv2 } from 'utils/multicall';\nimport predictionsAbi from 'config/abi/predictions.json';\nimport { getPredictionsAddress } from 'utils/addressHelpers';\nimport { getRoundBaseFields, getBetBaseFields, getUserBaseFields } from './queries';\nexport let Result;\n(function (Result) {\n  Result[\"WIN\"] = \"win\";\n  Result[\"LOSE\"] = \"lose\";\n  Result[\"CANCELED\"] = \"canceled\";\n  Result[\"LIVE\"] = \"live\";\n})(Result || (Result = {}));\nexport const numberOrNull = value => {\n  if (value === null) {\n    return null;\n  }\n  const valueNum = Number(value);\n  return Number.isNaN(valueNum) ? null : valueNum;\n};\nexport const transformBetResponse = betResponse => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    claimedHash: betResponse.claimedHash,\n    user: {\n      id: betResponse.user.id,\n      address: betResponse.user.address,\n      block: numberOrNull(betResponse.user.block),\n      totalBets: numberOrNull(betResponse.user.totalBets),\n      totalBNB: numberOrNull(betResponse.user.totalBNB)\n    }\n  };\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round);\n  }\n  return bet;\n};\nexport const transformRoundResponse = roundResponse => {\n  const {\n    id,\n    epoch,\n    failed,\n    startBlock,\n    startAt,\n    lockAt,\n    lockBlock,\n    lockPrice,\n    endBlock,\n    closePrice,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bearBets,\n    bearAmount,\n    bullAmount,\n    position,\n    bets = []\n  } = roundResponse;\n  const getRoundPosition = positionResponse => {\n    if (positionResponse === 'Bull') {\n      return BetPosition.BULL;\n    }\n    if (positionResponse === 'Bear') {\n      return BetPosition.BEAR;\n    }\n    return null;\n  };\n  return {\n    id,\n    failed,\n    epoch: numberOrNull(epoch),\n    startBlock: numberOrNull(startBlock),\n    startAt: numberOrNull(startAt),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\n    endBlock: numberOrNull(endBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : null,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bearBets: numberOrNull(bearBets),\n    bearAmount: numberOrNull(bearAmount),\n    bullAmount: numberOrNull(bullAmount),\n    position: getRoundPosition(position),\n    bets: bets.map(transformBetResponse)\n  };\n};\nexport const transformTotalWonResponse = (marketResponse, roundResponse) => {\n  const houseRounds = roundResponse.reduce((accum, round) => {\n    return accum + (round.totalAmount ? parseFloat(round.totalAmount) : 0);\n  }, 0);\n  const totalBNB = marketResponse.totalBNB ? parseFloat(marketResponse.totalBNB) : 0;\n  const totalBNBTreasury = marketResponse.totalBNBTreasury ? parseFloat(marketResponse.totalBNBTreasury) : 0;\n  return Math.max(totalBNB - (totalBNBTreasury + houseRounds), 0);\n};\nexport const getRoundResult = (bet, currentEpoch) => {\n  const {\n    round\n  } = bet;\n  if (round.failed) {\n    return Result.CANCELED;\n  }\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE;\n  }\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR;\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE;\n};\n\n/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */\nexport const getCanClaim = bet => {\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true);\n};\n\n/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */\nexport const getUnclaimedWinningBets = bets => {\n  return bets.filter(getCanClaim);\n};\nexport const getTotalWon = async () => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getTotalWonData($position: String) {\n        market(id: 1) {\n          totalBNB\n          totalBNBTreasury\n        }\n        rounds(where: { position: $position }) {\n          totalAmount\n        }\n      }\n    `, {\n    position: BetPosition.HOUSE\n  });\n  return transformTotalWonResponse(response.market, response.rounds);\n};\nexport const getBetHistory = async (where = {}, first = 1000, skip = 0) => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `, {\n    first,\n    skip,\n    where\n  });\n  return response.bets;\n};\nexport const getBet = async betId => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `, {\n    id: betId.toLowerCase()\n  });\n  return response.bet;\n};\n\n// V2 REFACTOR\nexport const getLedgerData = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const ledgerCalls = epochs.map(epoch => ({\n    address,\n    name: 'ledger',\n    params: [epoch, account]\n  }));\n  const response = await multicallv2(predictionsAbi, ledgerCalls);\n  return response;\n};\nexport const getClaimStatuses = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const claimableCalls = epochs.map(epoch => ({\n    address,\n    name: 'claimable',\n    params: [epoch, account]\n  }));\n  const claimableResponses = await multicallv2(predictionsAbi, claimableCalls);\n\n  // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\n  // This can be removed in Predictions V2\n  const ledgerResponses = await getLedgerData(account, epochs);\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\n    const {\n      amount,\n      claimed\n    } = ledgerResponses[index];\n    const epoch = epochs[index];\n    const [claimable] = claimableResponse;\n    return {\n      ...accum,\n      [epoch]: claimable && amount.gt(0) && !claimed\n    };\n  }, {});\n};\nexport const getPredictionData = async () => {\n  const address = getPredictionsAddress();\n  const staticCalls = ['currentEpoch', 'intervalBlocks', 'minBetAmount', 'paused', 'bufferBlocks', 'rewardRate'].map(method => ({\n    address,\n    name: method\n  }));\n  const [[currentEpoch], [intervalBlocks], [minBetAmount], [paused], [bufferBlocks], [rewardRate]] = await multicallv2(predictionsAbi, staticCalls);\n  return {\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: currentEpoch.toNumber(),\n    intervalBlocks: intervalBlocks.toNumber(),\n    bufferBlocks: bufferBlocks.toNumber(),\n    minBetAmount: minBetAmount.toString(),\n    rewardRate: rewardRate.toNumber()\n  };\n};\nexport const getRoundsData = async epochs => {\n  const address = getPredictionsAddress();\n  const calls = epochs.map(epoch => ({\n    address,\n    name: 'rounds',\n    params: [epoch]\n  }));\n  const response = await multicallv2(predictionsAbi, calls);\n  return response;\n};\nexport const makeFutureRoundResponse = (epoch, startBlock) => {\n  return {\n    epoch,\n    startBlock,\n    lockBlock: null,\n    endBlock: null,\n    lockPrice: null,\n    closePrice: null,\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\n    oracleCalled: false\n  };\n};\nexport const makeRoundData = rounds => {\n  return rounds.reduce((accum, round) => {\n    return {\n      ...accum,\n      [round.epoch.toString()]: round\n    };\n  }, {});\n};\nexport const serializePredictionsLedgerResponse = ledgerResponse => ({\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\n  amount: ledgerResponse.amount.toJSON(),\n  claimed: ledgerResponse.claimed\n});\nexport const makeLedgerData = (account, ledgers, epochs) => {\n  return ledgers.reduce((accum, ledgerResponse, index) => {\n    if (!ledgerResponse) {\n      return accum;\n    }\n\n    // If the amount is zero that means the user did not bet\n    if (ledgerResponse.amount.eq(0)) {\n      return accum;\n    }\n    const epoch = epochs[index].toString();\n    return {\n      ...accum,\n      [account]: {\n        ...accum[account],\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse)\n      }\n    };\n  }, {});\n};\n\n/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */\nexport const serializePredictionsRoundsResponse = response => {\n  const {\n    epoch,\n    startBlock,\n    lockBlock,\n    endBlock,\n    lockPrice,\n    closePrice,\n    totalAmount,\n    bullAmount,\n    bearAmount,\n    rewardAmount,\n    rewardBaseCalAmount,\n    oracleCalled\n  } = response;\n  return {\n    epoch: epoch.toNumber(),\n    startBlock: startBlock.toNumber(),\n    lockBlock: lockBlock.toNumber(),\n    endBlock: endBlock.toNumber(),\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\n    totalAmount: totalAmount.toJSON(),\n    bullAmount: bullAmount.toJSON(),\n    bearAmount: bearAmount.toJSON(),\n    rewardAmount: rewardAmount.toJSON(),\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\n    oracleCalled\n  };\n};\n\n/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */\nexport const parseBigNumberObj = data => {\n  return Object.keys(data).reduce((accum, key) => {\n    const value = data[key];\n    if (value && (value === null || value === void 0 ? void 0 : value.type) === 'BigNumber') {\n      return {\n        ...accum,\n        [key]: ethers.BigNumber.from(value)\n      };\n    }\n    return {\n      ...accum,\n      [key]: value\n    };\n  }, {});\n};","map":{"version":3,"names":["request","gql","GRAPH_API_PREDICTION","ethers","BetPosition","PredictionStatus","multicallv2","predictionsAbi","getPredictionsAddress","getRoundBaseFields","getBetBaseFields","getUserBaseFields","Result","numberOrNull","value","valueNum","Number","isNaN","transformBetResponse","betResponse","bet","id","hash","amount","parseFloat","position","BULL","BEAR","claimed","claimedHash","user","address","block","totalBets","totalBNB","round","transformRoundResponse","roundResponse","epoch","failed","startBlock","startAt","lockAt","lockBlock","lockPrice","endBlock","closePrice","totalAmount","bullBets","bearBets","bearAmount","bullAmount","bets","getRoundPosition","positionResponse","map","transformTotalWonResponse","marketResponse","houseRounds","reduce","accum","totalBNBTreasury","Math","max","getRoundResult","currentEpoch","CANCELED","LIVE","roundResultPosition","WIN","LOSE","getCanClaim","getUnclaimedWinningBets","filter","getTotalWon","response","HOUSE","market","rounds","getBetHistory","where","first","skip","getBet","betId","toLowerCase","getLedgerData","account","epochs","ledgerCalls","name","params","getClaimStatuses","claimableCalls","claimableResponses","ledgerResponses","claimableResponse","index","claimable","gt","getPredictionData","staticCalls","method","intervalBlocks","minBetAmount","paused","bufferBlocks","rewardRate","status","PAUSED","toNumber","toString","getRoundsData","calls","makeFutureRoundResponse","BigNumber","from","toJSON","rewardBaseCalAmount","rewardAmount","oracleCalled","makeRoundData","serializePredictionsLedgerResponse","ledgerResponse","makeLedgerData","ledgers","eq","serializePredictionsRoundsResponse","parseBigNumberObj","data","Object","keys","key","type"],"sources":["C:/Users/frkul/Documents/swapUI_pancake-frontend/src/state/predictions/helpers.ts"],"sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints'\r\nimport { ethers } from 'ethers'\r\nimport {\r\n  Bet,\r\n  LedgerData,\r\n  BetPosition,\r\n  PredictionsState,\r\n  PredictionStatus,\r\n  ReduxNodeLedger,\r\n  ReduxNodeRound,\r\n  Round,\r\n  RoundData,\r\n} from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport predictionsAbi from 'config/abi/predictions.json'\r\nimport { getPredictionsAddress } from 'utils/addressHelpers'\r\nimport { PredictionsClaimableResponse, PredictionsLedgerResponse, PredictionsRoundsResponse } from 'utils/types'\r\nimport {\r\n  BetResponse,\r\n  getRoundBaseFields,\r\n  getBetBaseFields,\r\n  getUserBaseFields,\r\n  RoundResponse,\r\n  TotalWonMarketResponse,\r\n  TotalWonRoundResponse,\r\n} from './queries'\r\n\r\nexport enum Result {\r\n  WIN = 'win',\r\n  LOSE = 'lose',\r\n  CANCELED = 'canceled',\r\n  LIVE = 'live',\r\n}\r\n\r\nexport const numberOrNull = (value: string) => {\r\n  if (value === null) {\r\n    return null\r\n  }\r\n\r\n  const valueNum = Number(value)\r\n  return Number.isNaN(valueNum) ? null : valueNum\r\n}\r\n\r\nexport const transformBetResponse = (betResponse: BetResponse): Bet => {\r\n  const bet = {\r\n    id: betResponse.id,\r\n    hash: betResponse.hash,\r\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\r\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\r\n    claimed: betResponse.claimed,\r\n    claimedHash: betResponse.claimedHash,\r\n    user: {\r\n      id: betResponse.user.id,\r\n      address: betResponse.user.address,\r\n      block: numberOrNull(betResponse.user.block),\r\n      totalBets: numberOrNull(betResponse.user.totalBets),\r\n      totalBNB: numberOrNull(betResponse.user.totalBNB),\r\n    },\r\n  } as Bet\r\n\r\n  if (betResponse.round) {\r\n    bet.round = transformRoundResponse(betResponse.round)\r\n  }\r\n\r\n  return bet\r\n}\r\n\r\nexport const transformRoundResponse = (roundResponse: RoundResponse): Round => {\r\n  const {\r\n    id,\r\n    epoch,\r\n    failed,\r\n    startBlock,\r\n    startAt,\r\n    lockAt,\r\n    lockBlock,\r\n    lockPrice,\r\n    endBlock,\r\n    closePrice,\r\n    totalBets,\r\n    totalAmount,\r\n    bullBets,\r\n    bearBets,\r\n    bearAmount,\r\n    bullAmount,\r\n    position,\r\n    bets = [],\r\n  } = roundResponse\r\n\r\n  const getRoundPosition = (positionResponse: string) => {\r\n    if (positionResponse === 'Bull') {\r\n      return BetPosition.BULL\r\n    }\r\n\r\n    if (positionResponse === 'Bear') {\r\n      return BetPosition.BEAR\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  return {\r\n    id,\r\n    failed,\r\n    epoch: numberOrNull(epoch),\r\n    startBlock: numberOrNull(startBlock),\r\n    startAt: numberOrNull(startAt),\r\n    lockAt: numberOrNull(lockAt),\r\n    lockBlock: numberOrNull(lockBlock),\r\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\r\n    endBlock: numberOrNull(endBlock),\r\n    closePrice: closePrice ? parseFloat(closePrice) : null,\r\n    totalBets: numberOrNull(totalBets),\r\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\r\n    bullBets: numberOrNull(bullBets),\r\n    bearBets: numberOrNull(bearBets),\r\n    bearAmount: numberOrNull(bearAmount),\r\n    bullAmount: numberOrNull(bullAmount),\r\n    position: getRoundPosition(position),\r\n    bets: bets.map(transformBetResponse),\r\n  }\r\n}\r\n\r\nexport const transformTotalWonResponse = (\r\n  marketResponse: TotalWonMarketResponse,\r\n  roundResponse: TotalWonRoundResponse[],\r\n): number => {\r\n  const houseRounds = roundResponse.reduce((accum, round) => {\r\n    return accum + (round.totalAmount ? parseFloat(round.totalAmount) : 0)\r\n  }, 0)\r\n\r\n  const totalBNB = marketResponse.totalBNB ? parseFloat(marketResponse.totalBNB) : 0\r\n  const totalBNBTreasury = marketResponse.totalBNBTreasury ? parseFloat(marketResponse.totalBNBTreasury) : 0\r\n\r\n  return Math.max(totalBNB - (totalBNBTreasury + houseRounds), 0)\r\n}\r\n\r\nexport const getRoundResult = (bet: Bet, currentEpoch: number): Result => {\r\n  const { round } = bet\r\n  if (round.failed) {\r\n    return Result.CANCELED\r\n  }\r\n\r\n  if (round.epoch >= currentEpoch - 1) {\r\n    return Result.LIVE\r\n  }\r\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR\r\n\r\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE\r\n}\r\n\r\n/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */\r\nexport const getCanClaim = (bet: Bet) => {\r\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true)\r\n}\r\n\r\n/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */\r\nexport const getUnclaimedWinningBets = (bets: Bet[]): Bet[] => {\r\n  return bets.filter(getCanClaim)\r\n}\r\n\r\nexport const getTotalWon = async (): Promise<number> => {\r\n  const response = (await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getTotalWonData($position: String) {\r\n        market(id: 1) {\r\n          totalBNB\r\n          totalBNBTreasury\r\n        }\r\n        rounds(where: { position: $position }) {\r\n          totalAmount\r\n        }\r\n      }\r\n    `,\r\n    { position: BetPosition.HOUSE },\r\n  )) as { market: TotalWonMarketResponse; rounds: TotalWonRoundResponse[] }\r\n\r\n  return transformTotalWonResponse(response.market, response.rounds)\r\n}\r\n\r\ntype BetHistoryWhereClause = Record<string, string | number | boolean | string[]>\r\n\r\nexport const getBetHistory = async (\r\n  where: BetHistoryWhereClause = {},\r\n  first = 1000,\r\n  skip = 0,\r\n): Promise<BetResponse[]> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\r\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n    `,\r\n    { first, skip, where },\r\n  )\r\n  return response.bets\r\n}\r\n\r\nexport const getBet = async (betId: string): Promise<BetResponse> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBet($id: ID!) {\r\n        bet(id: $id) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n  `,\r\n    {\r\n      id: betId.toLowerCase(),\r\n    },\r\n  )\r\n  return response.bet\r\n}\r\n\r\n// V2 REFACTOR\r\nexport const getLedgerData = async (account: string, epochs: number[]) => {\r\n  const address = getPredictionsAddress()\r\n  const ledgerCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'ledger',\r\n    params: [epoch, account],\r\n  }))\r\n  const response = await multicallv2<PredictionsLedgerResponse[]>(predictionsAbi, ledgerCalls)\r\n  return response\r\n}\r\n\r\nexport const getClaimStatuses = async (\r\n  account: string,\r\n  epochs: number[],\r\n): Promise<PredictionsState['claimableStatuses']> => {\r\n  const address = getPredictionsAddress()\r\n  const claimableCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'claimable',\r\n    params: [epoch, account],\r\n  }))\r\n  const claimableResponses = await multicallv2<[PredictionsClaimableResponse][]>(predictionsAbi, claimableCalls)\r\n\r\n  // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\r\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\r\n  // This can be removed in Predictions V2\r\n  const ledgerResponses = await getLedgerData(account, epochs)\r\n\r\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\r\n    const { amount, claimed } = ledgerResponses[index]\r\n    const epoch = epochs[index]\r\n    const [claimable] = claimableResponse\r\n\r\n    return {\r\n      ...accum,\r\n      [epoch]: claimable && amount.gt(0) && !claimed,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport type MarketData = Pick<\r\n  PredictionsState,\r\n  'status' | 'currentEpoch' | 'intervalBlocks' | 'bufferBlocks' | 'minBetAmount' | 'rewardRate'\r\n>\r\nexport const getPredictionData = async (): Promise<MarketData> => {\r\n  const address = getPredictionsAddress()\r\n  const staticCalls = ['currentEpoch', 'intervalBlocks', 'minBetAmount', 'paused', 'bufferBlocks', 'rewardRate'].map(\r\n    (method) => ({\r\n      address,\r\n      name: method,\r\n    }),\r\n  )\r\n  const [[currentEpoch], [intervalBlocks], [minBetAmount], [paused], [bufferBlocks], [rewardRate]] = await multicallv2(\r\n    predictionsAbi,\r\n    staticCalls,\r\n  )\r\n\r\n  return {\r\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\r\n    currentEpoch: currentEpoch.toNumber(),\r\n    intervalBlocks: intervalBlocks.toNumber(),\r\n    bufferBlocks: bufferBlocks.toNumber(),\r\n    minBetAmount: minBetAmount.toString(),\r\n    rewardRate: rewardRate.toNumber(),\r\n  }\r\n}\r\n\r\nexport const getRoundsData = async (epochs: number[]): Promise<PredictionsRoundsResponse[]> => {\r\n  const address = getPredictionsAddress()\r\n  const calls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'rounds',\r\n    params: [epoch],\r\n  }))\r\n  const response = await multicallv2<PredictionsRoundsResponse[]>(predictionsAbi, calls)\r\n  return response\r\n}\r\n\r\nexport const makeFutureRoundResponse = (epoch: number, startBlock: number): ReduxNodeRound => {\r\n  return {\r\n    epoch,\r\n    startBlock,\r\n    lockBlock: null,\r\n    endBlock: null,\r\n    lockPrice: null,\r\n    closePrice: null,\r\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\r\n    oracleCalled: false,\r\n  }\r\n}\r\n\r\nexport const makeRoundData = (rounds: ReduxNodeRound[]): RoundData => {\r\n  return rounds.reduce((accum, round) => {\r\n    return {\r\n      ...accum,\r\n      [round.epoch.toString()]: round,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport const serializePredictionsLedgerResponse = (ledgerResponse: PredictionsLedgerResponse): ReduxNodeLedger => ({\r\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\r\n  amount: ledgerResponse.amount.toJSON(),\r\n  claimed: ledgerResponse.claimed,\r\n})\r\n\r\nexport const makeLedgerData = (account: string, ledgers: PredictionsLedgerResponse[], epochs: number[]): LedgerData => {\r\n  return ledgers.reduce((accum, ledgerResponse, index) => {\r\n    if (!ledgerResponse) {\r\n      return accum\r\n    }\r\n\r\n    // If the amount is zero that means the user did not bet\r\n    if (ledgerResponse.amount.eq(0)) {\r\n      return accum\r\n    }\r\n\r\n    const epoch = epochs[index].toString()\r\n\r\n    return {\r\n      ...accum,\r\n      [account]: {\r\n        ...accum[account],\r\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse),\r\n      },\r\n    }\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */\r\nexport const serializePredictionsRoundsResponse = (response: PredictionsRoundsResponse): ReduxNodeRound => {\r\n  const {\r\n    epoch,\r\n    startBlock,\r\n    lockBlock,\r\n    endBlock,\r\n    lockPrice,\r\n    closePrice,\r\n    totalAmount,\r\n    bullAmount,\r\n    bearAmount,\r\n    rewardAmount,\r\n    rewardBaseCalAmount,\r\n    oracleCalled,\r\n  } = response\r\n\r\n  return {\r\n    epoch: epoch.toNumber(),\r\n    startBlock: startBlock.toNumber(),\r\n    lockBlock: lockBlock.toNumber(),\r\n    endBlock: endBlock.toNumber(),\r\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\r\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\r\n    totalAmount: totalAmount.toJSON(),\r\n    bullAmount: bullAmount.toJSON(),\r\n    bearAmount: bearAmount.toJSON(),\r\n    rewardAmount: rewardAmount.toJSON(),\r\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\r\n    oracleCalled,\r\n  }\r\n}\r\n\r\n/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */\r\nexport const parseBigNumberObj = <T = Record<string, any>, K = Record<string, any>>(data: T): K => {\r\n  return Object.keys(data).reduce((accum, key) => {\r\n    const value = data[key]\r\n\r\n    if (value && value?.type === 'BigNumber') {\r\n      return {\r\n        ...accum,\r\n        [key]: ethers.BigNumber.from(value),\r\n      }\r\n    }\r\n\r\n    return {\r\n      ...accum,\r\n      [key]: value,\r\n    }\r\n  }, {}) as K\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}