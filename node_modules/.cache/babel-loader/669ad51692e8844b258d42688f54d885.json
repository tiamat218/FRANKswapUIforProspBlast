{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport BigNumber from 'bignumber.js';\nimport { LotteryStatus } from 'config/constants/types';\nimport lotteryV2Abi from 'config/abi/lotteryV2.json';\nimport { getLotteryV2Address } from 'utils/addressHelpers';\nimport { multicallv2 } from 'utils/multicall';\nimport { getLotteryV2Contract } from 'utils/contractHelpers';\nimport { useMemo } from 'react';\nimport { ethersToSerializedBigNumber } from 'utils/bigNumber';\nimport { NUM_ROUNDS_TO_FETCH_FROM_NODES } from 'config/constants/lottery';\nconst lotteryContract = getLotteryV2Contract(); // Variable used to determine how many past rounds should be populated by node data rather than subgraph\n\nconst processViewLotterySuccessResponse = (response, lotteryId) => {\n  const {\n    status,\n    startTime,\n    endTime,\n    priceTicketInCake,\n    discountDivisor,\n    treasuryFee,\n    firstTicketId,\n    lastTicketId,\n    amountCollectedInCake,\n    finalNumber,\n    cakePerBracket,\n    countWinnersPerBracket,\n    rewardsBreakdown\n  } = response;\n  const statusKey = Object.keys(LotteryStatus)[status];\n  const serializedCakePerBracket = cakePerBracket.map(cakeInBracket => ethersToSerializedBigNumber(cakeInBracket));\n  const serializedCountWinnersPerBracket = countWinnersPerBracket.map(winnersInBracket => ethersToSerializedBigNumber(winnersInBracket));\n  const serializedRewardsBreakdown = rewardsBreakdown.map(reward => ethersToSerializedBigNumber(reward));\n  return {\n    isLoading: false,\n    lotteryId,\n    status: LotteryStatus[statusKey],\n    startTime: startTime === null || startTime === void 0 ? void 0 : startTime.toString(),\n    endTime: endTime === null || endTime === void 0 ? void 0 : endTime.toString(),\n    priceTicketInCake: ethersToSerializedBigNumber(priceTicketInCake),\n    discountDivisor: discountDivisor === null || discountDivisor === void 0 ? void 0 : discountDivisor.toString(),\n    treasuryFee: treasuryFee === null || treasuryFee === void 0 ? void 0 : treasuryFee.toString(),\n    firstTicketId: firstTicketId === null || firstTicketId === void 0 ? void 0 : firstTicketId.toString(),\n    lastTicketId: lastTicketId === null || lastTicketId === void 0 ? void 0 : lastTicketId.toString(),\n    amountCollectedInCake: ethersToSerializedBigNumber(amountCollectedInCake),\n    finalNumber,\n    cakePerBracket: serializedCakePerBracket,\n    countWinnersPerBracket: serializedCountWinnersPerBracket,\n    rewardsBreakdown: serializedRewardsBreakdown\n  };\n};\n\nconst processViewLotteryErrorResponse = lotteryId => {\n  return {\n    isLoading: true,\n    lotteryId,\n    status: LotteryStatus.PENDING,\n    startTime: '',\n    endTime: '',\n    priceTicketInCake: '',\n    discountDivisor: '',\n    treasuryFee: '',\n    firstTicketId: '',\n    lastTicketId: '',\n    amountCollectedInCake: '',\n    finalNumber: null,\n    cakePerBracket: [],\n    countWinnersPerBracket: [],\n    rewardsBreakdown: []\n  };\n};\n\nexport const fetchLottery = async lotteryId => {\n  try {\n    const lotteryData = await lotteryContract.viewLottery(lotteryId);\n    return processViewLotterySuccessResponse(lotteryData, lotteryId);\n  } catch (error) {\n    return processViewLotteryErrorResponse(lotteryId);\n  }\n};\nexport const fetchMultipleLotteries = async lotteryIds => {\n  const calls = lotteryIds.map(id => ({\n    name: 'viewLottery',\n    address: getLotteryV2Address(),\n    params: [id]\n  }));\n\n  try {\n    const multicallRes = await multicallv2(lotteryV2Abi, calls, {\n      requireSuccess: false\n    });\n    const processedResponses = multicallRes.map((res, index) => processViewLotterySuccessResponse(res[0], lotteryIds[index]));\n    return processedResponses;\n  } catch (error) {\n    console.error(error);\n    return calls.map((call, index) => processViewLotteryErrorResponse(lotteryIds[index]));\n  }\n};\nexport const fetchCurrentLotteryIdAndMaxBuy = async () => {\n  try {\n    const calls = ['currentLotteryId', 'maxNumberTicketsPerBuyOrClaim'].map(method => ({\n      address: getLotteryV2Address(),\n      name: method\n    }));\n    const [[currentLotteryId], [maxNumberTicketsPerBuyOrClaim]] = await multicallv2(lotteryV2Abi, calls);\n    return {\n      currentLotteryId: currentLotteryId ? currentLotteryId.toString() : null,\n      maxNumberTicketsPerBuyOrClaim: maxNumberTicketsPerBuyOrClaim ? maxNumberTicketsPerBuyOrClaim.toString() : null\n    };\n  } catch (error) {\n    return {\n      currentLotteryId: null,\n      maxNumberTicketsPerBuyOrClaim: null\n    };\n  }\n};\nexport const getRoundIdsArray = currentLotteryId => {\n  const currentIdAsInt = parseInt(currentLotteryId, 10);\n  const roundIds = [];\n\n  for (let i = 0; i < NUM_ROUNDS_TO_FETCH_FROM_NODES; i++) {\n    roundIds.push(currentIdAsInt - i);\n  }\n\n  return roundIds.map(roundId => roundId.toString());\n};\nexport const useProcessLotteryResponse = lotteryData => {\n  _s();\n\n  const {\n    priceTicketInCake: priceTicketInCakeAsString,\n    discountDivisor: discountDivisorAsString,\n    amountCollectedInCake: amountCollectedInCakeAsString\n  } = lotteryData;\n  const discountDivisor = useMemo(() => {\n    return new BigNumber(discountDivisorAsString);\n  }, [discountDivisorAsString]);\n  const priceTicketInCake = useMemo(() => {\n    return new BigNumber(priceTicketInCakeAsString);\n  }, [priceTicketInCakeAsString]);\n  const amountCollectedInCake = useMemo(() => {\n    return new BigNumber(amountCollectedInCakeAsString);\n  }, [amountCollectedInCakeAsString]);\n  return {\n    isLoading: lotteryData.isLoading,\n    lotteryId: lotteryData.lotteryId,\n    userTickets: lotteryData.userTickets,\n    status: lotteryData.status,\n    startTime: lotteryData.startTime,\n    endTime: lotteryData.endTime,\n    priceTicketInCake,\n    discountDivisor,\n    treasuryFee: lotteryData.treasuryFee,\n    firstTicketId: lotteryData.firstTicketId,\n    lastTicketId: lotteryData.lastTicketId,\n    amountCollectedInCake,\n    finalNumber: lotteryData.finalNumber,\n    cakePerBracket: lotteryData.cakePerBracket,\n    countWinnersPerBracket: lotteryData.countWinnersPerBracket,\n    rewardsBreakdown: lotteryData.rewardsBreakdown\n  };\n};\n\n_s(useProcessLotteryResponse, \"FnUdVBB2odZtpXQPLId0yuHMXOU=\");\n\nexport const hasRoundBeenClaimed = tickets => {\n  const claimedTickets = tickets.filter(ticket => ticket.status);\n  return claimedTickets.length > 0;\n};","map":{"version":3,"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/state/lottery/helpers.ts"],"names":["BigNumber","LotteryStatus","lotteryV2Abi","getLotteryV2Address","multicallv2","getLotteryV2Contract","useMemo","ethersToSerializedBigNumber","NUM_ROUNDS_TO_FETCH_FROM_NODES","lotteryContract","processViewLotterySuccessResponse","response","lotteryId","status","startTime","endTime","priceTicketInCake","discountDivisor","treasuryFee","firstTicketId","lastTicketId","amountCollectedInCake","finalNumber","cakePerBracket","countWinnersPerBracket","rewardsBreakdown","statusKey","Object","keys","serializedCakePerBracket","map","cakeInBracket","serializedCountWinnersPerBracket","winnersInBracket","serializedRewardsBreakdown","reward","isLoading","toString","processViewLotteryErrorResponse","PENDING","fetchLottery","lotteryData","viewLottery","error","fetchMultipleLotteries","lotteryIds","calls","id","name","address","params","multicallRes","requireSuccess","processedResponses","res","index","console","call","fetchCurrentLotteryIdAndMaxBuy","method","currentLotteryId","maxNumberTicketsPerBuyOrClaim","getRoundIdsArray","currentIdAsInt","parseInt","roundIds","i","push","roundId","useProcessLotteryResponse","priceTicketInCakeAsString","discountDivisorAsString","amountCollectedInCakeAsString","userTickets","hasRoundBeenClaimed","tickets","claimedTickets","filter","ticket","length"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\r\nimport { ethers } from 'ethers'\r\nimport { LotteryStatus, LotteryTicket } from 'config/constants/types'\r\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\r\nimport { getLotteryV2Address } from 'utils/addressHelpers'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport { LotteryRound, LotteryRoundUserTickets, LotteryResponse } from 'state/types'\r\nimport { getLotteryV2Contract } from 'utils/contractHelpers'\r\nimport { useMemo } from 'react'\r\nimport { ethersToSerializedBigNumber } from 'utils/bigNumber'\r\nimport { NUM_ROUNDS_TO_FETCH_FROM_NODES } from 'config/constants/lottery'\r\n\r\nconst lotteryContract = getLotteryV2Contract()\r\n// Variable used to determine how many past rounds should be populated by node data rather than subgraph\r\n\r\nconst processViewLotterySuccessResponse = (response, lotteryId: string): LotteryResponse => {\r\n  const {\r\n    status,\r\n    startTime,\r\n    endTime,\r\n    priceTicketInCake,\r\n    discountDivisor,\r\n    treasuryFee,\r\n    firstTicketId,\r\n    lastTicketId,\r\n    amountCollectedInCake,\r\n    finalNumber,\r\n    cakePerBracket,\r\n    countWinnersPerBracket,\r\n    rewardsBreakdown,\r\n  } = response\r\n\r\n  const statusKey = Object.keys(LotteryStatus)[status]\r\n  const serializedCakePerBracket = cakePerBracket.map((cakeInBracket) => ethersToSerializedBigNumber(cakeInBracket))\r\n  const serializedCountWinnersPerBracket = countWinnersPerBracket.map((winnersInBracket) =>\r\n    ethersToSerializedBigNumber(winnersInBracket),\r\n  )\r\n  const serializedRewardsBreakdown = rewardsBreakdown.map((reward) => ethersToSerializedBigNumber(reward))\r\n\r\n  return {\r\n    isLoading: false,\r\n    lotteryId,\r\n    status: LotteryStatus[statusKey],\r\n    startTime: startTime?.toString(),\r\n    endTime: endTime?.toString(),\r\n    priceTicketInCake: ethersToSerializedBigNumber(priceTicketInCake),\r\n    discountDivisor: discountDivisor?.toString(),\r\n    treasuryFee: treasuryFee?.toString(),\r\n    firstTicketId: firstTicketId?.toString(),\r\n    lastTicketId: lastTicketId?.toString(),\r\n    amountCollectedInCake: ethersToSerializedBigNumber(amountCollectedInCake),\r\n    finalNumber,\r\n    cakePerBracket: serializedCakePerBracket,\r\n    countWinnersPerBracket: serializedCountWinnersPerBracket,\r\n    rewardsBreakdown: serializedRewardsBreakdown,\r\n  }\r\n}\r\n\r\nconst processViewLotteryErrorResponse = (lotteryId: string): LotteryResponse => {\r\n  return {\r\n    isLoading: true,\r\n    lotteryId,\r\n    status: LotteryStatus.PENDING,\r\n    startTime: '',\r\n    endTime: '',\r\n    priceTicketInCake: '',\r\n    discountDivisor: '',\r\n    treasuryFee: '',\r\n    firstTicketId: '',\r\n    lastTicketId: '',\r\n    amountCollectedInCake: '',\r\n    finalNumber: null,\r\n    cakePerBracket: [],\r\n    countWinnersPerBracket: [],\r\n    rewardsBreakdown: [],\r\n  }\r\n}\r\n\r\nexport const fetchLottery = async (lotteryId: string): Promise<LotteryResponse> => {\r\n  try {\r\n    const lotteryData = await lotteryContract.viewLottery(lotteryId)\r\n    return processViewLotterySuccessResponse(lotteryData, lotteryId)\r\n  } catch (error) {\r\n    return processViewLotteryErrorResponse(lotteryId)\r\n  }\r\n}\r\n\r\nexport const fetchMultipleLotteries = async (lotteryIds: string[]): Promise<LotteryResponse[]> => {\r\n  const calls = lotteryIds.map((id) => ({\r\n    name: 'viewLottery',\r\n    address: getLotteryV2Address(),\r\n    params: [id],\r\n  }))\r\n  try {\r\n    const multicallRes = await multicallv2(lotteryV2Abi, calls, { requireSuccess: false })\r\n    const processedResponses = multicallRes.map((res, index) =>\r\n      processViewLotterySuccessResponse(res[0], lotteryIds[index]),\r\n    )\r\n    return processedResponses\r\n  } catch (error) {\r\n    console.error(error)\r\n    return calls.map((call, index) => processViewLotteryErrorResponse(lotteryIds[index]))\r\n  }\r\n}\r\n\r\nexport const fetchCurrentLotteryIdAndMaxBuy = async () => {\r\n  try {\r\n    const calls = ['currentLotteryId', 'maxNumberTicketsPerBuyOrClaim'].map((method) => ({\r\n      address: getLotteryV2Address(),\r\n      name: method,\r\n    }))\r\n    const [[currentLotteryId], [maxNumberTicketsPerBuyOrClaim]] = (await multicallv2(\r\n      lotteryV2Abi,\r\n      calls,\r\n    )) as ethers.BigNumber[][]\r\n\r\n    return {\r\n      currentLotteryId: currentLotteryId ? currentLotteryId.toString() : null,\r\n      maxNumberTicketsPerBuyOrClaim: maxNumberTicketsPerBuyOrClaim ? maxNumberTicketsPerBuyOrClaim.toString() : null,\r\n    }\r\n  } catch (error) {\r\n    return {\r\n      currentLotteryId: null,\r\n      maxNumberTicketsPerBuyOrClaim: null,\r\n    }\r\n  }\r\n}\r\n\r\nexport const getRoundIdsArray = (currentLotteryId: string): string[] => {\r\n  const currentIdAsInt = parseInt(currentLotteryId, 10)\r\n  const roundIds = []\r\n  for (let i = 0; i < NUM_ROUNDS_TO_FETCH_FROM_NODES; i++) {\r\n    roundIds.push(currentIdAsInt - i)\r\n  }\r\n  return roundIds.map((roundId) => roundId.toString())\r\n}\r\n\r\nexport const useProcessLotteryResponse = (\r\n  lotteryData: LotteryResponse & { userTickets?: LotteryRoundUserTickets },\r\n): LotteryRound => {\r\n  const {\r\n    priceTicketInCake: priceTicketInCakeAsString,\r\n    discountDivisor: discountDivisorAsString,\r\n    amountCollectedInCake: amountCollectedInCakeAsString,\r\n  } = lotteryData\r\n\r\n  const discountDivisor = useMemo(() => {\r\n    return new BigNumber(discountDivisorAsString)\r\n  }, [discountDivisorAsString])\r\n\r\n  const priceTicketInCake = useMemo(() => {\r\n    return new BigNumber(priceTicketInCakeAsString)\r\n  }, [priceTicketInCakeAsString])\r\n\r\n  const amountCollectedInCake = useMemo(() => {\r\n    return new BigNumber(amountCollectedInCakeAsString)\r\n  }, [amountCollectedInCakeAsString])\r\n\r\n  return {\r\n    isLoading: lotteryData.isLoading,\r\n    lotteryId: lotteryData.lotteryId,\r\n    userTickets: lotteryData.userTickets,\r\n    status: lotteryData.status,\r\n    startTime: lotteryData.startTime,\r\n    endTime: lotteryData.endTime,\r\n    priceTicketInCake,\r\n    discountDivisor,\r\n    treasuryFee: lotteryData.treasuryFee,\r\n    firstTicketId: lotteryData.firstTicketId,\r\n    lastTicketId: lotteryData.lastTicketId,\r\n    amountCollectedInCake,\r\n    finalNumber: lotteryData.finalNumber,\r\n    cakePerBracket: lotteryData.cakePerBracket,\r\n    countWinnersPerBracket: lotteryData.countWinnersPerBracket,\r\n    rewardsBreakdown: lotteryData.rewardsBreakdown,\r\n  }\r\n}\r\n\r\nexport const hasRoundBeenClaimed = (tickets: LotteryTicket[]): boolean => {\r\n  const claimedTickets = tickets.filter((ticket) => ticket.status)\r\n  return claimedTickets.length > 0\r\n}\r\n"]},"metadata":{},"sourceType":"module"}