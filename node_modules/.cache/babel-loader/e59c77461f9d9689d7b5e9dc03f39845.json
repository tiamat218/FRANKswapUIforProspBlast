{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$(),\n  _s7 = $RefreshSig$(),\n  _s8 = $RefreshSig$(),\n  _s9 = $RefreshSig$(),\n  _s10 = $RefreshSig$();\n/* eslint-disable no-param-reassign */\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { ETHER, Token, currencyEquals } from '@pancakeswap/sdk';\nimport { useMemo } from 'react';\nimport { arrayify } from 'ethers/lib/utils';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { useDefaultTokenList, useUnsupportedTokenList, useCombinedActiveList, useCombinedInactiveList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\nimport useUserAddedTokens from '../state/user/hooks/useUserAddedTokens';\nimport { isAddress } from '../utils';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nimport { filterTokens } from '../components/SearchModal/filtering';\n\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\nfunction useTokensFromMap(tokenMap, includeUserAdded) {\n  _s();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  return useMemo(() => {\n    if (!chainId) return {};\n\n    /*     const object1 = {\r\n          a: 'somestring',\r\n          b: 42,\r\n          c: false,\r\n        }; */\n\n    /*     // reduce to just tokens\r\n        const mapWithoutUrlspt1 = Object.keys(tokenMap[chainId]);\r\n        \r\n        \r\n        const mapWithoutUrls = mapWithoutUrlspt1.reduce <{ [address: string]: Token }> ((newMap, address) => {\r\n          newMap[address] = tokenMap[chainId][address].token\r\n          return newMap\r\n        }, {})  */\n\n    const mapWithoutUrls = {};\n    if (includeUserAdded) {\n      return userAddedTokens\n      // reduce into all ALL_TOKENS filtered by the current chain\n      .reduce((tokenMap_, token) => {\n        tokenMap_[token.address] = token;\n        return tokenMap_;\n      },\n      // must make a copy because reduce modifies the map, and we do not\n      // want to make a copy in every iteration\n      {\n        ...mapWithoutUrls\n      });\n    }\n    return mapWithoutUrls;\n  }, [chainId, userAddedTokens, includeUserAdded]); //  tokenMap, hier rausgenommen\n}\n_s(useTokensFromMap, \"o7LgZeIx6jncN8Lb8S6zeK0wZEQ=\", false, function () {\n  return [useActiveWeb3React, useUserAddedTokens];\n});\nexport function useDefaultTokens() {\n  _s2();\n  const defaultList = useDefaultTokenList();\n  return useTokensFromMap(defaultList, false);\n}\n_s2(useDefaultTokens, \"KFd6g+TcR728AgRacaW35zCvQZc=\", false, function () {\n  return [useDefaultTokenList, useTokensFromMap];\n});\nexport function useAllTokens() {\n  _s3();\n  const allTokens = useCombinedActiveList();\n  return useTokensFromMap(allTokens, true);\n}\n_s3(useAllTokens, \"jCGW4tI4Rs1UGm9shzKA8VnDJ0A=\", false, function () {\n  return [useCombinedActiveList, useTokensFromMap];\n});\nexport function useAllInactiveTokens() {\n  _s4();\n  // get inactive tokens\n  const inactiveTokensMap = useCombinedInactiveList();\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false);\n\n  // filter out any token that are on active list\n  const activeTokensAddresses = Object.keys(useAllTokens());\n  const filteredInactive = activeTokensAddresses ? Object.keys(inactiveTokens).reduce((newMap, address) => {\n    if (!activeTokensAddresses.includes(address)) {\n      newMap[address] = inactiveTokens[address];\n    }\n    return newMap;\n  }, {}) : inactiveTokens;\n  return filteredInactive;\n}\n_s4(useAllInactiveTokens, \"y9223uP8GCC/3ME2n383kLmFOz4=\", false, function () {\n  return [useCombinedInactiveList, useTokensFromMap, useAllTokens];\n});\nexport function useUnsupportedTokens() {\n  _s5();\n  const unsupportedTokensMap = useUnsupportedTokenList();\n  return useTokensFromMap(unsupportedTokensMap, false);\n}\n_s5(useUnsupportedTokens, \"cfUcH2/tU9tFbaAvFr6x9maL1ms=\", false, function () {\n  return [useUnsupportedTokenList, useTokensFromMap];\n});\nexport function useIsTokenActive(token) {\n  _s6();\n  const activeTokens = useAllTokens();\n  if (!activeTokens || !token) {\n    return false;\n  }\n  return !!activeTokens[token.address];\n}\n\n// used to detect extra search results\n_s6(useIsTokenActive, \"/DZnqUeqi963rU8m84lshLFLG1g=\", false, function () {\n  return [useAllTokens];\n});\nexport function useFoundOnInactiveList(searchQuery) {\n  _s7();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const inactiveTokens = useAllInactiveTokens();\n  return useMemo(() => {\n    if (!chainId || searchQuery === '') {\n      return undefined;\n    }\n    const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n    return tokens;\n  }, [chainId, inactiveTokens, searchQuery]);\n}\n\n// Check if currency is included in custom list from user storage\n_s7(useFoundOnInactiveList, \"hwNPd01dv/ucAD4kWZcYbreBqQU=\", false, function () {\n  return [useActiveWeb3React, useAllInactiveTokens];\n});\nexport function useIsUserAddedToken(currency) {\n  _s8();\n  const userAddedTokens = useUserAddedTokens();\n  if (!currency) {\n    return false;\n  }\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n}\n\n// parse a name or symbol from a token response\n_s8(useIsUserAddedToken, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", false, function () {\n  return [useUserAddedTokens];\n});\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str :\n  // need to check for proper bytes string and valid terminator\n  bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0 ? parseBytes32String(bytes32) : defaultValue;\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress) {\n  _s9();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address || undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address || undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\n_s9(useToken, \"eKyRyOw1MkhB0rg/op393nwat5k=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useTokenContract, useBytes32TokenContract, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\nexport function useCurrency(currencyId) {\n  _s10();\n  const isBNB = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'BNB';\n  const token = useToken(isBNB ? undefined : currencyId);\n  return isBNB ? ETHER : token;\n}\n_s10(useCurrency, \"YdEbLWY6/B/ql2/5vHiby7UXKcg=\", false, function () {\n  return [useToken];\n});","map":{"version":3,"names":["parseBytes32String","ETHER","Token","currencyEquals","useMemo","arrayify","useActiveWeb3React","useDefaultTokenList","useUnsupportedTokenList","useCombinedActiveList","useCombinedInactiveList","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useBytes32TokenContract","useTokenContract","filterTokens","useTokensFromMap","tokenMap","includeUserAdded","_s","chainId","userAddedTokens","mapWithoutUrls","reduce","tokenMap_","token","address","useDefaultTokens","_s2","defaultList","useAllTokens","_s3","allTokens","useAllInactiveTokens","_s4","inactiveTokensMap","inactiveTokens","activeTokensAddresses","Object","keys","filteredInactive","newMap","includes","useUnsupportedTokens","_s5","unsupportedTokensMap","useIsTokenActive","_s6","activeTokens","useFoundOnInactiveList","searchQuery","_s7","undefined","tokens","values","useIsUserAddedToken","currency","_s8","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","_s9","tokenContract","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","_symbol$result","_symbolBytes32$result","_tokenName$result","_tokenNameBytes32$res","useCurrency","currencyId","_s10","isBNB","toUpperCase"],"sources":["C:/Users/Devrim/Documents/FRANKswapUIforProspBlast/src/hooks/Tokens.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\r\nimport { parseBytes32String } from '@ethersproject/strings'\r\nimport { Currency, ETHER, Token, currencyEquals } from '@pancakeswap/sdk'\r\nimport { useMemo } from 'react'\r\nimport { arrayify } from 'ethers/lib/utils'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport {\r\n  TokenAddressMap,\r\n  useDefaultTokenList,\r\n  useUnsupportedTokenList,\r\n  useCombinedActiveList,\r\n  useCombinedInactiveList,\r\n} from '../state/lists/hooks'\r\n\r\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks'\r\nimport useUserAddedTokens from '../state/user/hooks/useUserAddedTokens'\r\nimport { isAddress } from '../utils'\r\n\r\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\r\nimport { filterTokens } from '../components/SearchModal/filtering'\r\n\r\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\r\nfunction useTokensFromMap(tokenMap: TokenAddressMap, includeUserAdded: boolean): { [address: string]: Token } {\r\n  const { chainId } = useActiveWeb3React()\r\n  const userAddedTokens = useUserAddedTokens()\r\n\r\n  return useMemo(() => {\r\n    if (!chainId) return {}\r\n\r\n\r\n/*     const object1 = {\r\n      a: 'somestring',\r\n      b: 42,\r\n      c: false,\r\n    }; */\r\n    \r\n/*     // reduce to just tokens\r\n    const mapWithoutUrlspt1 = Object.keys(tokenMap[chainId]);\r\n    \r\n    \r\n    const mapWithoutUrls = mapWithoutUrlspt1.reduce <{ [address: string]: Token }> ((newMap, address) => {\r\n      newMap[address] = tokenMap[chainId][address].token\r\n      return newMap\r\n    }, {})  */\r\n\r\n    const mapWithoutUrls = {};\r\n\r\n\r\n    if (includeUserAdded) {\r\n      return (\r\n        userAddedTokens\r\n          // reduce into all ALL_TOKENS filtered by the current chain\r\n          .reduce<{ [address: string]: Token }>(\r\n            (tokenMap_, token) => {\r\n              tokenMap_[token.address] = token\r\n              return tokenMap_\r\n            },\r\n            // must make a copy because reduce modifies the map, and we do not\r\n            // want to make a copy in every iteration\r\n            { ...mapWithoutUrls },\r\n          )\r\n      )\r\n    }\r\n\r\n    return mapWithoutUrls\r\n  }, [chainId, userAddedTokens,  includeUserAdded])  //  tokenMap, hier rausgenommen\r\n}\r\n\r\nexport function useDefaultTokens(): { [address: string]: Token } {\r\n  const defaultList = useDefaultTokenList()\r\n  return useTokensFromMap(defaultList, false)\r\n}\r\n\r\nexport function useAllTokens(): { [address: string]: Token } {\r\n  const allTokens = useCombinedActiveList()\r\n  return useTokensFromMap(allTokens, true)\r\n}\r\n\r\nexport function useAllInactiveTokens(): { [address: string]: Token } {\r\n  // get inactive tokens\r\n  const inactiveTokensMap = useCombinedInactiveList()\r\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false)\r\n\r\n  // filter out any token that are on active list\r\n  const activeTokensAddresses = Object.keys(useAllTokens())\r\n  const filteredInactive = activeTokensAddresses\r\n    ? Object.keys(inactiveTokens).reduce<{ [address: string]: Token }>((newMap, address) => {\r\n        if (!activeTokensAddresses.includes(address)) {\r\n          newMap[address] = inactiveTokens[address]\r\n        }\r\n        return newMap\r\n      }, {})\r\n    : inactiveTokens\r\n\r\n  return filteredInactive\r\n}\r\n\r\nexport function useUnsupportedTokens(): { [address: string]: Token } {\r\n  const unsupportedTokensMap = useUnsupportedTokenList()\r\n  return useTokensFromMap(unsupportedTokensMap, false)\r\n}\r\n\r\nexport function useIsTokenActive(token: Token | undefined | null): boolean {\r\n  const activeTokens = useAllTokens()\r\n\r\n  if (!activeTokens || !token) {\r\n    return false\r\n  }\r\n\r\n  return !!activeTokens[token.address]\r\n}\r\n\r\n// used to detect extra search results\r\nexport function useFoundOnInactiveList(searchQuery: string): Token[] | undefined {\r\n  const { chainId } = useActiveWeb3React()\r\n  const inactiveTokens = useAllInactiveTokens()\r\n\r\n  return useMemo(() => {\r\n    if (!chainId || searchQuery === '') {\r\n      return undefined\r\n    }\r\n    const tokens = filterTokens(Object.values(inactiveTokens), searchQuery)\r\n    return tokens\r\n  }, [chainId, inactiveTokens, searchQuery])\r\n}\r\n\r\n// Check if currency is included in custom list from user storage\r\nexport function useIsUserAddedToken(currency: Currency | undefined | null): boolean {\r\n  const userAddedTokens = useUserAddedTokens()\r\n\r\n  if (!currency) {\r\n    return false\r\n  }\r\n\r\n  return !!userAddedTokens.find((token) => currencyEquals(currency, token))\r\n}\r\n\r\n// parse a name or symbol from a token response\r\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\r\n\r\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\r\n  return str && str.length > 0\r\n    ? str\r\n    : // need to check for proper bytes string and valid terminator\r\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\r\n    ? parseBytes32String(bytes32)\r\n    : defaultValue\r\n}\r\n\r\n// undefined if invalid or does not exist\r\n// null if loading\r\n// otherwise returns the token\r\nexport function useToken(tokenAddress?: string): Token | undefined | null {\r\n  const { chainId } = useActiveWeb3React()\r\n  const tokens = useAllTokens()\r\n\r\n  const address = isAddress(tokenAddress)\r\n\r\n  const tokenContract = useTokenContract(address || undefined, false)\r\n  const tokenContractBytes32 = useBytes32TokenContract(address || undefined, false)\r\n  const token: Token | undefined = address ? tokens[address] : undefined\r\n\r\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\r\n  const tokenNameBytes32 = useSingleCallResult(\r\n    token ? undefined : tokenContractBytes32,\r\n    'name',\r\n    undefined,\r\n    NEVER_RELOAD,\r\n  )\r\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\r\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\r\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\r\n\r\n  return useMemo(() => {\r\n    if (token) return token\r\n    if (!chainId || !address) return undefined\r\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\r\n    if (decimals.result) {\r\n      return new Token(\r\n        chainId,\r\n        address,\r\n        decimals.result[0],\r\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\r\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token'),\r\n      )\r\n    }\r\n    return undefined\r\n  }, [\r\n    address,\r\n    chainId,\r\n    decimals.loading,\r\n    decimals.result,\r\n    symbol.loading,\r\n    symbol.result,\r\n    symbolBytes32.result,\r\n    token,\r\n    tokenName.loading,\r\n    tokenName.result,\r\n    tokenNameBytes32.result,\r\n  ])\r\n}\r\n\r\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\r\n  const isBNB = currencyId?.toUpperCase() === 'BNB'\r\n  const token = useToken(isBNB ? undefined : currencyId)\r\n  return isBNB ? ETHER : token\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}